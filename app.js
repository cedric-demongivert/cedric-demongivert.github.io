/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@cedric-demongivert/gl-tool-collection/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@cedric-demongivert/gl-tool-collection/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/View.ts
/**
* A readonly view over a given collection of values.
*/
class View {
    /**
    * Create a new view over an existing collection.
    *
    * @param collection - A collection to wrap.
    */
    constructor(collection) {
        this._collection = collection;
    }
    /**
    * Wrap an existing collection.
    *
    * @param collection - A collection to wrap in a view.
    *
    * @return A view over the given collection.
    */
    static wrap(collection) {
        if (collection instanceof View) {
            return collection;
        }
        else {
            return new View(collection);
        }
    }
    /**
    * @see Collection.size
    */
    get size() {
        return this._collection.size;
    }
    /**
    * @see Collection.isCollection
    */
    get isCollection() {
        return this._collection.isCollection;
    }
    /**
    * @see Collection.get
    */
    get(index) {
        return this._collection.get(index);
    }
    /**
    * @see Collection.has
    */
    has(element) {
        return this._collection.has(element);
    }
    /**
    * @see Collection.indexOf
    */
    indexOf(element) {
        return this._collection.indexOf(element);
    }
    /**
    * @see Collection.equals
    */
    equals(other) {
        return this._collection.equals(other);
    }
    /**
    * @see Collection.iterator
    */
    *[Symbol.iterator]() {
        yield* this._collection;
    }
}

// CONCATENATED MODULE: ./src/bissect.ts
function defaultComparator(left, right) {
    return left < right ? -1 : (left > right ? 1 : 0);
}
/**
* Binary search a given element into an ordered collection and then returns its
* index.
*
* If the given element does not exists into the given collection this method
* will return its insertion index in the form of the negative number :
* (-insertionIndex -1)
*
* @param collection - A collection to search.
* @param value - A value to search.
* @param [comparator = defaultComparator] - A comparison function to use.
*/
function bissect(collection, value, comparator = defaultComparator, offset = 0, size = collection.size) {
    if (size > 0) {
        let left = offset;
        let right = offset + size;
        while (left !== right) {
            const cursor = left + ((right - left) >>> 1);
            const comparison = comparator(value, collection.get(cursor));
            if (comparison === 0) {
                return cursor;
            }
            else if (comparison > 0) {
                left = cursor + 1;
            }
            else {
                right = cursor;
            }
        }
        return -(left + 1);
    }
    else {
        return -1;
    }
}

// CONCATENATED MODULE: ./src/equals.ts
function equals(left, right) {
    if (left == right)
        return true;
    if (left.equals)
        return left.equals(right);
    return false;
}

// CONCATENATED MODULE: ./src/quicksort.ts
function quicksort(collection, comparator, offset, size) { rquicksort(collection, comparator, offset, offset + size - 1); }
function rquicksort(collection, comparator, left, right) {
    if (left < right) {
        const pivot = partition(collection, comparator, left, right);
        rquicksort(collection, comparator, left, pivot);
        rquicksort(collection, comparator, pivot + 1, right);
    }
}
function partition(collection, comparator, left, right) {
    const pivot = collection.get((left + right) >>> 1);
    let lower = left;
    let upper = right;
    do {
        while (comparator(collection.get(lower), pivot) < 0) {
            lower += 1;
        }
        while (comparator(collection.get(upper), pivot) > 0) {
            upper -= 1;
        }
        if (lower >= upper) {
            return upper;
        }
        collection.swap(lower, upper);
    } while (true);
}

// CONCATENATED MODULE: ./src/pack/ArrayPack.ts


class ArrayPack_ArrayPack {
    /**
    * Instanciate a new pack with the given capacity based uppon a javascript array.
    *
    * @param [capacity=16] - The number of elements to preallocate.
    */
    constructor(capacity = 16) {
        this._elements = [];
        /**
        * @see https://v8.dev/blog/elements-kinds?fbclid=IwAR337wb3oxEpjz_5xVHL-Y14gUpVTOztLSIikVVQLGN6qcKidEjMLJ4vO3M
        */
        for (let index = 0; index < capacity; ++index) {
            this._elements.push(null);
        }
        this._size = 0;
    }
    /**
    * Return a copy of another pack.
    *
    * @param toCopy - A pack to copy.
    */
    static copy(toCopy) {
        const result = new ArrayPack_ArrayPack(toCopy.capacity);
        result.size = toCopy.size;
        for (let index = 0, length = toCopy.size; index < length; ++index) {
            result.set(index, toCopy.get(index));
        }
        return result;
    }
    /**
    * @see Collection.size
    */
    get size() {
        return this._size;
    }
    /**
    * @see Pack.size
    */
    set size(value) {
        /**
        * @see https://v8.dev/blog/elements-kinds?fbclid=IwAR337wb3oxEpjz_5xVHL-Y14gUpVTOztLSIikVVQLGN6qcKidEjMLJ4vO3M
        */
        while (value > this._elements.length) {
            this._elements.push(null);
        }
        for (let index = this._size; index < value; ++index) {
            this._elements[index] = null;
        }
        this._size = value;
    }
    /**
    * @see StaticCollection.capacity
    */
    get capacity() {
        return this._elements.length;
    }
    /**
    * @see ReallocableCollection.reallocate
    */
    reallocate(capacity) {
        if (capacity < this._elements.length) {
            this._elements.length = capacity;
            this._size = Math.min(this._size, capacity);
        }
        else {
            /**
            * @see https://v8.dev/blog/elements-kinds?fbclid=IwAR337wb3oxEpjz_5xVHL-Y14gUpVTOztLSIikVVQLGN6qcKidEjMLJ4vO3M
            */
            while (this._elements.length != capacity) {
                this._elements.push(null);
            }
        }
    }
    /**
    * @see ReallocableCollection.fit
    */
    fit() {
        this._elements.length = this._size;
    }
    /**
    * @see Collection.isCollection
    */
    get isCollection() {
        return true;
    }
    /**
    * @see Collection.get
    */
    get(index) {
        return this._elements[index];
    }
    /**
    * @see Pack.sort
    */
    sort(comparator) {
        quicksort(this, comparator, 0, this._size);
    }
    /**
    * @see Pack.swap
    */
    swap(first, second) {
        const tmp = this._elements[first];
        this._elements[first] = this._elements[second];
        this._elements[second] = tmp;
    }
    /**
    * @see Pack.set
    */
    set(index, value) {
        if (index >= this._size)
            this.size = index + 1;
        this._elements[index] = value;
    }
    /**
    * @see Pack.insert
    */
    insert(index, value) {
        if (index >= this._size) {
            this.set(index, value);
        }
        else {
            this.size += 1;
            for (let cursor = this._size - 1; cursor > index; --cursor) {
                this._elements[cursor] = this._elements[cursor - 1];
            }
            this._elements[index] = value;
        }
    }
    /**
    * @see Pack.push
    */
    push(value) {
        const index = this._size;
        this.size += 1;
        this._elements[index] = value;
    }
    /**
    * @see Pack.delete
    */
    delete(index) {
        for (let cursor = index, size = this._size - 1; cursor < size; ++cursor) {
            this._elements[cursor] = this._elements[cursor + 1];
        }
        this.size -= 1;
    }
    /**
    * @see Pack.warp
    */
    warp(index) {
        this._elements[index] = this._elements[this._size - 1];
        this.size -= 1;
    }
    /**
    * @see Collection.has
    */
    has(element) {
        return this.indexOf(element) >= 0;
    }
    /**
    * @see Collection.indexOf
    */
    indexOf(element) {
        for (let index = 0, length = this._size; index < length; ++index) {
            if (equals(element, this._elements[index])) {
                return index;
            }
        }
        return -1;
    }
    /**
    * @see Pack.allocate
    */
    allocate(capacity) {
        return new ArrayPack_ArrayPack(capacity);
    }
    /**
    * @see Pack.clear
    */
    clear() {
        this._size = 0;
    }
    /**
    * @see Collection.iterator
    */
    *[Symbol.iterator]() {
        for (let index = 0, length = this._size; index < length; ++index) {
            yield this._elements[index];
        }
    }
    /**
    * @see Collection.equals
    */
    equals(other) {
        if (other == null)
            return false;
        if (other === this)
            return true;
        if (other.isCollection) {
            if (other.size !== this._size)
                return false;
            for (let index = 0, size = this._size; index < size; ++index) {
                if (!equals(other.get(index), this._elements[index]))
                    return false;
            }
            return true;
        }
        return false;
    }
}
ArrayPack_ArrayPack.DEFAULT_VALUE = null;

// CONCATENATED MODULE: ./src/pack/BufferPack.ts


class BufferPack_BufferPack {
    /**
    * Wrap an existing buffer into a new pack instance.
    *
    * @param buffer - The buffer to wrap, the resulting pack will have the capacity of the given buffer.
    * @param [size = 0] - Initial number of elements in the pack.
    */
    constructor(buffer, size = 0) {
        this._elements = buffer;
        this._size = size;
    }
    /**
    * Return a copy of another pack.
    *
    * @param toCopy - A pack to copy.
    */
    static copy(toCopy) {
        const result = toCopy.allocate(toCopy.capacity);
        result.size = toCopy.size;
        for (let index = 0, length = toCopy.size; index < length; ++index) {
            result.set(index, toCopy.get(index));
        }
        return result;
    }
    /**
    * @return The underlying typed array.
    */
    get array() {
        return this._elements;
    }
    /**
    * @return The underlying buffer.
    */
    get buffer() {
        return this._elements.buffer;
    }
    /**
    * @see Collection.size
    */
    get size() {
        return this._size;
    }
    /**
    * Update the size of this pack.
    *
    * @param value - The new number of elements into this pack.
    */
    set size(value) {
        if (value > this._elements.length) {
            this.reallocate(value);
        }
        for (let index = this._size; index < value; ++index) {
            this._elements[index] = 0;
        }
        this._size = value;
    }
    /**
    * @return The constructor of the underlying typed array.
    */
    get allocator() {
        return this._elements.constructor;
    }
    /**
    * @see StaticCollection.capacity
    */
    get capacity() {
        return this._elements.length;
    }
    /**
    * @see ReallocableCollection.reallocate
    */
    reallocate(capacity) {
        const old = this._elements;
        const oldSize = this._size;
        this._elements = new this.allocator(capacity);
        this._size = Math.min(this._size, capacity);
        for (let index = 0; index < oldSize; ++index) {
            this._elements[index] = old[index];
        }
    }
    /**
    * @see Pack.allocate
    */
    allocate(capacity) {
        return new BufferPack_BufferPack(new this.allocator(capacity));
    }
    /**
    * @see ReallocableCollection.fit
    */
    fit() {
        this.reallocate(this._size);
    }
    /**
    * @see Collection.isCollection
    */
    get isCollection() {
        return true;
    }
    /**
    * @see Collection.get
    */
    get(index) {
        return this._elements[index];
    }
    /**
    * @see Pack.sort
    */
    sort(comparator) {
        quicksort(this, comparator, 0, this._size);
    }
    /**
    * @see Pack.swap
    */
    swap(first, second) {
        const tmp = this._elements[first];
        this._elements[first] = this._elements[second];
        this._elements[second] = tmp;
    }
    /**
    * @see Pack.set
    */
    set(index, value) {
        if (index >= this._size)
            this.size = index + 1;
        this._elements[index] = value;
    }
    /**
    * @see Pack.insert
    */
    insert(index, value) {
        if (index >= this._size) {
            this.set(index, value);
        }
        else {
            this.size += 1;
            for (let cursor = this._size - 1; cursor > index; --cursor) {
                this._elements[cursor] = this._elements[cursor - 1];
            }
            this._elements[index] = value;
        }
    }
    /**
    * @see Pack.push
    */
    push(value) {
        const index = this._size;
        this.size += 1;
        this._elements[index] = value;
    }
    /**
    * @see Pack.delete
    */
    delete(index) {
        for (let cursor = index, size = this._size - 1; cursor < size; ++cursor) {
            this._elements[cursor] = this._elements[cursor + 1];
        }
        this.size -= 1;
    }
    /**
    * @see Pack.warp
    */
    warp(index) {
        this._elements[index] = this._elements[this._size - 1];
        this.size -= 1;
    }
    /**
    * @see Collection.has
    */
    has(element) {
        return this.indexOf(element) >= 0;
    }
    /**
    * @see Collection.indexOf
    */
    indexOf(element) {
        for (let index = 0, length = this._size; index < length; ++index) {
            if (equals(element, this._elements[index])) {
                return index;
            }
        }
        return -1;
    }
    /**
    * Empty this pack of its elements.
    */
    clear() {
        this._size = 0;
    }
    /**
    * @see Collection.iterator
    */
    *[Symbol.iterator]() {
        for (let index = 0, length = this._size; index < length; ++index) {
            yield this._elements[index];
        }
    }
    /**
    * @see Collection.equals
    */
    equals(other) {
        if (other == null)
            return false;
        if (other === this)
            return true;
        if (other.isCollection) {
            if (other.size !== this._size)
                return false;
            for (let index = 0, size = this._size; index < size; ++index) {
                if (!equals(other.get(index), this._elements[index]))
                    return false;
            }
            return true;
        }
        return false;
    }
}
BufferPack_BufferPack.DEFAULT_VALUE = 0;

// CONCATENATED MODULE: ./src/pack/Packs.ts


class Packs_Packs {
    static copy(pack) {
        if (pack == null) {
            return null;
        }
        else {
            return pack.constructor.copy(pack);
        }
    }
    static create(pack, capacity) {
        if (pack == null) {
            return null;
        }
        else {
            return pack.instantiate(capacity);
        }
    }
    static like(existing, capacity) {
        return existing.allocate(capacity);
    }
    static any(capacity) {
        return new ArrayPack_ArrayPack(capacity);
    }
    static uint8(capacity) {
        return new BufferPack_BufferPack(new Uint8Array(capacity));
    }
    static uint16(capacity) {
        return new BufferPack_BufferPack(new Uint16Array(capacity));
    }
    static uint32(capacity) {
        return new BufferPack_BufferPack(new Uint32Array(capacity));
    }
    static upTo(maximum, capacity) {
        if (maximum <= 0xff) {
            return new BufferPack_BufferPack(new Uint8Array(capacity));
        }
        else if (maximum <= 0xffff) {
            return new BufferPack_BufferPack(new Uint16Array(capacity));
        }
        else {
            return new BufferPack_BufferPack(new Uint32Array(capacity));
        }
    }
    static int8(capacity) {
        return new BufferPack_BufferPack(new Int8Array(capacity));
    }
    static int16(capacity) {
        return new BufferPack_BufferPack(new Int16Array(capacity));
    }
    static int32(capacity) {
        return new BufferPack_BufferPack(new Int32Array(capacity));
    }
    static float32(capacity) {
        return new BufferPack_BufferPack(new Float32Array(capacity));
    }
    static float64(capacity) {
        return new BufferPack_BufferPack(new Float64Array(capacity));
    }
}

// CONCATENATED MODULE: ./src/pack/index.ts




// CONCATENATED MODULE: ./src/set/PackSet.ts

class PackSet_PackSet {
    /**
    * Create a new set collection based upon a pack instance.
    *
    * @param pack - An empty pack instance to wrap as a set.
    */
    constructor(elements) {
        this._elements = elements;
    }
    /**
    * Return a copy of a given pack set.
    *
    * @param toCopy - A pack set to copy.
    */
    static copy(toCopy) {
        return new PackSet_PackSet(Packs_Packs.copy(toCopy.elements));
    }
    /**
    * @return This set underlying pack instance.
    */
    get elements() {
        return this._elements;
    }
    /**
    * Change the wrapped pack instance.
    *
    * @param elements - The new pack instance to wrap.
    */
    set elements(elements) {
        this._elements = elements;
    }
    /**
    * @see Collection.isCollection
    */
    get isCollection() {
        return true;
    }
    /**
    * @see Set.isSet
    */
    get isSet() {
        return true;
    }
    /**
    * @see Collection.size
    */
    get size() {
        return this._elements.size;
    }
    /**
    * @see StaticCollection.capacity
    */
    get capacity() {
        return this._elements.capacity;
    }
    /**
    * @see Collection.has
    */
    has(element) {
        return this._elements.has(element);
    }
    /**
    * @see Collection.indexOf
    */
    indexOf(element) {
        return this._elements.indexOf(element);
    }
    /**
    * @see Set.add
    */
    add(element) {
        if (this._elements.indexOf(element) === -1) {
            this._elements.push(element);
        }
    }
    /**
    * @see Set.delete
    */
    delete(element) {
        const index = this._elements.indexOf(element);
        if (index >= 0) {
            this._elements.warp(index);
        }
    }
    /**
    * @see Collection.get
    */
    get(index) {
        return this._elements.get(index);
    }
    /**
    * @see ReallocableCollection.reallocate
    */
    reallocate(capacity) {
        this._elements.reallocate(capacity);
    }
    /**
    * @see ReallocableCollection.fit
    */
    fit() {
        this._elements.fit();
    }
    /**
    * @see Set.clear
    */
    clear() {
        this._elements.clear();
    }
    /**
    * @see Collection.iterator
    */
    *[Symbol.iterator]() {
        yield* this._elements;
    }
    /**
    * @see Collection.equals
    */
    equals(other) {
        if (other == null)
            return false;
        if (other === this)
            return true;
        if (other.isSet) {
            if (other.size !== this._elements.size)
                return false;
            for (let index = 0, length = other.size; index < length; ++index) {
                if (!this.has(other.get(index)))
                    return false;
            }
            return true;
        }
        return false;
    }
}

// CONCATENATED MODULE: ./src/set/PackSparseDenseSet.ts

class PackSparseDenseSet_PackSparseDenseSet {
    /**
    * Return a copy of a given sparse set.
    *
    * @param toCopy - A sparse set to copy.
    */
    static copy(toCopy) {
        const copy = new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.like(toCopy._dense, toCopy.capacity));
        for (let index = 0, size = toCopy.size; index < size; ++index) {
            copy.add(toCopy.get(index));
        }
        return copy;
    }
    /**
    * Create a new empty sparse set based uppon the given pack.
    *
    * @param dense - An empty dense number pack.
    */
    constructor(dense) {
        this._sparse = Packs_Packs.like(dense, dense.capacity);
        this._dense = dense;
    }
    /**
    * @see Collection.isCollection
    */
    get isCollection() {
        return true;
    }
    /**
    * @see Set.isSet
    */
    get isSet() {
        return true;
    }
    /**
    * @see Collection.size
    */
    get size() {
        return this._dense.size;
    }
    /**
    * @see StaticCollection.capacity
    */
    get capacity() {
        return this._dense.capacity;
    }
    /**
    * @see Collection.has
    */
    has(element) {
        const index = this._sparse.get(element);
        return index < this._dense.size && this._dense.get(index) === element;
    }
    /**
    * @see Collection.indexOf
    */
    indexOf(element) {
        const index = this._sparse.get(element);
        if (index < this._dense.size && this._dense.get(index) === element) {
            return index;
        }
        return -1;
    }
    /**
    * @see MutableCollection.add
    */
    add(element) {
        const index = this._sparse.get(element);
        if (index >= this._dense.size || this._dense.get(index) !== element) {
            this._sparse.set(element, this._dense.size);
            this._dense.push(element);
        }
    }
    /**
    * @see MutableCollection.delete
    */
    delete(element) {
        const index = this._sparse.get(element);
        if (index < this._dense.size && this._dense.get(index) === element) {
            const last = this._dense.get(this._dense.size - 1);
            this._dense.warp(index);
            this._sparse.set(last, index);
        }
    }
    /**
    * @see Collection.get
    */
    get(index) {
        return this._dense.get(index);
    }
    /**
    * @see StaticCollection.reallocate
    */
    reallocate(capacity) {
        const oldDense = this._dense;
        const oldSparse = this._sparse;
        this._dense = this._dense.allocate(capacity);
        this._sparse = this._sparse.allocate(capacity);
        for (let index = 0, size = oldDense.size; index < size; ++index) {
            if (oldDense.get(index) < capacity) {
                this._sparse.set(oldDense.get(index), this._dense.size);
                this._dense.push(oldDense.get(index));
            }
        }
    }
    /**
    * @see StaticCollection.fit
    */
    fit() {
        const max = this.max();
        this._dense.reallocate(max + 1);
        this._sparse.reallocate(max + 1);
    }
    /**
    * Return the maximum element of this set.
    *
    * @return The maximum element of this set.
    */
    max() {
        if (this._dense.size <= 0)
            return undefined;
        let result = this._dense.get(0);
        for (let index = 1, length = this._dense.size; index < length; ++index) {
            const cell = this._dense.get(index);
            result = cell > result ? cell : result;
        }
        return result;
    }
    /**
    * Return the minimum element of this set.
    *
    * @return The minimum element of this set.
    */
    min() {
        if (this._dense.size <= 0)
            return undefined;
        let result = this._dense.get(0);
        for (let index = 1, length = this._dense.size; index < length; ++index) {
            const cell = this._dense.get(index);
            result = cell < result ? cell : result;
        }
        return result;
    }
    /**
    * @see MutableCollection.clear
    */
    clear() {
        this._dense.clear();
    }
    /**
    * @see Collection.iterator
    */
    *[Symbol.iterator]() {
        for (let index = 0, length = this._dense.size; index < length; ++index) {
            yield this._dense.get(index);
        }
    }
    /**
    * @see Collection.equals
    */
    equals(other) {
        if (other == null)
            return false;
        if (other === this)
            return true;
        if (other.isSet) {
            if (other.size !== this._dense.size)
                return false;
            for (let index = 0, length = other.size; index < length; ++index) {
                if (!this.has(other.get(index)))
                    return false;
            }
            return true;
        }
        return false;
    }
}

// CONCATENATED MODULE: ./src/set/Sets.ts



class Sets_Sets {
    static copy(pack) {
        return pack == null ? null : pack.constructor.copy(pack);
    }
    static fromPack(pack) {
        return new PackSet_PackSet(pack);
    }
}
Sets_Sets.SparseDense = class {
    static copy(pack) {
        return pack == null ? null : pack.constructor.copy(pack);
    }
    static uint32(capacity) {
        return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.uint32(capacity));
    }
    static uint16(capacity) {
        return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.uint16(capacity));
    }
    static uint8(capacity) {
        return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.uint8(capacity));
    }
    static any(capacity) {
        return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.any(capacity));
    }
    static adaptative(capacity) {
        if (capacity <= 0xff) {
            return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.uint8(capacity));
        }
        else if (capacity <= 0xffff) {
            return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.uint16(capacity));
        }
        else {
            return new PackSparseDenseSet_PackSparseDenseSet(Packs_Packs.uint32(capacity));
        }
    }
};

// CONCATENATED MODULE: ./src/set/index.ts




// CONCATENATED MODULE: ./src/circular/PackCircularBuffer.ts


class PackCircularBuffer_PackCircularBuffer {
    /**
    * Create a new circular buffer uppon an existing pack implementation.
    *
    * @param elements - A pack to use for storing this circular buffer elements.
    */
    constructor(elements) {
        this._elements = elements;
        this._start = 0;
        this._size = elements.size;
        this._elements.size = elements.capacity;
    }
    /**
    * @see Collection.size
    */
    get size() {
        return this._size;
    }
    /**
    * @see StaticCollection.capacity
    */
    get capacity() {
        return this._elements.capacity;
    }
    /**
    * @see ReallocableCollection.reallocate
    */
    reallocate(capacity) {
        const next = Packs_Packs.copy(this._elements);
        next.reallocate(capacity);
        const nextSize = Math.min(capacity, this._size);
        for (let index = 0; index < capacity && index < this._size; ++index) {
            next.set(nextSize - index - 1, this.get(this._size - index - 1));
        }
        this._elements = next;
        this._size = nextSize;
        this._start = 0;
    }
    /**
    * @see ReallocableCollection.fit
    */
    fit() {
        this.reallocate(this._size);
    }
    /**
    * @see Collection.isCollection
    */
    get isCollection() {
        return true;
    }
    /**
    * @see CircularBuffer.isCircularBuffer
    */
    get isCircularBuffer() {
        return true;
    }
    /**
    * @see Collection.get
    */
    get(index) {
        return this._elements.get((this._start + index) % this._elements.capacity);
    }
    /**
    * @see CircularBuffer.swap
    */
    swap(first, second) {
        const rfirst = (this._start + first) % this._elements.capacity;
        const rsecond = (this._start + second) % this._elements.capacity;
        this._elements.swap(rfirst, rsecond);
    }
    /**
    * @see CircularBuffer.set
    */
    set(index, value) {
        if (index >= this._elements.capacity) {
            const offset = Math.min(index - this._elements.capacity + 1, this._size);
            this._start = (this._start + offset) % this._elements.capacity;
            this._size -= offset;
            index = this._elements.capacity - 1;
        }
        while (index >= this._size) {
            this.push(this._elements.constructor.DEFAULT_VALUE);
        }
        this._elements.set((this._start + index) % this._elements.capacity, value);
    }
    /**
    * @see CircularBuffer.insert
    */
    insert(index, value) {
        if (index >= this._size) {
            this.set(index, value);
        }
        else {
            if (this._size == this._elements.capacity) {
                this._start = (this._start + 1) % this._elements.capacity;
                --index;
            }
            else {
                this._size += 1;
            }
            for (let cursor = this._size - 1; cursor > index; --cursor) {
                this.set(cursor, this.get(cursor - 1));
            }
            this.set(index, value);
        }
    }
    /**
    * @see CircularBuffer.push
    */
    push(value) {
        if (this._size < this._elements.capacity) {
            this._elements.set((this._start + this._size) % this._elements.capacity, value);
            this._size += 1;
        }
        else {
            this._elements.set(this._start, value);
            this._start = (this._start + 1) % this._elements.capacity;
        }
    }
    /**
    * @see CircularBuffer.delete
    */
    delete(index) {
        for (let toMove = index; toMove > 0; --toMove) {
            this.set(toMove, this.get(toMove - 1));
        }
        this._start = (this._start + 1) % this._elements.capacity;
        this._size -= 1;
    }
    /**
    * @see CircularBuffer.warp
    */
    warp(index) {
        this.set(index, this.get(0));
        this._start = (this._start + 1) % this._elements.capacity;
        this._size -= 1;
    }
    /**
    * @see Collection.has
    */
    has(element) {
        return this.indexOf(element) >= 0;
    }
    /**
    * @see Collection.indexOf
    */
    indexOf(element) {
        for (let index = 0, length = this._size; index < length; ++index) {
            if (equals(this._elements.get((this._start + index) % this._elements.capacity), element)) {
                return index;
            }
        }
        return -1;
    }
    /**
    * @see CircularBuffer.clear
    */
    clear() {
        this._start = 0;
        this._size = 0;
    }
    /**
    * @see Collection.iterator
    */
    *[Symbol.iterator]() {
        for (let index = 0, length = this._size; index < length; ++index) {
            yield this._elements.get((this._start + index) % this._elements.capacity);
        }
    }
    /**
    * @see Collection.equals
    */
    equals(other) {
        if (other == null)
            return false;
        if (other === this)
            return true;
        if (other.isCollection) {
            if (other.size !== this._size)
                return false;
            for (let index = 0, size = this._size; index < size; ++index) {
                if (!equals(other.get(index), this.get(index)))
                    return false;
            }
            return true;
        }
        return false;
    }
}

// CONCATENATED MODULE: ./src/circular/CircularBuffers.ts

class CircularBuffers_CircularBuffers {
    static copy(buffer) {
        if (buffer == null) {
            return null;
        }
        else {
            return buffer.constructor.copy(buffer);
        }
    }
    static fromPack(pack) {
        return new PackCircularBuffer_PackCircularBuffer(pack);
    }
}

// CONCATENATED MODULE: ./src/circular/index.ts



// CONCATENATED MODULE: ./src/index.ts
/* concated harmony reexport View */__webpack_require__.d(__webpack_exports__, "View", function() { return View; });
/* concated harmony reexport bissect */__webpack_require__.d(__webpack_exports__, "bissect", function() { return bissect; });
/* concated harmony reexport ArrayPack */__webpack_require__.d(__webpack_exports__, "ArrayPack", function() { return ArrayPack_ArrayPack; });
/* concated harmony reexport BufferPack */__webpack_require__.d(__webpack_exports__, "BufferPack", function() { return BufferPack_BufferPack; });
/* concated harmony reexport Packs */__webpack_require__.d(__webpack_exports__, "Packs", function() { return Packs_Packs; });
/* concated harmony reexport PackSet */__webpack_require__.d(__webpack_exports__, "PackSet", function() { return PackSet_PackSet; });
/* concated harmony reexport PackSparseDenseSet */__webpack_require__.d(__webpack_exports__, "PackSparseDenseSet", function() { return PackSparseDenseSet_PackSparseDenseSet; });
/* concated harmony reexport Sets */__webpack_require__.d(__webpack_exports__, "Sets", function() { return Sets_Sets; });
/* concated harmony reexport PackCircularBuffer */__webpack_require__.d(__webpack_exports__, "PackCircularBuffer", function() { return PackCircularBuffer_PackCircularBuffer; });
/* concated harmony reexport CircularBuffers */__webpack_require__.d(__webpack_exports__, "CircularBuffers", function() { return CircularBuffers_CircularBuffers; });







/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/@cedric-demongivert/gl-tool-halfedge/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@cedric-demongivert/gl-tool-halfedge/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! @cedric-demongivert/gl-tool-collection */ "./node_modules/@cedric-demongivert/gl-tool-collection/index.js"));
	else {}
})(this, function(__WEBPACK_EXTERNAL_MODULE__0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/elements.js
var NULL_HALFEDGE = 0xffffffff;
var NULL_VERTEX = 0xffffffff;
var NULL_FACE = 0xffffffff;
// EXTERNAL MODULE: external "@cedric-demongivert/gl-tool-collection"
var gl_tool_collection_ = __webpack_require__(0);

// CONCATENATED MODULE: ./src/FaceBuffer.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var FaceBuffer_FaceBuffer =
/*#__PURE__*/
function () {
  _createClass(FaceBuffer, null, [{
    key: "copy",

    /**
    * Copy the given vertex buffer.
    *
    * @param toCopy - A vertex buffer instance to copy.
    *
    * @return A new vertex buffer equal to the given one.
    */
    value: function copy(toCopy) {
      var result = new FaceBuffer(toCopy.capacity);

      for (var index = 0, size = toCopy.size; index < size; ++index) {
        var face = toCopy.get(index);
        result.declare(face);
        result.setHalfedge(face, toCopy.getHalfedge(face));
      }

      return result;
    }
    /**
    * Does allocate a buffer for storing a given number of faces.
    *
    * @param capacity - The number of faces to be able to store into the resulting buffer.
    */

  }]);

  function FaceBuffer(capacity) {
    _classCallCheck(this, FaceBuffer);

    this._halfedges = gl_tool_collection_["Packs"].uint32(capacity); // TODO:  ADAPTATIVE ALLOCATION

    this._faces = gl_tool_collection_["Sets"].SparseDense.uint32(capacity); // TODO:  ADAPTATIVE ALLOCATION

    this._cursor = 0;
    this._view = gl_tool_collection_["View"].wrap(this._faces);
  }
  /**
  * @return The maximum number of halfedge that this buffer can store.
  */


  _createClass(FaceBuffer, [{
    key: "get",

    /**
    * Return the face at the given index.
    *
    * @param index - Index of the face to return.
    *
    * @return The face at the given index.
    */
    value: function get(index) {
      return this._faces.get(index);
    }
    /**
    * Return true if the given face exists.
    *
    * @param face - The face to check.
    *
    * @return True if the given face exists, false otherwise.
    */

  }, {
    key: "has",
    value: function has(face) {
      return this._faces.has(face);
    }
    /**
    * Insert the given face into this buffer.
    *
    * @param face - The face to insert into this buffer.
    */

  }, {
    key: "declare",
    value: function declare(face) {
      this._faces.add(face);

      this._halfedges.set(face, NULL_HALFEDGE);

      if (face == this._cursor) {
        do {
          this._cursor += 1;
        } while (this._faces.has(this._cursor));
      }
    }
    /**
    * @return The new face that was created.
    */

  }, {
    key: "create",
    value: function create() {
      var next = this._cursor;

      do {
        this._cursor += 1;
      } while (this._faces.has(this._cursor));

      this._faces.add(next);

      this._halfedges.set(next, NULL_HALFEDGE);

      return next;
    }
    /**
    * Remove a face from this buffer.
    *
    * @param face - The face to remove from this buffer.
    */

  }, {
    key: "delete",
    value: function _delete(face) {
      this._faces.delete(face);

      if (face < this._cursor) {
        this._cursor = face;
      }
    }
    /**
    * Return an incident halfedge of the given face.
    *
    * @param face - The face to read.
    *
    * @return An incident halfedge of the given face.
    */

  }, {
    key: "getHalfedge",
    value: function getHalfedge(face) {
      return this._halfedges.get(face);
    }
    /**
    * Return true if the given face has an incident halfedge.
    *
    * @param face - The face to read.
    *
    * @return True if the given face has an incident halfedge.
    */

  }, {
    key: "hasHafledge",
    value: function hasHafledge(face) {
      return this._halfedges.get(face) !== NULL_HALFEDGE;
    }
    /**
    * Update the incident halfedge of an existing face.
    *
    * @param face - The face to update.
    * @param halfedge - An incident halfedge to set for the given face.
    */

  }, {
    key: "setHalfedge",
    value: function setHalfedge(face, halfedge) {
      this._halfedges.set(face, halfedge);
    }
    /**
    * Reallocate this buffer in order to store more or less faces.
    *
    * @param capacity - The new number of faces to be able to store.
    */

  }, {
    key: "reallocate",
    value: function reallocate(capacity) {
      this._faces.reallocate(capacity); // TODO:  ADAPTATIVE REALLOCATION


      this._halfedges.reallocate(capacity); // TODO:  ADAPTATIVE REALLOCATION


      if (capacity < this._cursor) {
        this._cursor = capacity;
      }
    }
    /**
    * Reallocate this buffer in order to fit its capacity to its content.
    */

  }, {
    key: "fit",
    value: function fit() {
      this._faces.fit(); // TODO:  ADAPTATIVE REALLOCATION


      this._halfedges.reallocate(this._faces.capacity); // TODO:  ADAPTATIVE REALLOCATION

    }
    /**
    * Clear this buffer of all of its faces.
    */

  }, {
    key: "clear",
    value: function clear() {
      this._faces.clear();

      this._cursor = 0;
    }
    /**
    * Returns true if both instances are equals.
    *
    * @param other - Other instance to compare to this one.
    */

  }, {
    key: "equals",
    value: function equals(other) {
      if (other == null) return false;
      if (other === this) return true;

      if (other instanceof FaceBuffer) {
        if (other.size !== this.size) return false;
        if (other.capacity !== this.capacity) return false;

        for (var index = 0, size = this.size; index < size; ++index) {
          var face = this.get(index);
          if (!other.has(face)) return false;
          if (other.getHalfedge(face) !== this.getHalfedge(face)) return false;
        }

        return true;
      }
    }
  }, {
    key: "capacity",
    get: function get() {
      return this._faces.capacity;
    }
    /**
    * @return The number of halfedge contained into this buffer.
    */

  }, {
    key: "size",
    get: function get() {
      return this._faces.size;
    }
    /**
    * @return A view over each allocated faces of this buffer.
    */

  }, {
    key: "faces",
    get: function get() {
      return this._view;
    }
  }]);

  return FaceBuffer;
}();
// CONCATENATED MODULE: ./src/HalfedgeBuffer.js
function HalfedgeBuffer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function HalfedgeBuffer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function HalfedgeBuffer_createClass(Constructor, protoProps, staticProps) { if (protoProps) HalfedgeBuffer_defineProperties(Constructor.prototype, protoProps); if (staticProps) HalfedgeBuffer_defineProperties(Constructor, staticProps); return Constructor; }



var STARTING_VERTEX_OFFSET = 0;
var PAIR_HALFEDGE_OFFSET = 1;
var NEXT_HALFEDGE_OFFSET = 2;
var PREVIOUS_HALFEDGE_OFFSET = 3;
var ADJACENT_FACE_OFFSET = 4;
var FIELDS_COUNT = 5;
var HalfedgeBuffer_HalfedgeBuffer =
/*#__PURE__*/
function () {
  HalfedgeBuffer_createClass(HalfedgeBuffer, null, [{
    key: "copy",

    /**
    * Copy the given halfedge buffer.
    *
    * @param toCopy - An halfedge buffer instance to copy.
    *
    * @return A new halfedge buffer equal to the given one.
    */
    value: function copy(toCopy) {
      var result = new HalfedgeBuffer(toCopy.capacity);

      for (var index = 0, size = toCopy.size; index < size; ++index) {
        var halfedge = toCopy.get(index);
        result.declare(halfedge);
        result.setPairHalfedge(halfedge, toCopy.getPairHalfedge(halfedge));
        result.setNextHalfedge(halfedge, toCopy.getNextHalfedge(halfedge));
        result.setPreviousHalfedge(halfedge, toCopy.getPreviousHalfedge(halfedge));
        result.setAdjacentFace(halfedge, toCopy.getAdjacentFace(halfedge));
        result.setStartingVertex(halfedge, toCopy.getStartingVertex(halfedge));
      }

      return result;
    }
    /**
    * Allocate a buffer for storing a given number of halfedges.
    *
    * @param capacity - The capacity in halfedges of the resulting buffer.
    */

  }]);

  function HalfedgeBuffer(capacity) {
    HalfedgeBuffer_classCallCheck(this, HalfedgeBuffer);

    this._buffer = gl_tool_collection_["Packs"].uint32(capacity * FIELDS_COUNT); // TODO:  ADAPTATIVE ALLOCATION

    this._halfedges = gl_tool_collection_["Sets"].SparseDense.uint32(capacity); // TODO:  ADAPTATIVE ALLOCATION

    this._cursor = 0;
    this._view = gl_tool_collection_["View"].wrap(this._halfedges);
  }
  /**
  * @return The maximum number of halfedge that this buffer can store.
  */


  HalfedgeBuffer_createClass(HalfedgeBuffer, [{
    key: "get",

    /**
    * Return the halfedge at the given index.
    *
    * @param index - Index of the halfedge to return.
    *
    * @return The halfedge at the given index.
    */
    value: function get(index) {
      return this._halfedges.get(index);
    }
    /**
    * Return true if the given halfedge exists.
    *
    * @param halfedge - The halfedge to check.
    *
    * @return True if the given halfedge exists, false otherwise.
    */

  }, {
    key: "has",
    value: function has(halfedge) {
      return this._halfedges.has(halfedge);
    }
    /**
    * Insert the given halfedge into this buffer.
    *
    * @param halfedge - The halfedge to insert into this buffer.
    */

  }, {
    key: "declare",
    value: function declare(halfedge) {
      this._halfedges.add(halfedge);

      var buffer = this._buffer;
      var offset = halfedge * FIELDS_COUNT;
      buffer.set(offset + STARTING_VERTEX_OFFSET, NULL_VERTEX);
      buffer.set(offset + PAIR_HALFEDGE_OFFSET, NULL_HALFEDGE);
      buffer.set(offset + NEXT_HALFEDGE_OFFSET, NULL_HALFEDGE);
      buffer.set(offset + PREVIOUS_HALFEDGE_OFFSET, NULL_HALFEDGE);
      buffer.set(offset + ADJACENT_FACE_OFFSET, NULL_FACE);

      if (halfedge == this._cursor) {
        do {
          this._cursor += 1;
        } while (this._halfedges.has(this._cursor));
      }
    }
    /**
    * Create a new halfedge into this buffer and return its identifier.
    *
    * @return The identifier of the new halfedge that was created.
    */

  }, {
    key: "create",
    value: function create() {
      var next = this._cursor;

      this._halfedges.add(next);

      do {
        this._cursor += 1;
      } while (this._halfedges.has(this._cursor));

      var buffer = this._buffer;
      var offset = next * FIELDS_COUNT;
      buffer.set(offset + STARTING_VERTEX_OFFSET, NULL_VERTEX);
      buffer.set(offset + PAIR_HALFEDGE_OFFSET, NULL_HALFEDGE);
      buffer.set(offset + NEXT_HALFEDGE_OFFSET, NULL_HALFEDGE);
      buffer.set(offset + PREVIOUS_HALFEDGE_OFFSET, NULL_HALFEDGE);
      buffer.set(offset + ADJACENT_FACE_OFFSET, NULL_FACE);
      return next;
    }
    /**
    * Remove an halfedge from this buffer.
    *
    * @param halfedge - Identifier of the halfedge to remove from this buffer.
    */

  }, {
    key: "delete",
    value: function _delete(halfedge) {
      this._halfedges.delete(halfedge);

      if (halfedge < this._cursor) {
        this._cursor = halfedge;
      }
    }
    /**
    * Return the identifier of the vertex at the start of the given halfedge.
    *
    * @param halfedge - Identifier of the halfedge to read.
    *
    * @return The identifier of the vertex at the start of the given halfedge.
    */

  }, {
    key: "getStartingVertex",
    value: function getStartingVertex(halfedge) {
      return this._buffer.get(halfedge * FIELDS_COUNT + STARTING_VERTEX_OFFSET);
    }
    /**
    * Return the identifier of the vertex at the end of the given halfedge.
    *
    * @param halfedge - Identifier of the halfedge to read.
    *
    * @return The identifier of vertex at the end of the given halfedge.
    */

  }, {
    key: "getEndingVertex",
    value: function getEndingVertex(halfedge) {
      return this._buffer.get(this._buffer.get(halfedge * FIELDS_COUNT + PAIR_HALFEDGE_OFFSET) * FIELDS_COUNT + STARTING_VERTEX_OFFSET);
    }
    /**
    * Return the identifier of the pair halfedge of the given halfedge.
    *
    * @param halfedge - Identifier of the halfedge to read.
    *
    * @return The identifier of the pair halfedge of the given halfedge.
    */

  }, {
    key: "getPairHalfedge",
    value: function getPairHalfedge(halfedge) {
      return this._buffer.get(halfedge * FIELDS_COUNT + PAIR_HALFEDGE_OFFSET);
    }
    /**
    * Return the next halfedge of the given halfedge.
    *
    * @param halfedge - The halfedge to read.
    *
    * @return The next halfedge of the given halfedge.
    */

  }, {
    key: "getNextHalfedge",
    value: function getNextHalfedge(halfedge) {
      return this._buffer.get(halfedge * FIELDS_COUNT + NEXT_HALFEDGE_OFFSET);
    }
    /**
    * Return the previous halfedge of the given halfedge.
    *
    * @param halfedge - The halfedge to read.
    *
    * @return The previous halfedge of the given halfedge.
    */

  }, {
    key: "getPreviousHalfedge",
    value: function getPreviousHalfedge(halfedge) {
      return this._buffer.get(halfedge * FIELDS_COUNT + PREVIOUS_HALFEDGE_OFFSET);
    }
    /**
    * Return the adjacent face of the given halfedge.
    *
    * @param halfedge - The halfedge to read.
    *
    * @return The adjacent face of the given halfedge.
    */

  }, {
    key: "getAdjacentFace",
    value: function getAdjacentFace(halfedge) {
      return this._buffer.get(halfedge * FIELDS_COUNT + ADJACENT_FACE_OFFSET);
    }
    /**
    * Return true if the given halfedge has an adjacent face.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return True if the given halfedge has an adjacent face, false otherwise.
    */

  }, {
    key: "hasAdjacentFace",
    value: function hasAdjacentFace(halfedge) {
      return this.getAdjacentFace(halfedge) !== NULL_FACE;
    }
    /**
    * Update the starting vertex of an existing halfedge.
    *
    * @param halfedge - The halfedge to update.
    * @param vertex - The new starting vertex of the given halfedge.
    */

  }, {
    key: "setStartingVertex",
    value: function setStartingVertex(halfedge, vertex) {
      this._buffer.set(halfedge * FIELDS_COUNT + STARTING_VERTEX_OFFSET, vertex);
    }
    /**
    * Update the ending vertex of an existing halfedge.
    *
    * @param halfedge - The halfedge to update.
    * @param vertex - The new ending vertex of the given halfedge.
    */

  }, {
    key: "setEndingVertex",
    value: function setEndingVertex(halfedge, vertex) {
      this.setStartingVertex(this.getPairHalfedge(halfedge), vertex);
    }
    /**
    * Update the pair of an existing halfedge.
    *
    * @param halfedge - The halfedge to update.
    * @param pair - The new pair halfedge of the given halfedge.
    */

  }, {
    key: "setPairHalfedge",
    value: function setPairHalfedge(halfedge, pair) {
      this._buffer.set(halfedge * FIELDS_COUNT + PAIR_HALFEDGE_OFFSET, pair);
    }
    /**
    * Update the next halfedge of an existing halfedge.
    *
    * @param halfedge - The halfedge to update.
    * @param next - The new next halfedge of the given halfedge.
    */

  }, {
    key: "setNextHalfedge",
    value: function setNextHalfedge(halfedge, next) {
      this._buffer.set(halfedge * FIELDS_COUNT + NEXT_HALFEDGE_OFFSET, next);
    }
    /**
    * Update the previous halfedge of an existing halfedge.
    *
    * @param halfedge - The halfedge to update.
    * @param previous - The new previous halfedge of the given halfedge.
    */

  }, {
    key: "setPreviousHalfedge",
    value: function setPreviousHalfedge(halfedge, previous) {
      this._buffer.set(halfedge * FIELDS_COUNT + PREVIOUS_HALFEDGE_OFFSET, previous);
    }
    /**
    * Update the adjacent face of an existing halfedge.
    *
    * @param halfedge - The halfedge to update.
    * @param face - The new adjacent face of the given halfedge.
    */

  }, {
    key: "setAdjacentFace",
    value: function setAdjacentFace(halfedge, face) {
      this._buffer.set(halfedge * FIELDS_COUNT + ADJACENT_FACE_OFFSET, face);
    }
    /**
    * Reallocate this buffer in order to store more or less halfedges.
    *
    * @param capacity - The new number of halfedges to be able to store.
    */

  }, {
    key: "reallocate",
    value: function reallocate(capacity) {
      this._halfedges.reallocate(capacity); // TODO:  ADAPTATIVE REALLOCATION


      this._buffer.reallocate(capacity * FIELDS_COUNT); // TODO:  ADAPTATIVE REALLOCATION


      if (capacity < this._cursor) {
        this._cursor = capacity;
      }
    }
    /**
    * Reallocate this buffer in order to fit its capacity to its content.
    */

  }, {
    key: "fit",
    value: function fit() {
      this._halfedges.fit(); // TODO:  ADAPTATIVE REALLOCATION


      this._buffer.reallocate(this._halfedges.capacity * FIELDS_COUNT); // TODO:  ADAPTATIVE REALLOCATION

    }
    /**
    * Clear this buffer of all of its halfedges.
    */

  }, {
    key: "clear",
    value: function clear() {
      this._halfedges.clear();

      this._cursor = 0;
    }
    /**
    * Returns true if both instances are equals.
    *
    * @param other - Other instance to compare to this one.
    */

  }, {
    key: "equals",
    value: function equals(other) {
      if (other == null) return false;
      if (other === this) return true;

      if (other instanceof HalfedgeBuffer) {
        if (other.size !== this.size) return false;
        if (other.capacity !== this.capacity) return false;

        for (var index = 0, size = this.size; index < size; ++index) {
          var halfedge = this.get(index);
          if (!other.has(halfedge) || other.getStartingVertex(halfedge) !== this.getStartingVertex(halfedge) || other.getAdjacentFace(halfedge) !== this.getAdjacentFace(halfedge) || other.getNextHalfedge(halfedge) !== this.getNextHalfedge(halfedge) || other.getPreviousHalfedge(halfedge) !== this.getPreviousHalfedge(halfedge) || other.getPairHalfedge(halfedge) !== this.getPairHalfedge(halfedge)) return false;
        }

        return true;
      }
    }
  }, {
    key: "capacity",
    get: function get() {
      return this._halfedges.capacity;
    }
    /**
    * @return The number of halfedge stored into this buffer.
    */

  }, {
    key: "size",
    get: function get() {
      return this._halfedges.size;
    }
    /**
    * @return A view over each halfedge stored into this buffer.
    */

  }, {
    key: "halfedges",
    get: function get() {
      return this._view;
    }
  }]);

  return HalfedgeBuffer;
}();
// CONCATENATED MODULE: ./src/VertexBuffer.js
function VertexBuffer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function VertexBuffer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function VertexBuffer_createClass(Constructor, protoProps, staticProps) { if (protoProps) VertexBuffer_defineProperties(Constructor.prototype, protoProps); if (staticProps) VertexBuffer_defineProperties(Constructor, staticProps); return Constructor; }



var VertexBuffer_VertexBuffer =
/*#__PURE__*/
function () {
  VertexBuffer_createClass(VertexBuffer, null, [{
    key: "copy",

    /**
    * Copy the given vertex buffer.
    *
    * @param toCopy - A vertex buffer instance to copy.
    *
    * @return A new vertex buffer equal to the given one.
    */
    value: function copy(toCopy) {
      var result = new VertexBuffer(toCopy.capacity);

      for (var index = 0, size = toCopy.size; index < size; ++index) {
        var vertex = toCopy.get(index);
        result.declare(vertex);
        result.setOutgoingHalfedge(vertex, toCopy.getOutgoingHalfedge(vertex));
      }

      return result;
    }
    /**
    * Allocate a buffer of a given capacity for storing halfedges vertices.
    *
    * @param capacity - The capacity in vertices of the resulting buffer.
    */

  }]);

  function VertexBuffer(capacity) {
    VertexBuffer_classCallCheck(this, VertexBuffer);

    this._outgoingHalfedges = gl_tool_collection_["Packs"].uint32(capacity); // TODO:  ADAPTATIVE ALLOCATION

    this._vertices = gl_tool_collection_["Sets"].SparseDense.uint32(capacity); // TODO:  ADAPTATIVE ALLOCATION

    this._cursor = 0;
    this._view = gl_tool_collection_["View"].wrap(this._vertices);
  }
  /**
  * @return The maximum number of vertices that this buffer can store.
  */


  VertexBuffer_createClass(VertexBuffer, [{
    key: "get",

    /**
    * Return the vertex at the given index.
    *
    * @param index - Index of the vertex to return.
    *
    * @return The vertex at the given index.
    */
    value: function get(index) {
      return this._vertices.get(index);
    }
    /**
    * Return true if the given vertex exists.
    *
    * @param vertex - The vertex to check.
    *
    * @return True if the given vertex exists, false otherwise.
    */

  }, {
    key: "has",
    value: function has(vertex) {
      return this._vertices.has(vertex);
    }
    /**
    * Insert the given vertex into this buffer.
    *
    * @param vertex - The vertex to insert into this buffer.
    */

  }, {
    key: "declare",
    value: function declare(vertex) {
      this._vertices.add(vertex);

      this._outgoingHalfedges.set(vertex, NULL_HALFEDGE);

      if (vertex == this._cursor) {
        do {
          this._cursor += 1;
        } while (this._vertices.has(this._cursor));
      }
    }
    /**
    * Create a vertex into this buffer and return its identifier.
    *
    * @return The identifier of the new vertex that was created.
    */

  }, {
    key: "create",
    value: function create() {
      var next = this._cursor;

      do {
        this._cursor += 1;
      } while (this._vertices.has(this._cursor));

      this._vertices.add(next);

      this._outgoingHalfedges.set(next, NULL_HALFEDGE);

      return next;
    }
    /**
    * Remove a vertex from this buffer.
    *
    * @param vertex - The vertex to remove from this buffer.
    */

  }, {
    key: "delete",
    value: function _delete(vertex) {
      this._vertices.delete(vertex);

      if (vertex < this._cursor) {
        this._cursor = vertex;
      }
    }
    /**
    * Return the identifier of an outgoing halfedge connected to this vertex.
    *
    * @param vertex - The vertex to read.
    *
    * @return An outgoing halfedge connected to the given vertex.
    */

  }, {
    key: "getOutgoingHalfedge",
    value: function getOutgoingHalfedge(vertex) {
      return this._outgoingHalfedges.get(vertex);
    }
    /**
    * Return true if the given vertex has an outgoing halfedge.
    *
    * @param vertex - The vertex to read.
    *
    * @return True if the given vertex has an outgoing halfedge.
    */

  }, {
    key: "hasOutgoingHafledge",
    value: function hasOutgoingHafledge(vertex) {
      return this._outgoingHalfedges.get(vertex) !== NULL_HALFEDGE;
    }
    /**
    * Mark an halfedge as an outgoing halfedge of the given vertex.
    *
    * @param vertex - A vertex to update.
    * @param halfedge - An halfedge to mark as an outgoing halfedge of the given vertex.
    */

  }, {
    key: "setOutgoingHalfedge",
    value: function setOutgoingHalfedge(vertex, halfedge) {
      this._outgoingHalfedges.set(vertex, halfedge);
    }
    /**
    * Reallocate this buffer in order to store more or less vertices.
    *
    * @param capacity - The new number of vertices to be able to store.
    */

  }, {
    key: "reallocate",
    value: function reallocate(capacity) {
      this._vertices.reallocate(capacity); // TODO:  ADAPTATIVE REALLOCATION


      this._outgoingHalfedges.reallocate(capacity); // TODO:  ADAPTATIVE REALLOCATION


      if (capacity < this._cursor) {
        this._cursor = capacity;
      }
    }
    /**
    * Reallocate this buffer in order to fit its capacity to its content.
    */

  }, {
    key: "fit",
    value: function fit() {
      this._vertices.fit(); // TODO:  ADAPTATIVE REALLOCATION


      this._outgoingHalfedges.reallocate(this._vertices.capacity); // TODO:  ADAPTATIVE REALLOCATION

    }
    /**
    * Clear this buffer of all of its vertices.
    */

  }, {
    key: "clear",
    value: function clear() {
      this._vertices.clear();

      this._cursor = 0;
    }
    /**
    * Returns true if both instances are equals.
    *
    * @param other - Other instance to compare to this one.
    */

  }, {
    key: "equals",
    value: function equals(other) {
      if (other == null) return false;
      if (other === this) return true;

      if (other instanceof VertexBuffer) {
        if (other.size !== this.size) return false;
        if (other.capacity !== this.capacity) return false;

        for (var index = 0, size = this.size; index < size; ++index) {
          var vertex = this.get(index);
          if (!other.has(vertex)) return false;
          if (other.getOutgoingHalfedge(vertex) !== this.getOutgoingHalfedge(vertex)) return false;
        }

        return true;
      }
    }
  }, {
    key: "capacity",
    get: function get() {
      return this._vertices.capacity;
    }
    /**
    * @return The number of vertices stored into this buffer.
    */

  }, {
    key: "size",
    get: function get() {
      return this._vertices.size;
    }
    /**
    * @return A view over each allocated vertices of this buffer.
    */

  }, {
    key: "vertices",
    get: function get() {
      return this._view;
    }
  }]);

  return VertexBuffer;
}();
// CONCATENATED MODULE: ./src/HalfedgeStructure.js
function HalfedgeStructure_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function HalfedgeStructure_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function HalfedgeStructure_createClass(Constructor, protoProps, staticProps) { if (protoProps) HalfedgeStructure_defineProperties(Constructor.prototype, protoProps); if (staticProps) HalfedgeStructure_defineProperties(Constructor, staticProps); return Constructor; }





var HalfedgeStructure_HalfedgeStructure =
/*#__PURE__*/
function () {
  /**
  * Instantiate a new halfedge structure.
  *
  * @param capacity - An object that describe the space to allocate to the structure.
  */
  function HalfedgeStructure(capacity) {
    HalfedgeStructure_classCallCheck(this, HalfedgeStructure);

    this._faces = new FaceBuffer_FaceBuffer(capacity.faces);
    this._halfedges = new HalfedgeBuffer_HalfedgeBuffer(capacity.halfedges);
    this._vertices = new VertexBuffer_VertexBuffer(capacity.vertices);
    var self = this;
    this.capacity = Object.freeze({
      get faces() {
        return self._faces.capacity;
      },

      get halfedges() {
        return self._halfedges.capacity;
      },

      get vertices() {
        return self._vertices.capacity;
      }

    });
  }
  /**
  * @return A view over each faces of the structure.
  */


  HalfedgeStructure_createClass(HalfedgeStructure, [{
    key: "split",

    /**
    * Split the given edge in two by using the given vertex as a middle point.
    *
    * @param halfedge - The halfedge to split.
    * @param vertex - The vertex to use.
    */
    value: function split(halfedge, vertex) {
      var halfedges = this._halfedges;
      var vertices = this._vertices;
      var b = vertex;
      var ac = halfedge;
      var ca = halfedges.getPairHalfedge(ac);
      var c = halfedges.getStartingVertex(ca);
      var bc = halfedges.create();
      var cb = halfedges.create();
      halfedges.setPairHalfedge(bc, cb);
      halfedges.setPairHalfedge(cb, bc);
      halfedges.setAdjacentFace(bc, halfedges.getAdjacentFace(ac));
      halfedges.setAdjacentFace(cb, halfedges.getAdjacentFace(ca));
      halfedges.setStartingVertex(bc, b);
      halfedges.setStartingVertex(cb, c);
      halfedges.setStartingVertex(ca, b);
      vertices.setOutgoingHalfedge(b, ca);
      vertices.setOutgoingHalfedge(c, cb);
      var ba = ca;
      var ab = ac;
      var cx = halfedges.getNextHalfedge(ac);
      var xc = halfedges.getPreviousHalfedge(ca);
      if (cx === ca) cx = cb;
      if (xc === ac) xc = bc;
      halfedges.setNextHalfedge(ab, bc);
      halfedges.setNextHalfedge(bc, cx);
      halfedges.setNextHalfedge(xc, cb);
      halfedges.setNextHalfedge(cb, ba);
      halfedges.setPreviousHalfedge(bc, ab);
      halfedges.setPreviousHalfedge(cx, bc);
      halfedges.setPreviousHalfedge(cb, xc);
      halfedges.setPreviousHalfedge(ba, cb);
    }
    /**
    * Create a new vertex into this structure and return its identifier.
    *
    * @return The identifier of the vertex that was created.
    */

  }, {
    key: "createVertex",
    value: function createVertex() {
      return this._vertices.create();
    }
    /**
    * Return an outgoing halfedge of the given vertex.
    *
    * @param vertex - The vertex to read.
    *
    * @return An outgoing halfedge of the given vertex.
    */

  }, {
    key: "getOutgoingHalfedge",
    value: function getOutgoingHalfedge(vertex) {
      return this._vertices.getOutgoingHalfedge(vertex);
    }
    /**
    * Return true if the given vertex has an outgoing halfedge.
    *
    * @param vertex - The vertex to read.
    *
    * @return True if an outgoing halfedge exists for the given vertex.
    */

  }, {
    key: "hasOutgoingHafledge",
    value: function hasOutgoingHafledge(vertex) {
      return this._vertices.hasOutgoingHafledge(vertex);
    }
    /**
    * Create an edge into this structure and return the described halfedge.
    *
    * @param start - The vertex that starts the edge.
    * @param end - The vertex that ends the edge.
    *
    * @return The halfedge of the created edge that starts from, and end to, the given vertices.
    */

  }, {
    key: "createEdge",
    value: function createEdge(start, end) {
      var halfedge = this._halfedges.create();

      var pair = this._halfedges.create();

      this._halfedges.setPairHalfedge(halfedge, pair);

      this._halfedges.setPairHalfedge(pair, halfedge);

      this._halfedges.setStartingVertex(halfedge, start);

      this._halfedges.setStartingVertex(pair, end);

      this._halfedges.setNextHalfedge(halfedge, pair);

      this._halfedges.setPreviousHalfedge(halfedge, pair);

      this._halfedges.setNextHalfedge(pair, halfedge);

      this._halfedges.setPreviousHalfedge(pair, halfedge);

      this._vertices.setOutgoingHalfedge(start, halfedge);

      this._vertices.setOutgoingHalfedge(end, pair);

      return halfedge;
    }
    /**
    * Return the vertex that starts the given halfedge.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return The vertex that starts the given halfedge.
    */

  }, {
    key: "getStartingVertex",
    value: function getStartingVertex(halfedge) {
      return this._halfedges.getStartingVertex(halfedge);
    }
    /**
    * Return the vertex that ends the given halfedge.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return The vertex that ends the given halfedge.
    */

  }, {
    key: "getEndingVertex",
    value: function getEndingVertex(halfedge) {
      return this._halfedges.getEndingVertex(halfedge);
    }
    /**
    * Return the pair halfedge of the given halfedge.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return The pair halfedge of the given halfedge.
    */

  }, {
    key: "getPairHalfedge",
    value: function getPairHalfedge(halfedge) {
      return this._halfedges.getPairHalfedge(halfedge);
    }
    /**
    * Return the next halfedge of the given halfedge.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return The next halfedge of the given halfedge.
    */

  }, {
    key: "getNextHalfedge",
    value: function getNextHalfedge(halfedge) {
      return this._halfedges.getNextHalfedge(halfedge);
    }
    /**
    * Return the previous halfedge of the given halfedge.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return The previous halfedge of the given halfedge.
    */

  }, {
    key: "getPreviousHalfedge",
    value: function getPreviousHalfedge(halfedge) {
      return this._halfedges.getPreviousHalfedge(halfedge);
    }
    /**
    * Return the adjacent face of the given halfedge.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return The adjacent face of the given halfedge.
    */

  }, {
    key: "getAdjacentFace",
    value: function getAdjacentFace(halfedge) {
      return this._halfedges.getAdjacentFace(halfedge);
    }
    /**
    * Return true if the given halfedge has an adjacent face.
    *
    * @param halfedge - An halfedge to read.
    *
    * @return True if the given halfedge has an adjacent face, false otherwise.
    */

  }, {
    key: "hasAdjacentFace",
    value: function hasAdjacentFace(halfedge) {
      return this._halfedges.hasAdjacentFace(halfedge);
    }
    /**
    * Return the described halfedge if exists.
    *
    * @param start - The vertex that starts the halfedge.
    * @param end - The vertex that ends the halfedge.
    *
    * @return The halfedge that starts from, and end to, the given halfedges if exists, NULL_HALFEDGE otherwise.
    */

  }, {
    key: "getBetween",
    value: function getBetween(start, end) {
      var halfedges = this._halfedges;

      var first = this._vertices.getOutgoingHalfedge(start);

      var current = first;

      do {
        if (halfedges.getEndingVertex(current) === end) {
          return current;
        } else {
          current = halfedges.getNextHalfedge(halfedges.getPairHalfedge(current));
        }
      } while (current !== first);

      return NULL_HALFEDGE;
    }
    /**
    * Return true if the described halfedge exists.
    *
    * @param start - The vertex that starts the halfedge.
    * @param end - The vertex that ends the halfedge.
    *
    * @return True if an halfedge that starts from, and end to, the given halfedges exists, false otherwise.
    */

  }, {
    key: "hasBetween",
    value: function hasBetween(start, end) {
      return this.getBetween(start, end) !== NULL_HALFEDGE;
    }
    /**
    * Create a face adjacent to the given halfedge and return it.
    *
    * @param halfedge - The halfedge next to the given face.
    *
    * @return The created face.
    */

  }, {
    key: "createFace",
    value: function createFace(halfedge) {
      var existingFace = this.getAdjacentFace(halfedge);

      if (existingFace !== NULL_HALFEDGE) {
        return existingFace;
      }

      var face = this._faces.create();

      this._faces.setHalfedge(face, halfedge);

      var current = halfedge;

      do {
        this._halfedges.setAdjacentFace(current, face);

        current = this._halfedges.getNextHalfedge(current);
      } while (current !== halfedge);

      return face;
    }
    /**
    * Return an halfedge adjacent to the given face.
    *
    * @param face - A face.
    *
    * @return An halfedge adjacent to the given face.
    */

  }, {
    key: "getAdjacentHalfedge",
    value: function getAdjacentHalfedge(face) {
      return this._faces.getHalfedge(face);
    }
    /**
    * Remove the given face.
    *
    * @param face - The face to remove.
    */

  }, {
    key: "deleteFace",
    value: function deleteFace(face) {
      var halfedges = this._halfedges;
      var faces = this._faces;
      var first = faces.getHalfedge(face);
      var current = first;

      do {
        halfedges.setAdjacentFace(current, NULL_FACE);
        current = halfedges.getNextHalfedge(current);
      } while (current !== first);

      faces.delete(face);
    }
    /**
    * Delete the given face if it exists.
    *
    * @param face - The face to remove, may be NULL_FACE.
    */

  }, {
    key: "deleteFaceIfExists",
    value: function deleteFaceIfExists(face) {
      if (face !== NULL_FACE) {
        this.deleteFace(face);
      }
    }
    /**
    * Set the outgoing halfedge of the given vertex as the next available one.
    *
    * @param vertex - A vertex to update.
    */

  }, {
    key: "setOutgoingHalfedgeToNextAvailable",
    value: function setOutgoingHalfedgeToNextAvailable(vertex) {
      var outgoing = this._vertices.getOutgoingHalfedge(vertex);

      if (outgoing !== NULL_HALFEDGE) {
        this._vertices.setOutgoingHalfedge(vertex, this._halfedges.getNextHalfedge(this._halfedges.getPairHalfedge(outgoing)));
      }
    }
    /**
    * Set the outgoing halfedge of the given vertex as the next available one or null if no next halfedge exists.
    *
    * @param vertex - A vertex to update.
    */

  }, {
    key: "setOutgoingHalfedgeToNextAvailableOrNull",
    value: function setOutgoingHalfedgeToNextAvailableOrNull(vertex) {
      var outgoing = this._vertices.getOutgoingHalfedge(vertex);

      if (outgoing !== NULL_HALFEDGE) {
        var next = this._halfedges.getNextHalfedge(this._halfedges.getPairHalfedge(outgoing));

        this._vertices.setOutgoingHalfedge(vertex, next === outgoing ? NULL_HALFEDGE : next);
      }
    }
    /**
    * Delete the given edge.
    *
    * @param halfedge - Halfedge of the edge to delete.
    */

  }, {
    key: "deleteEdge",
    value: function deleteEdge(halfedge) {
      var halfedges = this._halfedges;
      var vertices = this._vertices;
      var start = halfedges.getStartingVertex(halfedge);
      var end = halfedges.getEndingVertex(halfedge);
      var pair = halfedges.getPairHalfedge(halfedge);
      this.deleteFaceIfExists(halfedges.getAdjacentFace(halfedge));
      this.deleteFaceIfExists(halfedges.getAdjacentFace(pair));

      if (vertices.getOutgoingHalfedge(start) === halfedge) {
        this.setOutgoingHalfedgeToNextAvailableOrNull(start);
      }

      if (vertices.getOutgoingHalfedge(end) === pair) {
        this.setOutgoingHalfedgeToNextAvailableOrNull(end);
      }

      this.setNextHalfedge(halfedge, pair);
      this.setNextHalfedge(pair, halfedge);
      halfedges.delete(halfedge);
      halfedges.delete(pair);
    }
    /**
    * Delete the given vertex.
    *
    * @param vertex - The vertex to delete.
    */

  }, {
    key: "deleteVertex",
    value: function deleteVertex(vertex) {
      var halfedges = this._halfedges;
      var vertices = this._vertices;
      var current = vertices.getOutgoingHalfedge(vertex);

      while (current !== NULL_HALFEDGE) {
        this.deleteEdge(vertices.getOutgoingHalfedge(vertex));
        current = vertices.getOutgoingHalfedge(vertex);
      }

      vertices.delete(vertex);
    }
    /**
    * Isolate an halfedge.
    *
    * @param halfedge - The halfedge to isolate.
    */

  }, {
    key: "isolate",
    value: function isolate(halfedge) {
      var pair = this._halfedges.getPairHalfedge(halfedge);

      this.setNextHalfedge(halfedge, pair);
      this.setNextHalfedge(pair, halfedge);
    }
    /**
    * Update the next halfedge of the given halfedge.
    *
    * @param halfedge - Halfedge to update.
    * @param next - New next halfedge.
    */

  }, {
    key: "setNextHalfedge",
    value: function setNextHalfedge(halfedge, next) {
      var halfedges = this._halfedges;
      var oldNext = halfedges.getNextHalfedge(halfedge);
      var oldPrevious = halfedges.getPreviousHalfedge(next);
      this.deleteFaceIfExists(halfedges.getAdjacentFace(halfedge));
      this.deleteFaceIfExists(halfedges.getAdjacentFace(next));
      this.deleteFaceIfExists(halfedges.getAdjacentFace(oldNext));
      this.deleteFaceIfExists(halfedges.getAdjacentFace(oldPrevious));
      halfedges.setNextHalfedge(halfedge, next);
      halfedges.setPreviousHalfedge(next, halfedge);
      halfedges.setNextHalfedge(oldPrevious, oldNext);
      halfedges.setPreviousHalfedge(oldNext, oldPrevious);
    }
    /**
    * Update the previous halfedge of the given halfedge.
    *
    * @param halfedge - Halfedge to update.
    * @param previous - New previous halfedge.
    */

  }, {
    key: "setPreviousHalfedge",
    value: function setPreviousHalfedge(halfedge, previous) {
      this.setNextHalfedge(previous, halfedge);
    }
    /**
    * Empty this structure.
    */

  }, {
    key: "clear",
    value: function clear() {
      this._vertices.clear();

      this._halfedges.clear();

      this._faces.clear();
    }
  }, {
    key: "faces",
    get: function get() {
      return this._faces.faces;
    }
    /**
    * @return A view over each halfedges of the structure.
    */

  }, {
    key: "halfedges",
    get: function get() {
      return this._halfedges.halfedges;
    }
    /**
    * @return A view over each vertices of the structure.
    */

  }, {
    key: "vertices",
    get: function get() {
      return this._vertices.vertices;
    }
  }]);

  return HalfedgeStructure;
}();
// CONCATENATED MODULE: ./src/index.ts
/* concated harmony reexport NULL_HALFEDGE */__webpack_require__.d(__webpack_exports__, "NULL_HALFEDGE", function() { return NULL_HALFEDGE; });
/* concated harmony reexport NULL_VERTEX */__webpack_require__.d(__webpack_exports__, "NULL_VERTEX", function() { return NULL_VERTEX; });
/* concated harmony reexport NULL_FACE */__webpack_require__.d(__webpack_exports__, "NULL_FACE", function() { return NULL_FACE; });
/* concated harmony reexport FaceBuffer */__webpack_require__.d(__webpack_exports__, "FaceBuffer", function() { return FaceBuffer_FaceBuffer; });
/* concated harmony reexport HalfedgeBuffer */__webpack_require__.d(__webpack_exports__, "HalfedgeBuffer", function() { return HalfedgeBuffer_HalfedgeBuffer; });
/* concated harmony reexport HalfedgeStructure */__webpack_require__.d(__webpack_exports__, "HalfedgeStructure", function() { return HalfedgeStructure_HalfedgeStructure; });
/* concated harmony reexport VertexBuffer */__webpack_require__.d(__webpack_exports__, "VertexBuffer", function() { return VertexBuffer_VertexBuffer; });







/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/@cedric-demongivert/gl-tool-math/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cedric-demongivert/gl-tool-math/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var hexadecimal_namespaceObject = {};
__webpack_require__.r(hexadecimal_namespaceObject);
__webpack_require__.d(hexadecimal_namespaceObject, "encode", function() { return encode; });
__webpack_require__.d(hexadecimal_namespaceObject, "encodeVector4f", function() { return encodeVector4f; });
__webpack_require__.d(hexadecimal_namespaceObject, "encodeVector3f", function() { return encodeVector3f; });
__webpack_require__.d(hexadecimal_namespaceObject, "encodeVector4d", function() { return encodeVector4d; });
__webpack_require__.d(hexadecimal_namespaceObject, "encodeVector3d", function() { return encodeVector3d; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeRed", function() { return decodeRed; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeGreen", function() { return decodeGreen; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeBlue", function() { return decodeBlue; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeAlpha", function() { return decodeAlpha; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeAsVector4f", function() { return decodeAsVector4f; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeAsVector4d", function() { return decodeAsVector4d; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeAsVector3f", function() { return decodeAsVector3f; });
__webpack_require__.d(hexadecimal_namespaceObject, "decodeAsVector3d", function() { return decodeAsVector3d; });
var hsl_namespaceObject = {};
__webpack_require__.r(hsl_namespaceObject);
__webpack_require__.d(hsl_namespaceObject, "hue", function() { return hue; });
__webpack_require__.d(hsl_namespaceObject, "saturation", function() { return saturation; });
__webpack_require__.d(hsl_namespaceObject, "lightness", function() { return lightness; });
__webpack_require__.d(hsl_namespaceObject, "red", function() { return red; });
__webpack_require__.d(hsl_namespaceObject, "green", function() { return green; });
__webpack_require__.d(hsl_namespaceObject, "blue", function() { return blue; });
var color_namespaceObject = {};
__webpack_require__.r(color_namespaceObject);
__webpack_require__.d(color_namespaceObject, "hexadecimal", function() { return hexadecimal_namespaceObject; });
__webpack_require__.d(color_namespaceObject, "hsl", function() { return hsl_namespaceObject; });
var vector2d_namespaceObject = {};
__webpack_require__.r(vector2d_namespaceObject);
__webpack_require__.d(vector2d_namespaceObject, "set", function() { return set; });
__webpack_require__.d(vector2d_namespaceObject, "normalize", function() { return normalize; });
__webpack_require__.d(vector2d_namespaceObject, "toString", function() { return toString_toString; });
__webpack_require__.d(vector2d_namespaceObject, "copy", function() { return copy; });
__webpack_require__.d(vector2d_namespaceObject, "clockwiseNormal", function() { return clockwiseNormal; });
__webpack_require__.d(vector2d_namespaceObject, "counterClockwiseNormal", function() { return counterClockwiseNormal; });
__webpack_require__.d(vector2d_namespaceObject, "add", function() { return add; });
__webpack_require__.d(vector2d_namespaceObject, "minimum", function() { return minimum_minimum; });
__webpack_require__.d(vector2d_namespaceObject, "floor", function() { return floor; });
__webpack_require__.d(vector2d_namespaceObject, "ceil", function() { return ceil; });
__webpack_require__.d(vector2d_namespaceObject, "round", function() { return round; });
__webpack_require__.d(vector2d_namespaceObject, "dot", function() { return dot; });
__webpack_require__.d(vector2d_namespaceObject, "divideWithScalar", function() { return divideWithScalar; });
__webpack_require__.d(vector2d_namespaceObject, "mix", function() { return mix; });
__webpack_require__.d(vector2d_namespaceObject, "multiplyWithScalar", function() { return multiplyWithScalar; });
__webpack_require__.d(vector2d_namespaceObject, "angle", function() { return angle; });
__webpack_require__.d(vector2d_namespaceObject, "angleBetween", function() { return angleBetween; });
__webpack_require__.d(vector2d_namespaceObject, "clamp", function() { return clamp; });
__webpack_require__.d(vector2d_namespaceObject, "equals", function() { return equals; });
__webpack_require__.d(vector2d_namespaceObject, "negate", function() { return negate; });
__webpack_require__.d(vector2d_namespaceObject, "subtract", function() { return subtract; });
__webpack_require__.d(vector2d_namespaceObject, "squaredLength", function() { return squaredLength; });
__webpack_require__.d(vector2d_namespaceObject, "maximum", function() { return maximum_maximum; });
__webpack_require__.d(vector2d_namespaceObject, "length", function() { return length_length; });
var vector2f_namespaceObject = {};
__webpack_require__.r(vector2f_namespaceObject);
__webpack_require__.d(vector2f_namespaceObject, "set", function() { return set_set; });
__webpack_require__.d(vector2f_namespaceObject, "normalize", function() { return normalize_normalize; });
__webpack_require__.d(vector2f_namespaceObject, "toString", function() { return vector2f_toString_toString; });
__webpack_require__.d(vector2f_namespaceObject, "copy", function() { return copy_copy; });
__webpack_require__.d(vector2f_namespaceObject, "clockwiseNormal", function() { return normal_clockwiseNormal; });
__webpack_require__.d(vector2f_namespaceObject, "counterClockwiseNormal", function() { return normal_counterClockwiseNormal; });
__webpack_require__.d(vector2f_namespaceObject, "add", function() { return add_add; });
__webpack_require__.d(vector2f_namespaceObject, "minimum", function() { return vector2f_minimum_minimum; });
__webpack_require__.d(vector2f_namespaceObject, "floor", function() { return floor_floor; });
__webpack_require__.d(vector2f_namespaceObject, "ceil", function() { return ceil_ceil; });
__webpack_require__.d(vector2f_namespaceObject, "round", function() { return round_round; });
__webpack_require__.d(vector2f_namespaceObject, "dot", function() { return dot_dot; });
__webpack_require__.d(vector2f_namespaceObject, "divideWithScalar", function() { return divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector2f_namespaceObject, "mix", function() { return mix_mix; });
__webpack_require__.d(vector2f_namespaceObject, "multiplyWithScalar", function() { return multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector2f_namespaceObject, "angle", function() { return angle_angle; });
__webpack_require__.d(vector2f_namespaceObject, "angleBetween", function() { return angle_angleBetween; });
__webpack_require__.d(vector2f_namespaceObject, "clamp", function() { return clamp_clamp; });
__webpack_require__.d(vector2f_namespaceObject, "equals", function() { return equals_equals; });
__webpack_require__.d(vector2f_namespaceObject, "negate", function() { return negate_negate; });
__webpack_require__.d(vector2f_namespaceObject, "subtract", function() { return subtract_subtract; });
__webpack_require__.d(vector2f_namespaceObject, "squaredLength", function() { return squaredLength_squaredLength; });
__webpack_require__.d(vector2f_namespaceObject, "maximum", function() { return vector2f_maximum_maximum; });
__webpack_require__.d(vector2f_namespaceObject, "length", function() { return vector2f_length_length; });
var vector2i_namespaceObject = {};
__webpack_require__.r(vector2i_namespaceObject);
__webpack_require__.d(vector2i_namespaceObject, "set", function() { return vector2i_set_set; });
__webpack_require__.d(vector2i_namespaceObject, "toString", function() { return vector2i_toString_toString; });
__webpack_require__.d(vector2i_namespaceObject, "copy", function() { return vector2i_copy_copy; });
__webpack_require__.d(vector2i_namespaceObject, "clockwiseNormal", function() { return vector2i_normal_clockwiseNormal; });
__webpack_require__.d(vector2i_namespaceObject, "counterClockwiseNormal", function() { return vector2i_normal_counterClockwiseNormal; });
__webpack_require__.d(vector2i_namespaceObject, "add", function() { return vector2i_add_add; });
__webpack_require__.d(vector2i_namespaceObject, "minimum", function() { return vector2i_minimum_minimum; });
__webpack_require__.d(vector2i_namespaceObject, "dot", function() { return vector2i_dot_dot; });
__webpack_require__.d(vector2i_namespaceObject, "divideWithScalar", function() { return vector2i_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector2i_namespaceObject, "mix", function() { return vector2i_mix_mix; });
__webpack_require__.d(vector2i_namespaceObject, "multiplyWithScalar", function() { return vector2i_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector2i_namespaceObject, "angle", function() { return vector2i_angle_angle; });
__webpack_require__.d(vector2i_namespaceObject, "angleBetween", function() { return vector2i_angle_angleBetween; });
__webpack_require__.d(vector2i_namespaceObject, "clamp", function() { return vector2i_clamp_clamp; });
__webpack_require__.d(vector2i_namespaceObject, "equals", function() { return vector2i_equals_equals; });
__webpack_require__.d(vector2i_namespaceObject, "negate", function() { return vector2i_negate_negate; });
__webpack_require__.d(vector2i_namespaceObject, "subtract", function() { return vector2i_subtract_subtract; });
__webpack_require__.d(vector2i_namespaceObject, "squaredLength", function() { return vector2i_squaredLength_squaredLength; });
__webpack_require__.d(vector2i_namespaceObject, "maximum", function() { return vector2i_maximum_maximum; });
__webpack_require__.d(vector2i_namespaceObject, "length", function() { return vector2i_length_length; });
var vector3d_namespaceObject = {};
__webpack_require__.r(vector3d_namespaceObject);
__webpack_require__.d(vector3d_namespaceObject, "set", function() { return vector3d_set_set; });
__webpack_require__.d(vector3d_namespaceObject, "normalize", function() { return vector3d_normalize_normalize; });
__webpack_require__.d(vector3d_namespaceObject, "toString", function() { return vector3d_toString_toString; });
__webpack_require__.d(vector3d_namespaceObject, "copy", function() { return vector3d_copy_copy; });
__webpack_require__.d(vector3d_namespaceObject, "add", function() { return vector3d_add_add; });
__webpack_require__.d(vector3d_namespaceObject, "minimum", function() { return vector3d_minimum_minimum; });
__webpack_require__.d(vector3d_namespaceObject, "floor", function() { return vector3d_floor_floor; });
__webpack_require__.d(vector3d_namespaceObject, "ceil", function() { return vector3d_ceil_ceil; });
__webpack_require__.d(vector3d_namespaceObject, "round", function() { return vector3d_round_round; });
__webpack_require__.d(vector3d_namespaceObject, "dot", function() { return vector3d_dot_dot; });
__webpack_require__.d(vector3d_namespaceObject, "divideWithScalar", function() { return vector3d_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector3d_namespaceObject, "mix", function() { return vector3d_mix_mix; });
__webpack_require__.d(vector3d_namespaceObject, "multiplyWithScalar", function() { return vector3d_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector3d_namespaceObject, "clamp", function() { return vector3d_clamp_clamp; });
__webpack_require__.d(vector3d_namespaceObject, "equals", function() { return vector3d_equals_equals; });
__webpack_require__.d(vector3d_namespaceObject, "negate", function() { return vector3d_negate_negate; });
__webpack_require__.d(vector3d_namespaceObject, "subtract", function() { return vector3d_subtract_subtract; });
__webpack_require__.d(vector3d_namespaceObject, "squaredLength", function() { return vector3d_squaredLength_squaredLength; });
__webpack_require__.d(vector3d_namespaceObject, "maximum", function() { return vector3d_maximum_maximum; });
__webpack_require__.d(vector3d_namespaceObject, "length", function() { return vector3d_length_length; });
var vector3f_namespaceObject = {};
__webpack_require__.r(vector3f_namespaceObject);
__webpack_require__.d(vector3f_namespaceObject, "set", function() { return vector3f_set_set; });
__webpack_require__.d(vector3f_namespaceObject, "normalize", function() { return vector3f_normalize_normalize; });
__webpack_require__.d(vector3f_namespaceObject, "toString", function() { return vector3f_toString_toString; });
__webpack_require__.d(vector3f_namespaceObject, "copy", function() { return vector3f_copy_copy; });
__webpack_require__.d(vector3f_namespaceObject, "add", function() { return vector3f_add_add; });
__webpack_require__.d(vector3f_namespaceObject, "minimum", function() { return vector3f_minimum_minimum; });
__webpack_require__.d(vector3f_namespaceObject, "floor", function() { return vector3f_floor_floor; });
__webpack_require__.d(vector3f_namespaceObject, "ceil", function() { return vector3f_ceil_ceil; });
__webpack_require__.d(vector3f_namespaceObject, "round", function() { return vector3f_round_round; });
__webpack_require__.d(vector3f_namespaceObject, "dot", function() { return vector3f_dot_dot; });
__webpack_require__.d(vector3f_namespaceObject, "divideWithScalar", function() { return vector3f_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector3f_namespaceObject, "mix", function() { return vector3f_mix_mix; });
__webpack_require__.d(vector3f_namespaceObject, "multiplyWithScalar", function() { return vector3f_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector3f_namespaceObject, "clamp", function() { return vector3f_clamp_clamp; });
__webpack_require__.d(vector3f_namespaceObject, "equals", function() { return vector3f_equals_equals; });
__webpack_require__.d(vector3f_namespaceObject, "negate", function() { return vector3f_negate_negate; });
__webpack_require__.d(vector3f_namespaceObject, "subtract", function() { return vector3f_subtract_subtract; });
__webpack_require__.d(vector3f_namespaceObject, "squaredLength", function() { return vector3f_squaredLength_squaredLength; });
__webpack_require__.d(vector3f_namespaceObject, "maximum", function() { return vector3f_maximum_maximum; });
__webpack_require__.d(vector3f_namespaceObject, "length", function() { return vector3f_length_length; });
var vector3i_namespaceObject = {};
__webpack_require__.r(vector3i_namespaceObject);
__webpack_require__.d(vector3i_namespaceObject, "set", function() { return vector3i_set_set; });
__webpack_require__.d(vector3i_namespaceObject, "toString", function() { return vector3i_toString_toString; });
__webpack_require__.d(vector3i_namespaceObject, "copy", function() { return vector3i_copy_copy; });
__webpack_require__.d(vector3i_namespaceObject, "add", function() { return vector3i_add_add; });
__webpack_require__.d(vector3i_namespaceObject, "minimum", function() { return vector3i_minimum_minimum; });
__webpack_require__.d(vector3i_namespaceObject, "dot", function() { return vector3i_dot_dot; });
__webpack_require__.d(vector3i_namespaceObject, "divideWithScalar", function() { return vector3i_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector3i_namespaceObject, "mix", function() { return vector3i_mix_mix; });
__webpack_require__.d(vector3i_namespaceObject, "multiplyWithScalar", function() { return vector3i_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector3i_namespaceObject, "clamp", function() { return vector3i_clamp_clamp; });
__webpack_require__.d(vector3i_namespaceObject, "equals", function() { return vector3i_equals_equals; });
__webpack_require__.d(vector3i_namespaceObject, "negate", function() { return vector3i_negate_negate; });
__webpack_require__.d(vector3i_namespaceObject, "subtract", function() { return vector3i_subtract_subtract; });
__webpack_require__.d(vector3i_namespaceObject, "squaredLength", function() { return vector3i_squaredLength_squaredLength; });
__webpack_require__.d(vector3i_namespaceObject, "maximum", function() { return vector3i_maximum_maximum; });
__webpack_require__.d(vector3i_namespaceObject, "length", function() { return vector3i_length_length; });
var vector4d_namespaceObject = {};
__webpack_require__.r(vector4d_namespaceObject);
__webpack_require__.d(vector4d_namespaceObject, "set", function() { return vector4d_set_set; });
__webpack_require__.d(vector4d_namespaceObject, "normalize", function() { return vector4d_normalize_normalize; });
__webpack_require__.d(vector4d_namespaceObject, "toString", function() { return vector4d_toString_toString; });
__webpack_require__.d(vector4d_namespaceObject, "copy", function() { return vector4d_copy_copy; });
__webpack_require__.d(vector4d_namespaceObject, "add", function() { return vector4d_add_add; });
__webpack_require__.d(vector4d_namespaceObject, "minimum", function() { return vector4d_minimum_minimum; });
__webpack_require__.d(vector4d_namespaceObject, "floor", function() { return vector4d_floor_floor; });
__webpack_require__.d(vector4d_namespaceObject, "ceil", function() { return vector4d_ceil_ceil; });
__webpack_require__.d(vector4d_namespaceObject, "round", function() { return vector4d_round_round; });
__webpack_require__.d(vector4d_namespaceObject, "dot", function() { return vector4d_dot_dot; });
__webpack_require__.d(vector4d_namespaceObject, "divideWithScalar", function() { return vector4d_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector4d_namespaceObject, "mix", function() { return vector4d_mix_mix; });
__webpack_require__.d(vector4d_namespaceObject, "multiplyWithScalar", function() { return vector4d_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector4d_namespaceObject, "clamp", function() { return vector4d_clamp_clamp; });
__webpack_require__.d(vector4d_namespaceObject, "equals", function() { return vector4d_equals_equals; });
__webpack_require__.d(vector4d_namespaceObject, "negate", function() { return vector4d_negate_negate; });
__webpack_require__.d(vector4d_namespaceObject, "subtract", function() { return vector4d_subtract_subtract; });
__webpack_require__.d(vector4d_namespaceObject, "squaredLength", function() { return vector4d_squaredLength_squaredLength; });
__webpack_require__.d(vector4d_namespaceObject, "maximum", function() { return vector4d_maximum_maximum; });
__webpack_require__.d(vector4d_namespaceObject, "length", function() { return vector4d_length_length; });
var vector4f_namespaceObject = {};
__webpack_require__.r(vector4f_namespaceObject);
__webpack_require__.d(vector4f_namespaceObject, "set", function() { return vector4f_set_set; });
__webpack_require__.d(vector4f_namespaceObject, "normalize", function() { return vector4f_normalize_normalize; });
__webpack_require__.d(vector4f_namespaceObject, "toString", function() { return vector4f_toString_toString; });
__webpack_require__.d(vector4f_namespaceObject, "copy", function() { return vector4f_copy_copy; });
__webpack_require__.d(vector4f_namespaceObject, "add", function() { return vector4f_add_add; });
__webpack_require__.d(vector4f_namespaceObject, "minimum", function() { return vector4f_minimum_minimum; });
__webpack_require__.d(vector4f_namespaceObject, "floor", function() { return vector4f_floor_floor; });
__webpack_require__.d(vector4f_namespaceObject, "ceil", function() { return vector4f_ceil_ceil; });
__webpack_require__.d(vector4f_namespaceObject, "round", function() { return vector4f_round_round; });
__webpack_require__.d(vector4f_namespaceObject, "dot", function() { return vector4f_dot_dot; });
__webpack_require__.d(vector4f_namespaceObject, "divideWithScalar", function() { return vector4f_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector4f_namespaceObject, "mix", function() { return vector4f_mix_mix; });
__webpack_require__.d(vector4f_namespaceObject, "multiplyWithScalar", function() { return vector4f_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector4f_namespaceObject, "clamp", function() { return vector4f_clamp_clamp; });
__webpack_require__.d(vector4f_namespaceObject, "equals", function() { return vector4f_equals_equals; });
__webpack_require__.d(vector4f_namespaceObject, "negate", function() { return vector4f_negate_negate; });
__webpack_require__.d(vector4f_namespaceObject, "subtract", function() { return vector4f_subtract_subtract; });
__webpack_require__.d(vector4f_namespaceObject, "squaredLength", function() { return vector4f_squaredLength_squaredLength; });
__webpack_require__.d(vector4f_namespaceObject, "maximum", function() { return vector4f_maximum_maximum; });
__webpack_require__.d(vector4f_namespaceObject, "length", function() { return vector4f_length_length; });
var vector4i_namespaceObject = {};
__webpack_require__.r(vector4i_namespaceObject);
__webpack_require__.d(vector4i_namespaceObject, "set", function() { return vector4i_set_set; });
__webpack_require__.d(vector4i_namespaceObject, "toString", function() { return vector4i_toString_toString; });
__webpack_require__.d(vector4i_namespaceObject, "copy", function() { return vector4i_copy_copy; });
__webpack_require__.d(vector4i_namespaceObject, "add", function() { return vector4i_add_add; });
__webpack_require__.d(vector4i_namespaceObject, "minimum", function() { return vector4i_minimum_minimum; });
__webpack_require__.d(vector4i_namespaceObject, "dot", function() { return vector4i_dot_dot; });
__webpack_require__.d(vector4i_namespaceObject, "divideWithScalar", function() { return vector4i_divideWithScalar_divideWithScalar; });
__webpack_require__.d(vector4i_namespaceObject, "mix", function() { return vector4i_mix_mix; });
__webpack_require__.d(vector4i_namespaceObject, "multiplyWithScalar", function() { return vector4i_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(vector4i_namespaceObject, "clamp", function() { return vector4i_clamp_clamp; });
__webpack_require__.d(vector4i_namespaceObject, "equals", function() { return vector4i_equals_equals; });
__webpack_require__.d(vector4i_namespaceObject, "negate", function() { return vector4i_negate_negate; });
__webpack_require__.d(vector4i_namespaceObject, "subtract", function() { return vector4i_subtract_subtract; });
__webpack_require__.d(vector4i_namespaceObject, "squaredLength", function() { return vector4i_squaredLength_squaredLength; });
__webpack_require__.d(vector4i_namespaceObject, "maximum", function() { return vector4i_maximum_maximum; });
__webpack_require__.d(vector4i_namespaceObject, "length", function() { return vector4i_length_length; });
var matrix2f_namespaceObject = {};
__webpack_require__.r(matrix2f_namespaceObject);
__webpack_require__.d(matrix2f_namespaceObject, "set", function() { return matrix2f_set_set; });
__webpack_require__.d(matrix2f_namespaceObject, "multiplyWithVector", function() { return multiplyWithVector; });
__webpack_require__.d(matrix2f_namespaceObject, "toScale", function() { return toScale; });
__webpack_require__.d(matrix2f_namespaceObject, "toString", function() { return matrix2f_toString_toString; });
__webpack_require__.d(matrix2f_namespaceObject, "copy", function() { return matrix2f_copy_copy; });
__webpack_require__.d(matrix2f_namespaceObject, "translate", function() { return translate; });
__webpack_require__.d(matrix2f_namespaceObject, "add", function() { return matrix2f_add_add; });
__webpack_require__.d(matrix2f_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix2f_namespaceObject, "rotate", function() { return rotate; });
__webpack_require__.d(matrix2f_namespaceObject, "multiplyWithMatrix", function() { return multiplyWithMatrix; });
__webpack_require__.d(matrix2f_namespaceObject, "determinant", function() { return determinant; });
__webpack_require__.d(matrix2f_namespaceObject, "toRotation", function() { return toRotation; });
__webpack_require__.d(matrix2f_namespaceObject, "extractTranslation", function() { return extractTranslation; });
__webpack_require__.d(matrix2f_namespaceObject, "divideWithScalar", function() { return matrix2f_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix2f_namespaceObject, "invert", function() { return invert; });
__webpack_require__.d(matrix2f_namespaceObject, "multiplyWithScalar", function() { return matrix2f_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix2f_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix2f_namespaceObject, "extract2DRotation", function() { return extract2DRotation; });
__webpack_require__.d(matrix2f_namespaceObject, "toIdentity", function() { return toIdentity; });
__webpack_require__.d(matrix2f_namespaceObject, "equals", function() { return matrix2f_equals_equals; });
__webpack_require__.d(matrix2f_namespaceObject, "negate", function() { return matrix2f_negate_negate; });
__webpack_require__.d(matrix2f_namespaceObject, "subtract", function() { return matrix2f_subtract_subtract; });
__webpack_require__.d(matrix2f_namespaceObject, "scale", function() { return scale; });
__webpack_require__.d(matrix2f_namespaceObject, "fill", function() { return fill; });
__webpack_require__.d(matrix2f_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix2f_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix2f_namespaceObject, "toTranslation", function() { return toTranslation; });
__webpack_require__.d(matrix2f_namespaceObject, "transpose", function() { return transpose; });
__webpack_require__.d(matrix2f_namespaceObject, "extractScale", function() { return extractScale; });
var matrix2d_namespaceObject = {};
__webpack_require__.r(matrix2d_namespaceObject);
__webpack_require__.d(matrix2d_namespaceObject, "set", function() { return matrix2d_set_set; });
__webpack_require__.d(matrix2d_namespaceObject, "multiplyWithVector", function() { return multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix2d_namespaceObject, "toScale", function() { return toScale_toScale; });
__webpack_require__.d(matrix2d_namespaceObject, "toString", function() { return matrix2d_toString_toString; });
__webpack_require__.d(matrix2d_namespaceObject, "copy", function() { return matrix2d_copy_copy; });
__webpack_require__.d(matrix2d_namespaceObject, "translate", function() { return translate_translate; });
__webpack_require__.d(matrix2d_namespaceObject, "add", function() { return matrix2d_add_add; });
__webpack_require__.d(matrix2d_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix2d_namespaceObject, "rotate", function() { return rotate_rotate; });
__webpack_require__.d(matrix2d_namespaceObject, "multiplyWithMatrix", function() { return multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix2d_namespaceObject, "determinant", function() { return determinant_determinant; });
__webpack_require__.d(matrix2d_namespaceObject, "toRotation", function() { return toRotation_toRotation; });
__webpack_require__.d(matrix2d_namespaceObject, "extractTranslation", function() { return extractTranslation_extractTranslation; });
__webpack_require__.d(matrix2d_namespaceObject, "divideWithScalar", function() { return matrix2d_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix2d_namespaceObject, "invert", function() { return invert_invert; });
__webpack_require__.d(matrix2d_namespaceObject, "multiplyWithScalar", function() { return matrix2d_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix2d_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix2d_namespaceObject, "extract2DRotation", function() { return extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix2d_namespaceObject, "toIdentity", function() { return toIdentity_toIdentity; });
__webpack_require__.d(matrix2d_namespaceObject, "equals", function() { return matrix2d_equals_equals; });
__webpack_require__.d(matrix2d_namespaceObject, "negate", function() { return matrix2d_negate_negate; });
__webpack_require__.d(matrix2d_namespaceObject, "subtract", function() { return matrix2d_subtract_subtract; });
__webpack_require__.d(matrix2d_namespaceObject, "scale", function() { return scale_scale; });
__webpack_require__.d(matrix2d_namespaceObject, "fill", function() { return fill_fill; });
__webpack_require__.d(matrix2d_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix2d_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix2d_namespaceObject, "toTranslation", function() { return toTranslation_toTranslation; });
__webpack_require__.d(matrix2d_namespaceObject, "transpose", function() { return transpose_transpose; });
__webpack_require__.d(matrix2d_namespaceObject, "extractScale", function() { return extractScale_extractScale; });
var matrix2i_namespaceObject = {};
__webpack_require__.r(matrix2i_namespaceObject);
__webpack_require__.d(matrix2i_namespaceObject, "set", function() { return matrix2i_set_set; });
__webpack_require__.d(matrix2i_namespaceObject, "multiplyWithVector", function() { return matrix2i_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix2i_namespaceObject, "toScale", function() { return matrix2i_toScale_toScale; });
__webpack_require__.d(matrix2i_namespaceObject, "toString", function() { return matrix2i_toString_toString; });
__webpack_require__.d(matrix2i_namespaceObject, "copy", function() { return matrix2i_copy_copy; });
__webpack_require__.d(matrix2i_namespaceObject, "translate", function() { return matrix2i_translate_translate; });
__webpack_require__.d(matrix2i_namespaceObject, "add", function() { return matrix2i_add_add; });
__webpack_require__.d(matrix2i_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix2i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix2i_namespaceObject, "rotate", function() { return matrix2i_rotate_rotate; });
__webpack_require__.d(matrix2i_namespaceObject, "multiplyWithMatrix", function() { return matrix2i_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix2i_namespaceObject, "determinant", function() { return matrix2i_determinant_determinant; });
__webpack_require__.d(matrix2i_namespaceObject, "toRotation", function() { return matrix2i_toRotation_toRotation; });
__webpack_require__.d(matrix2i_namespaceObject, "extractTranslation", function() { return matrix2i_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix2i_namespaceObject, "divideWithScalar", function() { return matrix2i_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix2i_namespaceObject, "multiplyWithScalar", function() { return matrix2i_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix2i_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix2i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix2i_namespaceObject, "extract2DRotation", function() { return matrix2i_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix2i_namespaceObject, "toIdentity", function() { return matrix2i_toIdentity_toIdentity; });
__webpack_require__.d(matrix2i_namespaceObject, "equals", function() { return matrix2i_equals_equals; });
__webpack_require__.d(matrix2i_namespaceObject, "negate", function() { return matrix2i_negate_negate; });
__webpack_require__.d(matrix2i_namespaceObject, "subtract", function() { return matrix2i_subtract_subtract; });
__webpack_require__.d(matrix2i_namespaceObject, "scale", function() { return matrix2i_scale_scale; });
__webpack_require__.d(matrix2i_namespaceObject, "fill", function() { return matrix2i_fill_fill; });
__webpack_require__.d(matrix2i_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix2i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix2i_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix2i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix2i_namespaceObject, "toTranslation", function() { return matrix2i_toTranslation_toTranslation; });
__webpack_require__.d(matrix2i_namespaceObject, "transpose", function() { return matrix2i_transpose_transpose; });
__webpack_require__.d(matrix2i_namespaceObject, "extractScale", function() { return matrix2i_extractScale_extractScale; });
var matrix3f_namespaceObject = {};
__webpack_require__.r(matrix3f_namespaceObject);
__webpack_require__.d(matrix3f_namespaceObject, "set", function() { return matrix3f_set_set; });
__webpack_require__.d(matrix3f_namespaceObject, "multiplyWithVector", function() { return matrix3f_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix3f_namespaceObject, "toScale", function() { return matrix3f_toScale_toScale; });
__webpack_require__.d(matrix3f_namespaceObject, "toString", function() { return matrix3f_toString_toString; });
__webpack_require__.d(matrix3f_namespaceObject, "copy", function() { return matrix3f_copy_copy; });
__webpack_require__.d(matrix3f_namespaceObject, "translate", function() { return matrix3f_translate_translate; });
__webpack_require__.d(matrix3f_namespaceObject, "add", function() { return matrix3f_add_add; });
__webpack_require__.d(matrix3f_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix3f_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix3f_namespaceObject, "rotate", function() { return matrix3f_rotate_rotate; });
__webpack_require__.d(matrix3f_namespaceObject, "multiplyWithMatrix", function() { return matrix3f_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix3f_namespaceObject, "determinant", function() { return matrix3f_determinant_determinant; });
__webpack_require__.d(matrix3f_namespaceObject, "toRotation", function() { return matrix3f_toRotation_toRotation; });
__webpack_require__.d(matrix3f_namespaceObject, "extractTranslation", function() { return matrix3f_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix3f_namespaceObject, "divideWithScalar", function() { return matrix3f_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix3f_namespaceObject, "invert", function() { return matrix3f_invert_invert; });
__webpack_require__.d(matrix3f_namespaceObject, "multiplyWithScalar", function() { return matrix3f_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix3f_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix3f_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix3f_namespaceObject, "extract2DRotation", function() { return matrix3f_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix3f_namespaceObject, "toIdentity", function() { return matrix3f_toIdentity_toIdentity; });
__webpack_require__.d(matrix3f_namespaceObject, "equals", function() { return matrix3f_equals_equals; });
__webpack_require__.d(matrix3f_namespaceObject, "negate", function() { return matrix3f_negate_negate; });
__webpack_require__.d(matrix3f_namespaceObject, "subtract", function() { return matrix3f_subtract_subtract; });
__webpack_require__.d(matrix3f_namespaceObject, "scale", function() { return matrix3f_scale_scale; });
__webpack_require__.d(matrix3f_namespaceObject, "fill", function() { return matrix3f_fill_fill; });
__webpack_require__.d(matrix3f_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix3f_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3f_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix3f_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3f_namespaceObject, "computeZComponentOfMultiplicationWithVector", function() { return computeZComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3f_namespaceObject, "toTranslation", function() { return matrix3f_toTranslation_toTranslation; });
__webpack_require__.d(matrix3f_namespaceObject, "transpose", function() { return matrix3f_transpose_transpose; });
__webpack_require__.d(matrix3f_namespaceObject, "extractScale", function() { return matrix3f_extractScale_extractScale; });
var matrix3d_namespaceObject = {};
__webpack_require__.r(matrix3d_namespaceObject);
__webpack_require__.d(matrix3d_namespaceObject, "set", function() { return matrix3d_set_set; });
__webpack_require__.d(matrix3d_namespaceObject, "multiplyWithVector", function() { return matrix3d_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix3d_namespaceObject, "toScale", function() { return matrix3d_toScale_toScale; });
__webpack_require__.d(matrix3d_namespaceObject, "toString", function() { return matrix3d_toString_toString; });
__webpack_require__.d(matrix3d_namespaceObject, "copy", function() { return matrix3d_copy_copy; });
__webpack_require__.d(matrix3d_namespaceObject, "translate", function() { return matrix3d_translate_translate; });
__webpack_require__.d(matrix3d_namespaceObject, "add", function() { return matrix3d_add_add; });
__webpack_require__.d(matrix3d_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix3d_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix3d_namespaceObject, "rotate", function() { return matrix3d_rotate_rotate; });
__webpack_require__.d(matrix3d_namespaceObject, "multiplyWithMatrix", function() { return matrix3d_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix3d_namespaceObject, "determinant", function() { return matrix3d_determinant_determinant; });
__webpack_require__.d(matrix3d_namespaceObject, "toRotation", function() { return matrix3d_toRotation_toRotation; });
__webpack_require__.d(matrix3d_namespaceObject, "extractTranslation", function() { return matrix3d_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix3d_namespaceObject, "divideWithScalar", function() { return matrix3d_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix3d_namespaceObject, "invert", function() { return matrix3d_invert_invert; });
__webpack_require__.d(matrix3d_namespaceObject, "multiplyWithScalar", function() { return matrix3d_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix3d_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix3d_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix3d_namespaceObject, "extract2DRotation", function() { return matrix3d_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix3d_namespaceObject, "toIdentity", function() { return matrix3d_toIdentity_toIdentity; });
__webpack_require__.d(matrix3d_namespaceObject, "equals", function() { return matrix3d_equals_equals; });
__webpack_require__.d(matrix3d_namespaceObject, "negate", function() { return matrix3d_negate_negate; });
__webpack_require__.d(matrix3d_namespaceObject, "subtract", function() { return matrix3d_subtract_subtract; });
__webpack_require__.d(matrix3d_namespaceObject, "scale", function() { return matrix3d_scale_scale; });
__webpack_require__.d(matrix3d_namespaceObject, "fill", function() { return matrix3d_fill_fill; });
__webpack_require__.d(matrix3d_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix3d_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3d_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix3d_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3d_namespaceObject, "computeZComponentOfMultiplicationWithVector", function() { return computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3d_namespaceObject, "toTranslation", function() { return matrix3d_toTranslation_toTranslation; });
__webpack_require__.d(matrix3d_namespaceObject, "transpose", function() { return matrix3d_transpose_transpose; });
__webpack_require__.d(matrix3d_namespaceObject, "extractScale", function() { return matrix3d_extractScale_extractScale; });
var matrix3i_namespaceObject = {};
__webpack_require__.r(matrix3i_namespaceObject);
__webpack_require__.d(matrix3i_namespaceObject, "set", function() { return matrix3i_set_set; });
__webpack_require__.d(matrix3i_namespaceObject, "multiplyWithVector", function() { return matrix3i_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix3i_namespaceObject, "toScale", function() { return matrix3i_toScale_toScale; });
__webpack_require__.d(matrix3i_namespaceObject, "toString", function() { return matrix3i_toString_toString; });
__webpack_require__.d(matrix3i_namespaceObject, "copy", function() { return matrix3i_copy_copy; });
__webpack_require__.d(matrix3i_namespaceObject, "translate", function() { return matrix3i_translate_translate; });
__webpack_require__.d(matrix3i_namespaceObject, "add", function() { return matrix3i_add_add; });
__webpack_require__.d(matrix3i_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix3i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix3i_namespaceObject, "rotate", function() { return matrix3i_rotate_rotate; });
__webpack_require__.d(matrix3i_namespaceObject, "multiplyWithMatrix", function() { return matrix3i_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix3i_namespaceObject, "determinant", function() { return matrix3i_determinant_determinant; });
__webpack_require__.d(matrix3i_namespaceObject, "toRotation", function() { return matrix3i_toRotation_toRotation; });
__webpack_require__.d(matrix3i_namespaceObject, "extractTranslation", function() { return matrix3i_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix3i_namespaceObject, "divideWithScalar", function() { return matrix3i_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix3i_namespaceObject, "multiplyWithScalar", function() { return matrix3i_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix3i_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix3i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix3i_namespaceObject, "extract2DRotation", function() { return matrix3i_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix3i_namespaceObject, "toIdentity", function() { return matrix3i_toIdentity_toIdentity; });
__webpack_require__.d(matrix3i_namespaceObject, "equals", function() { return matrix3i_equals_equals; });
__webpack_require__.d(matrix3i_namespaceObject, "negate", function() { return matrix3i_negate_negate; });
__webpack_require__.d(matrix3i_namespaceObject, "subtract", function() { return matrix3i_subtract_subtract; });
__webpack_require__.d(matrix3i_namespaceObject, "scale", function() { return matrix3i_scale_scale; });
__webpack_require__.d(matrix3i_namespaceObject, "fill", function() { return matrix3i_fill_fill; });
__webpack_require__.d(matrix3i_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix3i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3i_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix3i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3i_namespaceObject, "computeZComponentOfMultiplicationWithVector", function() { return matrix3i_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix3i_namespaceObject, "toTranslation", function() { return matrix3i_toTranslation_toTranslation; });
__webpack_require__.d(matrix3i_namespaceObject, "transpose", function() { return matrix3i_transpose_transpose; });
__webpack_require__.d(matrix3i_namespaceObject, "extractScale", function() { return matrix3i_extractScale_extractScale; });
var matrix4f_namespaceObject = {};
__webpack_require__.r(matrix4f_namespaceObject);
__webpack_require__.d(matrix4f_namespaceObject, "set", function() { return matrix4f_set_set; });
__webpack_require__.d(matrix4f_namespaceObject, "multiplyWithVector", function() { return matrix4f_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix4f_namespaceObject, "toScale", function() { return matrix4f_toScale_toScale; });
__webpack_require__.d(matrix4f_namespaceObject, "toString", function() { return matrix4f_toString_toString; });
__webpack_require__.d(matrix4f_namespaceObject, "copy", function() { return matrix4f_copy_copy; });
__webpack_require__.d(matrix4f_namespaceObject, "translate", function() { return matrix4f_translate_translate; });
__webpack_require__.d(matrix4f_namespaceObject, "add", function() { return matrix4f_add_add; });
__webpack_require__.d(matrix4f_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix4f_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix4f_namespaceObject, "rotate", function() { return matrix4f_rotate_rotate; });
__webpack_require__.d(matrix4f_namespaceObject, "multiplyWithMatrix", function() { return matrix4f_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix4f_namespaceObject, "determinant", function() { return matrix4f_determinant_determinant; });
__webpack_require__.d(matrix4f_namespaceObject, "toRotation", function() { return matrix4f_toRotation_toRotation; });
__webpack_require__.d(matrix4f_namespaceObject, "extractTranslation", function() { return matrix4f_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix4f_namespaceObject, "divideWithScalar", function() { return matrix4f_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix4f_namespaceObject, "invert", function() { return matrix4f_invert_invert; });
__webpack_require__.d(matrix4f_namespaceObject, "multiplyWithScalar", function() { return matrix4f_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix4f_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix4f_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix4f_namespaceObject, "extract2DRotation", function() { return matrix4f_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix4f_namespaceObject, "toIdentity", function() { return matrix4f_toIdentity_toIdentity; });
__webpack_require__.d(matrix4f_namespaceObject, "equals", function() { return matrix4f_equals_equals; });
__webpack_require__.d(matrix4f_namespaceObject, "negate", function() { return matrix4f_negate_negate; });
__webpack_require__.d(matrix4f_namespaceObject, "subtract", function() { return matrix4f_subtract_subtract; });
__webpack_require__.d(matrix4f_namespaceObject, "scale", function() { return matrix4f_scale_scale; });
__webpack_require__.d(matrix4f_namespaceObject, "fill", function() { return matrix4f_fill_fill; });
__webpack_require__.d(matrix4f_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix4f_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4f_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix4f_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4f_namespaceObject, "computeZComponentOfMultiplicationWithVector", function() { return matrix4f_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4f_namespaceObject, "computeWComponentOfMultiplicationWithVector", function() { return computeWComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4f_namespaceObject, "toTranslation", function() { return matrix4f_toTranslation_toTranslation; });
__webpack_require__.d(matrix4f_namespaceObject, "transpose", function() { return matrix4f_transpose_transpose; });
__webpack_require__.d(matrix4f_namespaceObject, "extractScale", function() { return matrix4f_extractScale_extractScale; });
var matrix4d_namespaceObject = {};
__webpack_require__.r(matrix4d_namespaceObject);
__webpack_require__.d(matrix4d_namespaceObject, "set", function() { return matrix4d_set_set; });
__webpack_require__.d(matrix4d_namespaceObject, "multiplyWithVector", function() { return matrix4d_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix4d_namespaceObject, "toScale", function() { return matrix4d_toScale_toScale; });
__webpack_require__.d(matrix4d_namespaceObject, "toString", function() { return matrix4d_toString_toString; });
__webpack_require__.d(matrix4d_namespaceObject, "copy", function() { return matrix4d_copy_copy; });
__webpack_require__.d(matrix4d_namespaceObject, "translate", function() { return matrix4d_translate_translate; });
__webpack_require__.d(matrix4d_namespaceObject, "add", function() { return matrix4d_add_add; });
__webpack_require__.d(matrix4d_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix4d_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix4d_namespaceObject, "rotate", function() { return matrix4d_rotate_rotate; });
__webpack_require__.d(matrix4d_namespaceObject, "multiplyWithMatrix", function() { return matrix4d_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix4d_namespaceObject, "determinant", function() { return matrix4d_determinant_determinant; });
__webpack_require__.d(matrix4d_namespaceObject, "toRotation", function() { return matrix4d_toRotation_toRotation; });
__webpack_require__.d(matrix4d_namespaceObject, "extractTranslation", function() { return matrix4d_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix4d_namespaceObject, "divideWithScalar", function() { return matrix4d_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix4d_namespaceObject, "invert", function() { return matrix4d_invert_invert; });
__webpack_require__.d(matrix4d_namespaceObject, "multiplyWithScalar", function() { return matrix4d_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix4d_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix4d_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix4d_namespaceObject, "extract2DRotation", function() { return matrix4d_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix4d_namespaceObject, "toIdentity", function() { return matrix4d_toIdentity_toIdentity; });
__webpack_require__.d(matrix4d_namespaceObject, "equals", function() { return matrix4d_equals_equals; });
__webpack_require__.d(matrix4d_namespaceObject, "negate", function() { return matrix4d_negate_negate; });
__webpack_require__.d(matrix4d_namespaceObject, "subtract", function() { return matrix4d_subtract_subtract; });
__webpack_require__.d(matrix4d_namespaceObject, "scale", function() { return matrix4d_scale_scale; });
__webpack_require__.d(matrix4d_namespaceObject, "fill", function() { return matrix4d_fill_fill; });
__webpack_require__.d(matrix4d_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix4d_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4d_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix4d_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4d_namespaceObject, "computeZComponentOfMultiplicationWithVector", function() { return matrix4d_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4d_namespaceObject, "computeWComponentOfMultiplicationWithVector", function() { return computeComponentOfMultiplicationWithVector_computeWComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4d_namespaceObject, "toTranslation", function() { return matrix4d_toTranslation_toTranslation; });
__webpack_require__.d(matrix4d_namespaceObject, "transpose", function() { return matrix4d_transpose_transpose; });
__webpack_require__.d(matrix4d_namespaceObject, "extractScale", function() { return matrix4d_extractScale_extractScale; });
var matrix4i_namespaceObject = {};
__webpack_require__.r(matrix4i_namespaceObject);
__webpack_require__.d(matrix4i_namespaceObject, "set", function() { return matrix4i_set_set; });
__webpack_require__.d(matrix4i_namespaceObject, "multiplyWithVector", function() { return matrix4i_multiplyWithVector_multiplyWithVector; });
__webpack_require__.d(matrix4i_namespaceObject, "toScale", function() { return matrix4i_toScale_toScale; });
__webpack_require__.d(matrix4i_namespaceObject, "toString", function() { return matrix4i_toString_toString; });
__webpack_require__.d(matrix4i_namespaceObject, "copy", function() { return matrix4i_copy_copy; });
__webpack_require__.d(matrix4i_namespaceObject, "translate", function() { return matrix4i_translate_translate; });
__webpack_require__.d(matrix4i_namespaceObject, "add", function() { return matrix4i_add_add; });
__webpack_require__.d(matrix4i_namespaceObject, "multiplyWithStaticMatrixAsRightOperand", function() { return matrix4i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand; });
__webpack_require__.d(matrix4i_namespaceObject, "rotate", function() { return matrix4i_rotate_rotate; });
__webpack_require__.d(matrix4i_namespaceObject, "multiplyWithMatrix", function() { return matrix4i_multiplyWithMatrix_multiplyWithMatrix; });
__webpack_require__.d(matrix4i_namespaceObject, "determinant", function() { return matrix4i_determinant_determinant; });
__webpack_require__.d(matrix4i_namespaceObject, "toRotation", function() { return matrix4i_toRotation_toRotation; });
__webpack_require__.d(matrix4i_namespaceObject, "extractTranslation", function() { return matrix4i_extractTranslation_extractTranslation; });
__webpack_require__.d(matrix4i_namespaceObject, "divideWithScalar", function() { return matrix4i_divideWithScalar_divideWithScalar; });
__webpack_require__.d(matrix4i_namespaceObject, "multiplyWithScalar", function() { return matrix4i_multiplyWithScalar_multiplyWithScalar; });
__webpack_require__.d(matrix4i_namespaceObject, "multiplyWithStaticMatrixAsLeftOperand", function() { return matrix4i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand; });
__webpack_require__.d(matrix4i_namespaceObject, "extract2DRotation", function() { return matrix4i_extract2DRotation_extract2DRotation; });
__webpack_require__.d(matrix4i_namespaceObject, "toIdentity", function() { return matrix4i_toIdentity_toIdentity; });
__webpack_require__.d(matrix4i_namespaceObject, "equals", function() { return matrix4i_equals_equals; });
__webpack_require__.d(matrix4i_namespaceObject, "negate", function() { return matrix4i_negate_negate; });
__webpack_require__.d(matrix4i_namespaceObject, "subtract", function() { return matrix4i_subtract_subtract; });
__webpack_require__.d(matrix4i_namespaceObject, "scale", function() { return matrix4i_scale_scale; });
__webpack_require__.d(matrix4i_namespaceObject, "fill", function() { return matrix4i_fill_fill; });
__webpack_require__.d(matrix4i_namespaceObject, "computeXComponentOfMultiplicationWithVector", function() { return matrix4i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4i_namespaceObject, "computeYComponentOfMultiplicationWithVector", function() { return matrix4i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4i_namespaceObject, "computeZComponentOfMultiplicationWithVector", function() { return matrix4i_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4i_namespaceObject, "computeWComponentOfMultiplicationWithVector", function() { return matrix4i_computeComponentOfMultiplicationWithVector_computeWComponentOfMultiplicationWithVector; });
__webpack_require__.d(matrix4i_namespaceObject, "toTranslation", function() { return matrix4i_toTranslation_toTranslation; });
__webpack_require__.d(matrix4i_namespaceObject, "transpose", function() { return matrix4i_transpose_transpose; });
__webpack_require__.d(matrix4i_namespaceObject, "extractScale", function() { return matrix4i_extractScale_extractScale; });

// CONCATENATED MODULE: ./src/color/hexadecimal.ts

/**
* Return an hexadecimal representation of an rgba color.
*
* @param red - Red channel value.
* @param green - Green channel value.
* @param blue - Blue channel value.
* @param alpha - Alpha channel value.
*
* @return An hexadecimal representation of the given color.
*/
function encode(red, green, blue, alpha) {
    return Math.round(red * 255) << 24 ^
        Math.round(green * 255) << 16 ^
        Math.round(blue * 255) << 8 ^
        Math.round(alpha * 255) << 0;
}
/**
* Return an hexadecimal representation of a 4D float vector.
*
* @param color - A color to encode.
*
* @return An hexadecimal representation of the given color.
*/
function encodeVector4f(color) {
    return encode(color.r, color.g, color.b, color.a);
}
/**
* Return an hexadecimal representation of a 3D float vector.
*
* @param color - A color to encode.
*
* @return An hexadecimal representation of the given color.
*/
function encodeVector3f(color) {
    return encode(color.r, color.g, color.b, 1.0);
}
/**
* Return an hexadecimal representation of a vector 4d.
*
* @param color - A color to encode.
*
* @return An hexadecimal representation of the given color.
*/
function encodeVector4d(color) {
    return encode(color.r, color.g, color.b, color.a);
}
/**
* Return an hexadecimal representation of a vector 3d.
*
* @param color - A color to encode.
*
* @return An hexadecimal representation of the given color.
*/
function encodeVector3d(color) {
    return encode(color.r, color.g, color.b, 1.0);
}
/**
* Decode the red channel value from an hexadecimal color and return it.
*
* @param hexadecimal - Hexadecimal color to decode.
*
* @return The red channel value of the given color.
*/
function decodeRed(hexadecimal) {
    return (hexadecimal >> 24 & 255) / 255;
}
/**
* Decode the green channel value from an hexadecimal color and return it.
*
* @param hexadecimal - Hexadecimal color to decode.
*
* @return The green channel value of the given color.
*/
function decodeGreen(hexadecimal) {
    return (hexadecimal >> 16 & 255) / 255;
}
/**
* Decode the blue channel value from an hexadecimal color and return it.
*
* @param hexadecimal - Hexadecimal color to decode.
*
* @return The blue channel value of the given color.
*/
function decodeBlue(hexadecimal) {
    return (hexadecimal >> 8 & 255) / 255;
}
/**
* Decode the alpha channel value from an hexadecimal color and return it.
*
* @param hexadecimal - Hexadecimal color to decode.
*
* @return The alpha channel value of the given color.
*/
function decodeAlpha(hexadecimal) {
    return (hexadecimal >> 0 & 255) / 255;
}
/**
* Decode the given hexadecimal color as a Vector4f.
*
* @param hexadecimal - Hexadecimal color to decode.
* @param [result = new Vector4f()] - Result vector.
*
* @return The result vector.
*/
function decodeAsVector4f(hexadecimal, result = new Vector4f_Vector4f()) {
    result.r = decodeRed(hexadecimal);
    result.g = decodeGreen(hexadecimal);
    result.b = decodeBlue(hexadecimal);
    result.a = decodeAlpha(hexadecimal);
    return result;
}
/**
* Decode the given hexadecimal color as a Vector4d.
*
* @param hexadecimal - Hexadecimal color to decode.
* @param [result = new Vector4d()] - Result vector.
*
* @return The result vector.
*/
function decodeAsVector4d(hexadecimal, result = new Vector4d_Vector4d()) {
    result.r = decodeRed(hexadecimal);
    result.g = decodeGreen(hexadecimal);
    result.b = decodeBlue(hexadecimal);
    result.a = decodeAlpha(hexadecimal);
    return result;
}
/**
* Decode the given hexadecimal color as a Vector3f.
*
* @param hexadecimal - Hexadecimal color to decode.
* @param [result = new Vector3f()] - Result vector.
*
* @return The result vector.
*/
function decodeAsVector3f(hexadecimal, result = new Vector3f_Vector3f()) {
    result.r = decodeRed(hexadecimal);
    result.g = decodeGreen(hexadecimal);
    result.b = decodeBlue(hexadecimal);
    return result;
}
/**
* Decode the given hexadecimal color as a Vector3d.
*
* @param hexadecimal - Hexadecimal color to decode.
* @param [result = new Vector3d()] - Result vector.
*
* @return The result vector.
*/
function decodeAsVector3d(hexadecimal, result = new Vector3d_Vector3d()) {
    result.r = decodeRed(hexadecimal);
    result.g = decodeGreen(hexadecimal);
    result.b = decodeBlue(hexadecimal);
    return result;
}

// CONCATENATED MODULE: ./src/color/hsl.ts
/**
* Return the hue value of an RGB color.
*
* @param red - Red channel value.
* @param green - Green channel value.
* @param blue - Blue channel value.
*
* @return The hue of the given RGB color.
*/
function hue(red, green, blue) {
    const max = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    if (min === max) {
        return 0;
    }
    else {
        const delta = max - min;
        switch (max) {
            case red:
                return ((green - blue) / delta + (green < blue ? 6 : 0)) * 60;
            case green:
                return ((blue - red) / delta + 2) * 60;
            case blue:
                return ((red - green) / delta + 4) * 60;
        }
    }
}
/**
* Return the saturation value of an RGB color.
*
* @param red - Red channel value.
* @param green - Green channel value.
* @param blue - Blue channel value.
*
* @return The saturation of the given RGB color.
*/
function saturation(red, green, blue) {
    const max = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    const lightness = (min + max) / 2.0;
    if (min === max) {
        return 0;
    }
    else {
        const delta = max - min;
        if (lightness <= 0.5) {
            return delta / (max + min);
        }
        else {
            return delta / (2 - max - min);
        }
    }
}
/**
* Return the lightness value of an RGB color.
*
* @param red - Red channel value.
* @param green - Green channel value.
* @param blue - Blue channel value.
*
* @return The lightness of the given RGB color.
*/
function lightness(red, green, blue) {
    const max = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    return (min + max) / 2.0;
}
/**
* Return the red channel value of an HSL color.
*
* @param hue - Hue channel value.
* @param saturation - Saturation channel value.
* @param lightness - Lightness channel value.
*
* @return The red channel value of the given HSL color.
*/
function red(hue, saturation, lightness) {
    const chroma = (1 * Math.abs(2 * lightness - 1)) * saturation;
    const uh = hue / 60;
    const x = chroma * (1 - Math.abs(uh % 2 - 1));
    const m = lightness - chroma / 2;
    switch (uh >> 0) {
        case 1:
        case 4:
            return x + m;
        case 2:
        case 3:
            return m;
            return x + m;
        default:
            return chroma + m;
    }
}
/**
* Return the green channel value of an HSL color.
*
* @param hue - Hue channel value.
* @param saturation - Saturation channel value.
* @param lightness - Lightness channel value.
*
* @return The green channel value of the given HSL color.
*/
function green(hue, saturation, lightness) {
    const chroma = (1 * Math.abs(2 * lightness - 1)) * saturation;
    const uh = hue / 60;
    const x = chroma * (1 - Math.abs(uh % 2 - 1));
    const m = lightness - chroma / 2;
    switch (uh >> 0) {
        case 0:
        case 3:
            return x + m;
        case 1:
        case 2:
            return chroma + m;
        default:
            return m;
    }
}
/**
* Return the blue channel value of an HSL color.
*
* @param hue - Hue channel value.
* @param saturation - Saturation channel value.
* @param lightness - Lightness channel value.
*
* @return The blue channel value of the given HSL color.
*/
function blue(hue, saturation, lightness) {
    const chroma = (1 * Math.abs(2 * lightness - 1)) * saturation;
    const uh = hue / 60;
    const x = chroma * (1 - Math.abs(uh % 2 - 1));
    const m = lightness - chroma / 2;
    switch (uh >> 0) {
        case 0:
        case 1:
            return m;
        case 3:
        case 4:
            return chroma + m;
        default:
            return x + m;
    }
}

// CONCATENATED MODULE: ./src/color/index.ts





// CONCATENATED MODULE: ./src/vector2d/set.ts
/**
* Set the content of a 2 double buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
*
* @return The given buffer updated with the new values.
*/
function set(vectorBuffer, vectorBufferOffset, a0, a1) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/squaredLength.ts
/**
* Return the squared length of a 2 double buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    return a0 * a0 + a1 * a1;
}

// CONCATENATED MODULE: ./src/vector2d/length.ts

/**
* Return the length of a 2 double buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector2d/normalize.ts

/**
* Normalize a 2 double buffered vector and set the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function normalize(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const scalar = length_length(vectorBuffer, vectorBufferOffset);
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/toString.ts
/**
* Transform a 2D double buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 2 double null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        return [
            `vector 2 double [`,
            a0, ',', a1,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector2d/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/normal.ts
/**
* Compute the clockwise normal of a 2 double buffered vector and return the result.
*
* @param leftBuffer - Buffer that contains the vector to transform.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function clockwiseNormal(leftBuffer, leftBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a1;
    resultBuffer[resultBufferOffset + 1] = -a0;
    return resultBuffer;
}
/**
* Compute the counter-clockwise normal of a 2 double buffered vector and return the result.
*
* @param leftBuffer - Buffer that contains the vector to transform.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function counterClockwiseNormal(leftBuffer, leftBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = -a1;
    resultBuffer[resultBufferOffset + 1] = a0;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/add.ts
/**
* Perform an addition of two 2 double vectors.
*
* This function take each components of two 2 double vectors
* stored into two Float64Array and put the result of their addition
* into another Float64Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/minimum.ts
/**
* Update each component of a 2 double buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/floor.ts
/**
* Floor each component of a 2 double buffered vector and put the result into another buffer.
*
* @param {Float64Array} vectorBuffer - Buffer to read.
* @param {number} vectorBufferOffset - Offset to use when we read the given buffer.
* @param {Float64Array} resultBuffer - Buffer to write.
* @param {number} resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return {Float64Array} The result buffer updated with the result of this operation.
*/
function floor(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.floor(a0);
    resultBuffer[resultBufferOffset + 1] = Math.floor(a1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/ceil.ts
/**
* Ceil each component of a 2 double buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function ceil(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.ceil(a0);
    resultBuffer[resultBufferOffset + 1] = Math.ceil(a1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/round.ts
/**
* Round each component of a 2 double buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function round(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.round(a0);
    resultBuffer[resultBufferOffset + 1] = Math.round(a1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/dot.ts
/**
* Compute the dot product of two 2 double buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    return a0 * b0 + a1 * b1;
}

// CONCATENATED MODULE: ./src/vector2d/divideWithScalar.ts
/**
* Divide a 2 double buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/mix.ts
/**
* Compute the a vector that is a mix of two 2 double buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/multiplyWithScalar.ts
/**
* Multiply a 2 double buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/angle.ts
/**
* Compute the angle between the x axis and a 2 double buffered vector and return the result in radians.
*
* @param leftBuffer - Buffer that contains the vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector.
*
* @return The angle between the x axis vector and the given one in radians.
*/
function angle(leftBuffer, leftBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const result = Math.atan2(a0, a1);
    return result < 0 ? result + 2 * Math.PI : result;
}
/**
* Compute the angle between two 2 double buffered vectors and return the result in radians.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector
*
* @return The angle between the two vectors in radians.
*/
function angleBetween(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const aAngle = angle(leftBuffer, leftBufferOffset);
    const bAngle = angle(rightBuffer, rightBufferOffset);
    return bAngle > aAngle ? bAngle - aAngle : Math.PI * 2 + bAngle - aAngle;
}

// CONCATENATED MODULE: ./src/vector2d/clamp.ts
/**
* Clamp each component of 2 double buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/equals.ts
/**
* Test if two 2 double vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance;
}

// CONCATENATED MODULE: ./src/vector2d/negate.ts
/**
* Negate a 2 double buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/subtract.ts
/**
* Compute the subtraction of two 2 double buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/maximum.ts
/**
* Update each component of a 2 double buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2d/index.ts























// CONCATENATED MODULE: ./src/vector2f/set.ts
/**
* Set the content of a 2 float buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
*
* @return The given buffer updated with the new values.
*/
function set_set(vectorBuffer, vectorBufferOffset, a0, a1) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/squaredLength.ts
/**
* Return the squared length of a 2 float buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    return a0 * a0 + a1 * a1;
}

// CONCATENATED MODULE: ./src/vector2f/length.ts

/**
* Return the length of a 2 float buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector2f_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector2f/normalize.ts

/**
* Normalize a 2 float buffered vector and set the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function normalize_normalize(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const scalar = vector2f_length_length(vectorBuffer, vectorBufferOffset);
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/toString.ts
/**
* Transform a 2D float buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector2f_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 2 float null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        return [
            `vector 2 float [`,
            a0, ',', a1,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector2f/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/normal.ts
/**
* Compute the clockwise normal of a 2 float buffered vector and return the result.
*
* @param leftBuffer - Buffer that contains the vector to transform.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function normal_clockwiseNormal(leftBuffer, leftBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a1;
    resultBuffer[resultBufferOffset + 1] = -a0;
    return resultBuffer;
}
/**
* Compute the counter-clockwise normal of a 2 float buffered vector and return the result.
*
* @param leftBuffer - Buffer that contains the vector to transform.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function normal_counterClockwiseNormal(leftBuffer, leftBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = -a1;
    resultBuffer[resultBufferOffset + 1] = a0;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/add.ts
/**
* Perform an addition of two 2 float vectors.
*
* This function take each components of two 2 float vectors
* stored into two Float32Array and put the result of their addition
* into another Float32Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/minimum.ts
/**
* Update each component of a 2 float buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2f_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/floor.ts
/**
* Floor each component of a 2 float buffered vector and put the result into another buffer.
*
* @param {Float32Array} vectorBuffer - Buffer to read.
* @param {number} vectorBufferOffset - Offset to use when we read the given buffer.
* @param {Float32Array} resultBuffer - Buffer to write.
* @param {number} resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return {Float32Array} The result buffer updated with the result of this operation.
*/
function floor_floor(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.floor(a0);
    resultBuffer[resultBufferOffset + 1] = Math.floor(a1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/ceil.ts
/**
* Ceil each component of a 2 float buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function ceil_ceil(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.ceil(a0);
    resultBuffer[resultBufferOffset + 1] = Math.ceil(a1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/round.ts
/**
* Round each component of a 2 float buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function round_round(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.round(a0);
    resultBuffer[resultBufferOffset + 1] = Math.round(a1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/dot.ts
/**
* Compute the dot product of two 2 float buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    return a0 * b0 + a1 * b1;
}

// CONCATENATED MODULE: ./src/vector2f/divideWithScalar.ts
/**
* Divide a 2 float buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/mix.ts
/**
* Compute the a vector that is a mix of two 2 float buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/multiplyWithScalar.ts
/**
* Multiply a 2 float buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/angle.ts
/**
* Compute the angle between the x axis and a 2 float buffered vector and return the result in radians.
*
* @param leftBuffer - Buffer that contains the vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector.
*
* @return The angle between the x axis vector and the given one in radians.
*/
function angle_angle(leftBuffer, leftBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const result = Math.atan2(a0, a1);
    return result < 0 ? result + 2 * Math.PI : result;
}
/**
* Compute the angle between two 2 float buffered vectors and return the result in radians.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector
*
* @return The angle between the two vectors in radians.
*/
function angle_angleBetween(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const aAngle = angle_angle(leftBuffer, leftBufferOffset);
    const bAngle = angle_angle(rightBuffer, rightBufferOffset);
    return bAngle > aAngle ? bAngle - aAngle : Math.PI * 2 + bAngle - aAngle;
}

// CONCATENATED MODULE: ./src/vector2f/clamp.ts
/**
* Clamp each component of 2 float buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/equals.ts
/**
* Test if two 2 float vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance;
}

// CONCATENATED MODULE: ./src/vector2f/negate.ts
/**
* Negate a 2 float buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/subtract.ts
/**
* Compute the subtraction of two 2 float buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/maximum.ts
/**
* Update each component of a 2 float buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2f_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2f/index.ts























// CONCATENATED MODULE: ./src/vector2i/set.ts
/**
* Set the content of a 2 integer buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector2i_set_set(vectorBuffer, vectorBufferOffset, a0, a1) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/toString.ts
/**
* Transform a 2D integer buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector2i_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 2 integer null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        return [
            `vector 2 integer [`,
            a0, ',', a1,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector2i/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector2i_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/normal.ts
/**
* Compute the clockwise normal of a 2 integer buffered vector and return the result.
*
* @param leftBuffer - Buffer that contains the vector to transform.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector2i_normal_clockwiseNormal(leftBuffer, leftBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a1;
    resultBuffer[resultBufferOffset + 1] = -a0;
    return resultBuffer;
}
/**
* Compute the counter-clockwise normal of a 2 integer buffered vector and return the result.
*
* @param leftBuffer - Buffer that contains the vector to transform.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector2i_normal_counterClockwiseNormal(leftBuffer, leftBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = -a1;
    resultBuffer[resultBufferOffset + 1] = a0;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/add.ts
/**
* Perform an addition of two 2 integer vectors.
*
* This function take each components of two 2 integer vectors
* stored into two Int32Array and put the result of their addition
* into another Int32Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector2i_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/minimum.ts
/**
* Update each component of a 2 integer buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/dot.ts
/**
* Compute the dot product of two 2 integer buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector2i_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    return a0 * b0 + a1 * b1;
}

// CONCATENATED MODULE: ./src/vector2i/divideWithScalar.ts
/**
* Divide a 2 integer buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/mix.ts
/**
* Compute the a vector that is a mix of two 2 integer buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector2i_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/multiplyWithScalar.ts
/**
* Multiply a 2 integer buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/angle.ts
/**
* Compute the angle between the x axis and a 2 integer buffered vector and return the result in radians.
*
* @param leftBuffer - Buffer that contains the vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the vector.
*
* @return The angle between the x axis vector and the given one in radians.
*/
function vector2i_angle_angle(leftBuffer, leftBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const result = Math.atan2(a0, a1);
    return result < 0 ? result + 2 * Math.PI : result;
}
/**
* Compute the angle between two 2 integer buffered vectors and return the result in radians.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector
*
* @return The angle between the two vectors in radians.
*/
function vector2i_angle_angleBetween(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const aAngle = vector2i_angle_angle(leftBuffer, leftBufferOffset);
    const bAngle = vector2i_angle_angle(rightBuffer, rightBufferOffset);
    return bAngle > aAngle ? bAngle - aAngle : Math.PI * 2 + bAngle - aAngle;
}

// CONCATENATED MODULE: ./src/vector2i/clamp.ts
/**
* Clamp each component of 2 integer buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/equals.ts
/**
* Test if two 2 integer vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector2i_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance;
}

// CONCATENATED MODULE: ./src/vector2i/negate.ts
/**
* Negate a 2 integer buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/subtract.ts
/**
* Compute the subtraction of two 2 integer buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/squaredLength.ts
/**
* Return the squared length of a 2 integer buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector2i_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    return a0 * a0 + a1 * a1;
}

// CONCATENATED MODULE: ./src/vector2i/maximum.ts
/**
* Update each component of a 2 integer buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector2i_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector2i/length.ts

/**
* Return the length of a 2 integer buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector2i_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector2i_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector2i/index.ts



















// CONCATENATED MODULE: ./src/vector3d/set.ts
/**
* Set the content of a 3 double buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
* @param a2 - 2th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector3d_set_set(vectorBuffer, vectorBufferOffset, a0, a1, a2) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    vectorBuffer[vectorBufferOffset + 2] = a2;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/squaredLength.ts
/**
* Return the squared length of a 3 double buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector3d_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    return a0 * a0 + a1 * a1 + a2 * a2;
}

// CONCATENATED MODULE: ./src/vector3d/length.ts

/**
* Return the length of a 3 double buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector3d_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector3d_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector3d/normalize.ts

/**
* Normalize a 3 double buffered vector and set the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_normalize_normalize(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const scalar = vector3d_length_length(vectorBuffer, vectorBufferOffset);
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/toString.ts
/**
* Transform a 3D double buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector3d_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 3 double null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        const a2 = vectorBuffer[vectorBufferOffset + 2];
        return [
            `vector 3 double [`,
            a0, ',', a1, ',', a2,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector3d/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector3d_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    const a2 = sourceBuffer[sourceBufferOffset + 2];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    destinationBuffer[destinationBufferOffset + 2] = a2;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/add.ts
/**
* Perform an addition of two 3 double vectors.
*
* This function take each components of two 3 double vectors
* stored into two Float64Array and put the result of their addition
* into another Float64Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector3d_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    resultBuffer[resultBufferOffset + 2] = a2 + b2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/minimum.ts
/**
* Update each component of a 3 double buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(a2, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/floor.ts
/**
* Floor each component of a 3 double buffered vector and put the result into another buffer.
*
* @param {Float64Array} vectorBuffer - Buffer to read.
* @param {number} vectorBufferOffset - Offset to use when we read the given buffer.
* @param {Float64Array} resultBuffer - Buffer to write.
* @param {number} resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return {Float64Array} The result buffer updated with the result of this operation.
*/
function vector3d_floor_floor(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.floor(a0);
    resultBuffer[resultBufferOffset + 1] = Math.floor(a1);
    resultBuffer[resultBufferOffset + 2] = Math.floor(a2);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/ceil.ts
/**
* Ceil each component of a 3 double buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_ceil_ceil(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.ceil(a0);
    resultBuffer[resultBufferOffset + 1] = Math.ceil(a1);
    resultBuffer[resultBufferOffset + 2] = Math.ceil(a2);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/round.ts
/**
* Round each component of a 3 double buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_round_round(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.round(a0);
    resultBuffer[resultBufferOffset + 1] = Math.round(a1);
    resultBuffer[resultBufferOffset + 2] = Math.round(a2);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/dot.ts
/**
* Compute the dot product of two 3 double buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector3d_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    return a0 * b0 + a1 * b1 + a2 * b2;
}

// CONCATENATED MODULE: ./src/vector3d/divideWithScalar.ts
/**
* Divide a 3 double buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/mix.ts
/**
* Compute the a vector that is a mix of two 3 double buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector3d_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 + (b2 - a2) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/multiplyWithScalar.ts
/**
* Multiply a 3 double buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/clamp.ts
/**
* Clamp each component of 3 double buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(Math.min(a2, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/equals.ts
/**
* Test if two 3 double vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector3d_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance &&
        Math.abs(a2 - b2) < tolerance;
}

// CONCATENATED MODULE: ./src/vector3d/negate.ts
/**
* Negate a 3 double buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    resultBuffer[resultBufferOffset + 2] = -a2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/subtract.ts
/**
* Compute the subtraction of two 3 double buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    resultBuffer[resultBufferOffset + 2] = a2 - b2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/maximum.ts
/**
* Update each component of a 3 double buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3d_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    resultBuffer[resultBufferOffset + 2] = Math.min(a2, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3d/index.ts





















// CONCATENATED MODULE: ./src/vector3f/set.ts
/**
* Set the content of a 3 float buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
* @param a2 - 2th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector3f_set_set(vectorBuffer, vectorBufferOffset, a0, a1, a2) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    vectorBuffer[vectorBufferOffset + 2] = a2;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/squaredLength.ts
/**
* Return the squared length of a 3 float buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector3f_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    return a0 * a0 + a1 * a1 + a2 * a2;
}

// CONCATENATED MODULE: ./src/vector3f/length.ts

/**
* Return the length of a 3 float buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector3f_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector3f_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector3f/normalize.ts

/**
* Normalize a 3 float buffered vector and set the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_normalize_normalize(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const scalar = vector3f_length_length(vectorBuffer, vectorBufferOffset);
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/toString.ts
/**
* Transform a 3D float buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector3f_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 3 float null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        const a2 = vectorBuffer[vectorBufferOffset + 2];
        return [
            `vector 3 float [`,
            a0, ',', a1, ',', a2,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector3f/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector3f_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    const a2 = sourceBuffer[sourceBufferOffset + 2];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    destinationBuffer[destinationBufferOffset + 2] = a2;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/add.ts
/**
* Perform an addition of two 3 float vectors.
*
* This function take each components of two 3 float vectors
* stored into two Float32Array and put the result of their addition
* into another Float32Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector3f_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    resultBuffer[resultBufferOffset + 2] = a2 + b2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/minimum.ts
/**
* Update each component of a 3 float buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(a2, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/floor.ts
/**
* Floor each component of a 3 float buffered vector and put the result into another buffer.
*
* @param {Float32Array} vectorBuffer - Buffer to read.
* @param {number} vectorBufferOffset - Offset to use when we read the given buffer.
* @param {Float32Array} resultBuffer - Buffer to write.
* @param {number} resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return {Float32Array} The result buffer updated with the result of this operation.
*/
function vector3f_floor_floor(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.floor(a0);
    resultBuffer[resultBufferOffset + 1] = Math.floor(a1);
    resultBuffer[resultBufferOffset + 2] = Math.floor(a2);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/ceil.ts
/**
* Ceil each component of a 3 float buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_ceil_ceil(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.ceil(a0);
    resultBuffer[resultBufferOffset + 1] = Math.ceil(a1);
    resultBuffer[resultBufferOffset + 2] = Math.ceil(a2);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/round.ts
/**
* Round each component of a 3 float buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_round_round(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.round(a0);
    resultBuffer[resultBufferOffset + 1] = Math.round(a1);
    resultBuffer[resultBufferOffset + 2] = Math.round(a2);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/dot.ts
/**
* Compute the dot product of two 3 float buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector3f_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    return a0 * b0 + a1 * b1 + a2 * b2;
}

// CONCATENATED MODULE: ./src/vector3f/divideWithScalar.ts
/**
* Divide a 3 float buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/mix.ts
/**
* Compute the a vector that is a mix of two 3 float buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector3f_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 + (b2 - a2) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/multiplyWithScalar.ts
/**
* Multiply a 3 float buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/clamp.ts
/**
* Clamp each component of 3 float buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(Math.min(a2, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/equals.ts
/**
* Test if two 3 float vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector3f_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance &&
        Math.abs(a2 - b2) < tolerance;
}

// CONCATENATED MODULE: ./src/vector3f/negate.ts
/**
* Negate a 3 float buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    resultBuffer[resultBufferOffset + 2] = -a2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/subtract.ts
/**
* Compute the subtraction of two 3 float buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    resultBuffer[resultBufferOffset + 2] = a2 - b2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/maximum.ts
/**
* Update each component of a 3 float buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3f_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    resultBuffer[resultBufferOffset + 2] = Math.min(a2, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3f/index.ts





















// CONCATENATED MODULE: ./src/vector3i/set.ts
/**
* Set the content of a 3 integer buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
* @param a2 - 2th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector3i_set_set(vectorBuffer, vectorBufferOffset, a0, a1, a2) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    vectorBuffer[vectorBufferOffset + 2] = a2;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/toString.ts
/**
* Transform a 3D integer buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector3i_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 3 integer null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        const a2 = vectorBuffer[vectorBufferOffset + 2];
        return [
            `vector 3 integer [`,
            a0, ',', a1, ',', a2,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector3i/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector3i_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    const a2 = sourceBuffer[sourceBufferOffset + 2];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    destinationBuffer[destinationBufferOffset + 2] = a2;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/add.ts
/**
* Perform an addition of two 3 integer vectors.
*
* This function take each components of two 3 integer vectors
* stored into two Int32Array and put the result of their addition
* into another Int32Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector3i_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    resultBuffer[resultBufferOffset + 2] = a2 + b2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/minimum.ts
/**
* Update each component of a 3 integer buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(a2, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/dot.ts
/**
* Compute the dot product of two 3 integer buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector3i_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    return a0 * b0 + a1 * b1 + a2 * b2;
}

// CONCATENATED MODULE: ./src/vector3i/divideWithScalar.ts
/**
* Divide a 3 integer buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/mix.ts
/**
* Compute the a vector that is a mix of two 3 integer buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector3i_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 + (b2 - a2) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/multiplyWithScalar.ts
/**
* Multiply a 3 integer buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/clamp.ts
/**
* Clamp each component of 3 integer buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(Math.min(a2, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/equals.ts
/**
* Test if two 3 integer vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector3i_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance &&
        Math.abs(a2 - b2) < tolerance;
}

// CONCATENATED MODULE: ./src/vector3i/negate.ts
/**
* Negate a 3 integer buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    resultBuffer[resultBufferOffset + 2] = -a2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/subtract.ts
/**
* Compute the subtraction of two 3 integer buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    resultBuffer[resultBufferOffset + 2] = a2 - b2;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/squaredLength.ts
/**
* Return the squared length of a 3 integer buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector3i_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    return a0 * a0 + a1 * a1 + a2 * a2;
}

// CONCATENATED MODULE: ./src/vector3i/maximum.ts
/**
* Update each component of a 3 integer buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector3i_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    resultBuffer[resultBufferOffset + 2] = Math.min(a2, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector3i/length.ts

/**
* Return the length of a 3 integer buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector3i_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector3i_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector3i/index.ts

















// CONCATENATED MODULE: ./src/vector4d/set.ts
/**
* Set the content of a 4 double buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
* @param a2 - 2th vector component value.
* @param a3 - 3th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector4d_set_set(vectorBuffer, vectorBufferOffset, a0, a1, a2, a3) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    vectorBuffer[vectorBufferOffset + 2] = a2;
    vectorBuffer[vectorBufferOffset + 3] = a3;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/squaredLength.ts
/**
* Return the squared length of a 4 double buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector4d_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    return a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
}

// CONCATENATED MODULE: ./src/vector4d/length.ts

/**
* Return the length of a 4 double buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector4d_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector4d_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector4d/normalize.ts

/**
* Normalize a 4 double buffered vector and set the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_normalize_normalize(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const scalar = vector4d_length_length(vectorBuffer, vectorBufferOffset);
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    resultBuffer[resultBufferOffset + 3] = a3 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/toString.ts
/**
* Transform a 4D double buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector4d_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 4 double null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        const a2 = vectorBuffer[vectorBufferOffset + 2];
        const a3 = vectorBuffer[vectorBufferOffset + 3];
        return [
            `vector 4 double [`,
            a0, ',', a1, ',', a2, ',', a3,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector4d/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector4d_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    const a2 = sourceBuffer[sourceBufferOffset + 2];
    const a3 = sourceBuffer[sourceBufferOffset + 3];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    destinationBuffer[destinationBufferOffset + 2] = a2;
    destinationBuffer[destinationBufferOffset + 3] = a3;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/add.ts
/**
* Perform an addition of two 4 double vectors.
*
* This function take each components of two 4 double vectors
* stored into two Float64Array and put the result of their addition
* into another Float64Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector4d_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    resultBuffer[resultBufferOffset + 2] = a2 + b2;
    resultBuffer[resultBufferOffset + 3] = a3 + b3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/minimum.ts
/**
* Update each component of a 4 double buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(a2, minimum);
    resultBuffer[resultBufferOffset + 3] = Math.max(a3, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/floor.ts
/**
* Floor each component of a 4 double buffered vector and put the result into another buffer.
*
* @param {Float64Array} vectorBuffer - Buffer to read.
* @param {number} vectorBufferOffset - Offset to use when we read the given buffer.
* @param {Float64Array} resultBuffer - Buffer to write.
* @param {number} resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return {Float64Array} The result buffer updated with the result of this operation.
*/
function vector4d_floor_floor(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.floor(a0);
    resultBuffer[resultBufferOffset + 1] = Math.floor(a1);
    resultBuffer[resultBufferOffset + 2] = Math.floor(a2);
    resultBuffer[resultBufferOffset + 3] = Math.floor(a3);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/ceil.ts
/**
* Ceil each component of a 4 double buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_ceil_ceil(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.ceil(a0);
    resultBuffer[resultBufferOffset + 1] = Math.ceil(a1);
    resultBuffer[resultBufferOffset + 2] = Math.ceil(a2);
    resultBuffer[resultBufferOffset + 3] = Math.ceil(a3);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/round.ts
/**
* Round each component of a 4 double buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_round_round(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.round(a0);
    resultBuffer[resultBufferOffset + 1] = Math.round(a1);
    resultBuffer[resultBufferOffset + 2] = Math.round(a2);
    resultBuffer[resultBufferOffset + 3] = Math.round(a3);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/dot.ts
/**
* Compute the dot product of two 4 double buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector4d_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    return a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
}

// CONCATENATED MODULE: ./src/vector4d/divideWithScalar.ts
/**
* Divide a 4 double buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    resultBuffer[resultBufferOffset + 3] = a3 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/mix.ts
/**
* Compute the a vector that is a mix of two 4 double buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector4d_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 + (b2 - a2) * scalar;
    resultBuffer[resultBufferOffset + 3] = a3 + (b3 - a3) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/multiplyWithScalar.ts
/**
* Multiply a 4 double buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 * scalar;
    resultBuffer[resultBufferOffset + 3] = a3 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/clamp.ts
/**
* Clamp each component of 4 double buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(Math.min(a2, maximum), minimum);
    resultBuffer[resultBufferOffset + 3] = Math.max(Math.min(a3, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/equals.ts
/**
* Test if two 4 double vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector4d_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance &&
        Math.abs(a2 - b2) < tolerance &&
        Math.abs(a3 - b3) < tolerance;
}

// CONCATENATED MODULE: ./src/vector4d/negate.ts
/**
* Negate a 4 double buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    resultBuffer[resultBufferOffset + 2] = -a2;
    resultBuffer[resultBufferOffset + 3] = -a3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/subtract.ts
/**
* Compute the subtraction of two 4 double buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    resultBuffer[resultBufferOffset + 2] = a2 - b2;
    resultBuffer[resultBufferOffset + 3] = a3 - b3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/maximum.ts
/**
* Update each component of a 4 double buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4d_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    resultBuffer[resultBufferOffset + 2] = Math.min(a2, maximum);
    resultBuffer[resultBufferOffset + 3] = Math.min(a3, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4d/index.ts





















// CONCATENATED MODULE: ./src/vector4f/set.ts
/**
* Set the content of a 4 float buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
* @param a2 - 2th vector component value.
* @param a3 - 3th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector4f_set_set(vectorBuffer, vectorBufferOffset, a0, a1, a2, a3) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    vectorBuffer[vectorBufferOffset + 2] = a2;
    vectorBuffer[vectorBufferOffset + 3] = a3;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/squaredLength.ts
/**
* Return the squared length of a 4 float buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector4f_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    return a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
}

// CONCATENATED MODULE: ./src/vector4f/length.ts

/**
* Return the length of a 4 float buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector4f_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector4f_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector4f/normalize.ts

/**
* Normalize a 4 float buffered vector and set the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_normalize_normalize(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const scalar = vector4f_length_length(vectorBuffer, vectorBufferOffset);
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    resultBuffer[resultBufferOffset + 3] = a3 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/toString.ts
/**
* Transform a 4D float buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector4f_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 4 float null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        const a2 = vectorBuffer[vectorBufferOffset + 2];
        const a3 = vectorBuffer[vectorBufferOffset + 3];
        return [
            `vector 4 float [`,
            a0, ',', a1, ',', a2, ',', a3,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector4f/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector4f_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    const a2 = sourceBuffer[sourceBufferOffset + 2];
    const a3 = sourceBuffer[sourceBufferOffset + 3];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    destinationBuffer[destinationBufferOffset + 2] = a2;
    destinationBuffer[destinationBufferOffset + 3] = a3;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/add.ts
/**
* Perform an addition of two 4 float vectors.
*
* This function take each components of two 4 float vectors
* stored into two Float32Array and put the result of their addition
* into another Float32Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector4f_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    resultBuffer[resultBufferOffset + 2] = a2 + b2;
    resultBuffer[resultBufferOffset + 3] = a3 + b3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/minimum.ts
/**
* Update each component of a 4 float buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(a2, minimum);
    resultBuffer[resultBufferOffset + 3] = Math.max(a3, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/floor.ts
/**
* Floor each component of a 4 float buffered vector and put the result into another buffer.
*
* @param {Float32Array} vectorBuffer - Buffer to read.
* @param {number} vectorBufferOffset - Offset to use when we read the given buffer.
* @param {Float32Array} resultBuffer - Buffer to write.
* @param {number} resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return {Float32Array} The result buffer updated with the result of this operation.
*/
function vector4f_floor_floor(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.floor(a0);
    resultBuffer[resultBufferOffset + 1] = Math.floor(a1);
    resultBuffer[resultBufferOffset + 2] = Math.floor(a2);
    resultBuffer[resultBufferOffset + 3] = Math.floor(a3);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/ceil.ts
/**
* Ceil each component of a 4 float buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_ceil_ceil(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.ceil(a0);
    resultBuffer[resultBufferOffset + 1] = Math.ceil(a1);
    resultBuffer[resultBufferOffset + 2] = Math.ceil(a2);
    resultBuffer[resultBufferOffset + 3] = Math.ceil(a3);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/round.ts
/**
* Round each component of a 4 float buffered vector and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_round_round(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.round(a0);
    resultBuffer[resultBufferOffset + 1] = Math.round(a1);
    resultBuffer[resultBufferOffset + 2] = Math.round(a2);
    resultBuffer[resultBufferOffset + 3] = Math.round(a3);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/dot.ts
/**
* Compute the dot product of two 4 float buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector4f_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    return a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
}

// CONCATENATED MODULE: ./src/vector4f/divideWithScalar.ts
/**
* Divide a 4 float buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    resultBuffer[resultBufferOffset + 3] = a3 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/mix.ts
/**
* Compute the a vector that is a mix of two 4 float buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector4f_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 + (b2 - a2) * scalar;
    resultBuffer[resultBufferOffset + 3] = a3 + (b3 - a3) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/multiplyWithScalar.ts
/**
* Multiply a 4 float buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 * scalar;
    resultBuffer[resultBufferOffset + 3] = a3 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/clamp.ts
/**
* Clamp each component of 4 float buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(Math.min(a2, maximum), minimum);
    resultBuffer[resultBufferOffset + 3] = Math.max(Math.min(a3, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/equals.ts
/**
* Test if two 4 float vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector4f_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance &&
        Math.abs(a2 - b2) < tolerance &&
        Math.abs(a3 - b3) < tolerance;
}

// CONCATENATED MODULE: ./src/vector4f/negate.ts
/**
* Negate a 4 float buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    resultBuffer[resultBufferOffset + 2] = -a2;
    resultBuffer[resultBufferOffset + 3] = -a3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/subtract.ts
/**
* Compute the subtraction of two 4 float buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    resultBuffer[resultBufferOffset + 2] = a2 - b2;
    resultBuffer[resultBufferOffset + 3] = a3 - b3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/maximum.ts
/**
* Update each component of a 4 float buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4f_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    resultBuffer[resultBufferOffset + 2] = Math.min(a2, maximum);
    resultBuffer[resultBufferOffset + 3] = Math.min(a3, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4f/index.ts





















// CONCATENATED MODULE: ./src/vector4i/set.ts
/**
* Set the content of a 4 integer buffered vector.
*
* @param vectorBuffer - Buffer to write.
* @param vectorBufferOffset - Offset to use when we write the result into the given buffer.
* @param a0 - 0th vector component value.
* @param a1 - 1th vector component value.
* @param a2 - 2th vector component value.
* @param a3 - 3th vector component value.
*
* @return The given buffer updated with the new values.
*/
function vector4i_set_set(vectorBuffer, vectorBufferOffset, a0, a1, a2, a3) {
    vectorBuffer[vectorBufferOffset + 0] = a0;
    vectorBuffer[vectorBufferOffset + 1] = a1;
    vectorBuffer[vectorBufferOffset + 2] = a2;
    vectorBuffer[vectorBufferOffset + 3] = a3;
    return vectorBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/toString.ts
/**
* Transform a 4D integer buffered vector into a string.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return A string representation of the given vector.
*/
function vector4i_toString_toString(vectorBuffer, vectorBufferOffset) {
    if (vectorBuffer == null) {
        return 'vector 4 integer null';
    }
    else {
        const a0 = vectorBuffer[vectorBufferOffset + 0];
        const a1 = vectorBuffer[vectorBufferOffset + 1];
        const a2 = vectorBuffer[vectorBufferOffset + 2];
        const a3 = vectorBuffer[vectorBufferOffset + 3];
        return [
            `vector 4 integer [`,
            a0, ',', a1, ',', a2, ',', a3,
            ']'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/vector4i/copy.ts
/**
* Copy a vector from a buffer to another.
*
* @param sourceBuffer - Buffer that contains the left operand vector.
* @param sourceBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param destinationBuffer - Buffer that contains the right operand vector.
* @param destinationBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
*
* @return The updated destination buffer.
*/
function vector4i_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a0 = sourceBuffer[sourceBufferOffset + 0];
    const a1 = sourceBuffer[sourceBufferOffset + 1];
    const a2 = sourceBuffer[sourceBufferOffset + 2];
    const a3 = sourceBuffer[sourceBufferOffset + 3];
    destinationBuffer[destinationBufferOffset + 0] = a0;
    destinationBuffer[destinationBufferOffset + 1] = a1;
    destinationBuffer[destinationBufferOffset + 2] = a2;
    destinationBuffer[destinationBufferOffset + 3] = a3;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/add.ts
/**
* Perform an addition of two 4 integer vectors.
*
* This function take each components of two 4 integer vectors
* stored into two Int32Array and put the result of their addition
* into another Int32Array.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector4i_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 + b0;
    resultBuffer[resultBufferOffset + 1] = a1 + b1;
    resultBuffer[resultBufferOffset + 2] = a2 + b2;
    resultBuffer[resultBufferOffset + 3] = a3 + b3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/minimum.ts
/**
* Update each component of a 4 integer buffered vector less than the given minimum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_minimum_minimum(vectorBuffer, vectorBufferOffset, minimum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.max(a0, minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(a1, minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(a2, minimum);
    resultBuffer[resultBufferOffset + 3] = Math.max(a3, minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/dot.ts
/**
* Compute the dot product of two 4 integer buffered vectors and return the result.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
*
* @return The result of the dot product.
*/
function vector4i_dot_dot(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    return a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
}

// CONCATENATED MODULE: ./src/vector4i/divideWithScalar.ts
/**
* Divide a 4 integer buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the division.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_divideWithScalar_divideWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 / scalar;
    resultBuffer[resultBufferOffset + 1] = a1 / scalar;
    resultBuffer[resultBufferOffset + 2] = a2 / scalar;
    resultBuffer[resultBufferOffset + 3] = a3 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/mix.ts
/**
* Compute the a vector that is a mix of two 4 integer buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param scalar - A float number between 0 and 1.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The updated result buffer.
*/
function vector4i_mix_mix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 + (b0 - a0) * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 + (b1 - a1) * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 + (b2 - a2) * scalar;
    resultBuffer[resultBufferOffset + 3] = a3 + (b3 - a3) * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/multiplyWithScalar.ts
/**
* Multiply a 4 integer buffered vector with a scalar and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param scalar - Scalar to use for the multiplication.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_multiplyWithScalar_multiplyWithScalar(vectorBuffer, vectorBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 * scalar;
    resultBuffer[resultBufferOffset + 1] = a1 * scalar;
    resultBuffer[resultBufferOffset + 2] = a2 * scalar;
    resultBuffer[resultBufferOffset + 3] = a3 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/clamp.ts
/**
* Clamp each component of 4 integer buffered vector between two values, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param minimum - Minimum value allowed.
* @param maximum - Maximum value allowed.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_clamp_clamp(vectorBuffer, vectorBufferOffset, minimum, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.max(Math.min(a0, maximum), minimum);
    resultBuffer[resultBufferOffset + 1] = Math.max(Math.min(a1, maximum), minimum);
    resultBuffer[resultBufferOffset + 2] = Math.max(Math.min(a2, maximum), minimum);
    resultBuffer[resultBufferOffset + 3] = Math.max(Math.min(a3, maximum), minimum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/equals.ts
/**
* Test if two 4 integer vectors from two buffers are equals.
*
* @param leftBuffer - Buffer that contains the left operand vector.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand vector.
* @param rightBuffer - Buffer that contains the right operand vector.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand vector.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both vector are equals, false otherwise.
*/
function vector4i_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    return Math.abs(a0 - b0) < tolerance &&
        Math.abs(a1 - b1) < tolerance &&
        Math.abs(a2 - b2) < tolerance &&
        Math.abs(a3 - b3) < tolerance;
}

// CONCATENATED MODULE: ./src/vector4i/negate.ts
/**
* Negate a 4 integer buffered vector and put the result in another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_negate_negate(vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = -a0;
    resultBuffer[resultBufferOffset + 1] = -a1;
    resultBuffer[resultBufferOffset + 2] = -a2;
    resultBuffer[resultBufferOffset + 3] = -a3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/subtract.ts
/**
* Compute the subtraction of two 4 integer buffered vectors and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand.
* @param leftBufferOffset - Offset to use when we read the buffer that contains the left operand.
* @param rightBuffer - Buffer that contains the right operand.
* @param rightBufferOffset - Offset to use when we read the buffer that contains the right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a0 = leftBuffer[leftBufferOffset + 0];
    const a1 = leftBuffer[leftBufferOffset + 1];
    const a2 = leftBuffer[leftBufferOffset + 2];
    const a3 = leftBuffer[leftBufferOffset + 3];
    const b0 = rightBuffer[rightBufferOffset + 0];
    const b1 = rightBuffer[rightBufferOffset + 1];
    const b2 = rightBuffer[rightBufferOffset + 2];
    const b3 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a0 - b0;
    resultBuffer[resultBufferOffset + 1] = a1 - b1;
    resultBuffer[resultBufferOffset + 2] = a2 - b2;
    resultBuffer[resultBufferOffset + 3] = a3 - b3;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/squaredLength.ts
/**
* Return the squared length of a 4 integer buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The squared length of the given vector.
*/
function vector4i_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    return a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
}

// CONCATENATED MODULE: ./src/vector4i/maximum.ts
/**
* Update each component of a 4 integer buffered vector greather than the given maximum, and put the result into another buffer.
*
* @param vectorBuffer - Buffer to read.
* @param vectorBufferOffset - Offset to use when we read the given buffer.
* @param maximum - Maximum value allowed.
* @param  resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to use when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function vector4i_maximum_maximum(vectorBuffer, vectorBufferOffset, maximum, resultBuffer, resultBufferOffset) {
    const a0 = vectorBuffer[vectorBufferOffset + 0];
    const a1 = vectorBuffer[vectorBufferOffset + 1];
    const a2 = vectorBuffer[vectorBufferOffset + 2];
    const a3 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.min(a0, maximum);
    resultBuffer[resultBufferOffset + 1] = Math.min(a1, maximum);
    resultBuffer[resultBufferOffset + 2] = Math.min(a2, maximum);
    resultBuffer[resultBufferOffset + 3] = Math.min(a3, maximum);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/vector4i/length.ts

/**
* Return the length of a 4 integer buffered vector.
*
* @param vectorBuffer - Buffer that contains the vector to transform.
* @param vectorBufferOffset - Offset to use when we read the buffer that contains the vector to transform.
*
* @return The length of the given vector.
*/
function vector4i_length_length(vectorBuffer, vectorBufferOffset) {
    return Math.sqrt(vector4i_squaredLength_squaredLength(vectorBuffer, vectorBufferOffset));
}

// CONCATENATED MODULE: ./src/vector4i/index.ts

















// CONCATENATED MODULE: ./src/Vector2d.ts

class Vector2d_Vector2d {
    /**
    * Create a new 2 double vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y) {
        return new Vector2d_Vector2d().set(x, y);
    }
    /**
    * Wrap a Float64Array as a 2 double vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector2d_Vector2d(buffer);
    }
    /**
    * Clone another 2 double vector and return the result.
    *
    * @param vector - A 2 double vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector2d_Vector2d();
        result.x = vector.x;
        result.y = vector.y;
        return result;
    }
    /**
    * Create a new 2 double vector.
    *
    * @param [buffer = new Float64Array(2)] - A buffer to wrap.
    */
    constructor(buffer = new Float64Array(2)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 2;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y) {
        set(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Normalize this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    normalize(result = this) {
        normalize(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Ceil each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    ceil(result = this) {
        ceil(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Floor each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    floor(result = this) {
        floor(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Round each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    round(result = this) {
        round(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Compute the clockwise normal of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clockwiseNormal(result = this) {
        clockwiseNormal(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Compute the counter-clockwise normal of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    counterClockwiseNormal(result = this) {
        counterClockwiseNormal(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Compute the angle between this vector and another one and return the result in radians.
    *
    * @param other - The other vector to use.
    *
    * @return The angle between this vector and the other one in radians.
    */
    angleWith(other) {
        return angleBetween(this._buffer, 0, other.buffer, 0);
    }
    /**
    * Compute the angle between the x axis vector and this one and return it.
    *
    * @return The angle between the x axis vector and this one in radians.
    */
    get angle() {
        return angle(this._buffer, 0);
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector2f.ts

class Vector2f_Vector2f {
    /**
    * Create a new 2 float vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y) {
        return new Vector2f_Vector2f().set(x, y);
    }
    /**
    * Wrap a Float32Array as a 2 float vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector2f_Vector2f(buffer);
    }
    /**
    * Clone another 2 float vector and return the result.
    *
    * @param vector - A 2 float vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector2f_Vector2f();
        result.x = vector.x;
        result.y = vector.y;
        return result;
    }
    /**
    * Create a new 2 float vector.
    *
    * @param [buffer = new Float32Array(2)] - A buffer to wrap.
    */
    constructor(buffer = new Float32Array(2)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 2;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector2f_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y) {
        set_set(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Normalize this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    normalize(result = this) {
        normalize_normalize(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Ceil each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    ceil(result = this) {
        ceil_ceil(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Floor each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    floor(result = this) {
        floor_floor(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Round each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    round(result = this) {
        round_round(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector2f_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector2f_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Compute the clockwise normal of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clockwiseNormal(result = this) {
        normal_clockwiseNormal(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Compute the counter-clockwise normal of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    counterClockwiseNormal(result = this) {
        normal_counterClockwiseNormal(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Compute the angle between this vector and another one and return the result in radians.
    *
    * @param other - The other vector to use.
    *
    * @return The angle between this vector and the other one in radians.
    */
    angleWith(other) {
        return angle_angleBetween(this._buffer, 0, other.buffer, 0);
    }
    /**
    * Compute the angle between the x axis vector and this one and return it.
    *
    * @return The angle between the x axis vector and this one in radians.
    */
    get angle() {
        return angle_angle(this._buffer, 0);
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector2f_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector2i.ts

class Vector2i_Vector2i {
    /**
    * Create a new 2 integer vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y) {
        return new Vector2i_Vector2i().set(x, y);
    }
    /**
    * Wrap a Int32Array as a 2 integer vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector2i_Vector2i(buffer);
    }
    /**
    * Clone another 2 integer vector and return the result.
    *
    * @param vector - A 2 integer vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector2i_Vector2i();
        result.x = vector.x;
        result.y = vector.y;
        return result;
    }
    /**
    * Create a new 2 integer vector.
    *
    * @param [buffer = new Int32Array(2)] - A buffer to wrap.
    */
    constructor(buffer = new Int32Array(2)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 2;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector2i_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector2i_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y) {
        vector2i_set_set(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector2i_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector2i_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector2i_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector2i_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector2i_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector2i_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector2i_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector2i_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector2i_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector2i_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Compute the clockwise normal of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clockwiseNormal(result = this) {
        vector2i_normal_clockwiseNormal(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Compute the counter-clockwise normal of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    counterClockwiseNormal(result = this) {
        vector2i_normal_counterClockwiseNormal(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Compute the angle between this vector and another one and return the result in radians.
    *
    * @param other - The other vector to use.
    *
    * @return The angle between this vector and the other one in radians.
    */
    angleWith(other) {
        return vector2i_angle_angleBetween(this._buffer, 0, other.buffer, 0);
    }
    /**
    * Compute the angle between the x axis vector and this one and return it.
    *
    * @return The angle between the x axis vector and this one in radians.
    */
    get angle() {
        return vector2i_angle_angle(this._buffer, 0);
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector2i_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector2i_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector2i_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector3d.ts

class Vector3d_Vector3d {
    /**
    * Create a new 3 double vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y, z) {
        return new Vector3d_Vector3d().set(x, y, z);
    }
    /**
    * Wrap a Float64Array as a 3 double vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector3d_Vector3d(buffer);
    }
    /**
    * Clone another 3 double vector and return the result.
    *
    * @param vector - A 3 double vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector3d_Vector3d();
        result.x = vector.x;
        result.y = vector.y;
        result.z = vector.z;
        return result;
    }
    /**
    * Create a new 3 double vector.
    *
    * @param [buffer = new Float64Array(3)] - A buffer to wrap.
    */
    constructor(buffer = new Float64Array(3)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get z() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set z(value) {
        this._buffer[2] = value;
    }
    /**
    * @return {number} The  component of this vector.
    */
    get r() {
        return this._buffer[0];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get g() {
        return this._buffer[1];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get b() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set r(value) {
        this._buffer[0] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set g(value) {
        this._buffer[1] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set b(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 3;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector3d_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector3d_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y, z) {
        vector3d_set_set(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector3d_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector3d_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector3d_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector3d_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector3d_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector3d_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Normalize this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    normalize(result = this) {
        vector3d_normalize_normalize(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Ceil each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    ceil(result = this) {
        vector3d_ceil_ceil(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Floor each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    floor(result = this) {
        vector3d_floor_floor(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Round each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    round(result = this) {
        vector3d_round_round(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector3d_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector3d_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector3d_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector3d_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector3d_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector3d_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector3d_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector3f.ts

class Vector3f_Vector3f {
    /**
    * Create a new 3 float vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y, z) {
        return new Vector3f_Vector3f().set(x, y, z);
    }
    /**
    * Wrap a Float32Array as a 3 float vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector3f_Vector3f(buffer);
    }
    /**
    * Clone another 3 float vector and return the result.
    *
    * @param vector - A 3 float vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector3f_Vector3f();
        result.x = vector.x;
        result.y = vector.y;
        result.z = vector.z;
        return result;
    }
    /**
    * Create a new 3 float vector.
    *
    * @param [buffer = new Float32Array(3)] - A buffer to wrap.
    */
    constructor(buffer = new Float32Array(3)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get z() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set z(value) {
        this._buffer[2] = value;
    }
    /**
    * @return {number} The  component of this vector.
    */
    get r() {
        return this._buffer[0];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get g() {
        return this._buffer[1];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get b() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set r(value) {
        this._buffer[0] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set g(value) {
        this._buffer[1] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set b(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 3;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector3f_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector3f_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y, z) {
        vector3f_set_set(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector3f_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector3f_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector3f_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector3f_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector3f_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector3f_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Normalize this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    normalize(result = this) {
        vector3f_normalize_normalize(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Ceil each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    ceil(result = this) {
        vector3f_ceil_ceil(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Floor each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    floor(result = this) {
        vector3f_floor_floor(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Round each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    round(result = this) {
        vector3f_round_round(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector3f_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector3f_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector3f_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector3f_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector3f_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector3f_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector3f_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector3i.ts

class Vector3i_Vector3i {
    /**
    * Create a new 3 integer vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y, z) {
        return new Vector3i_Vector3i().set(x, y, z);
    }
    /**
    * Wrap a Int32Array as a 3 integer vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector3i_Vector3i(buffer);
    }
    /**
    * Clone another 3 integer vector and return the result.
    *
    * @param vector - A 3 integer vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector3i_Vector3i();
        result.x = vector.x;
        result.y = vector.y;
        result.z = vector.z;
        return result;
    }
    /**
    * Create a new 3 integer vector.
    *
    * @param [buffer = new Int32Array(3)] - A buffer to wrap.
    */
    constructor(buffer = new Int32Array(3)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get z() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set z(value) {
        this._buffer[2] = value;
    }
    /**
    * @return {number} The  component of this vector.
    */
    get r() {
        return this._buffer[0];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get g() {
        return this._buffer[1];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get b() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set r(value) {
        this._buffer[0] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set g(value) {
        this._buffer[1] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set b(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 3;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector3i_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector3i_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y, z) {
        vector3i_set_set(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector3i_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector3i_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector3i_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector3i_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector3i_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector3i_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector3i_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector3i_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector3i_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector3i_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector3i_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector3i_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector3i_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector4d.ts

class Vector4d_Vector4d {
    /**
    * Create a new 4 double vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    * @param w - w component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y, z, w) {
        return new Vector4d_Vector4d().set(x, y, z, w);
    }
    /**
    * Wrap a Float64Array as a 4 double vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector4d_Vector4d(buffer);
    }
    /**
    * Clone another 4 double vector and return the result.
    *
    * @param vector - A 4 double vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector4d_Vector4d();
        result.x = vector.x;
        result.y = vector.y;
        result.z = vector.z;
        result.w = vector.w;
        return result;
    }
    /**
    * Create a new 4 double vector.
    *
    * @param [buffer = new Float64Array(4)] - A buffer to wrap.
    */
    constructor(buffer = new Float64Array(4)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get z() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set z(value) {
        this._buffer[2] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get w() {
        return this._buffer[3];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set w(value) {
        this._buffer[3] = value;
    }
    /**
    * @return {number} The  component of this vector.
    */
    get r() {
        return this._buffer[0];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get g() {
        return this._buffer[1];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get b() {
        return this._buffer[2];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get a() {
        return this._buffer[3];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set r(value) {
        this._buffer[0] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set g(value) {
        this._buffer[1] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set b(value) {
        this._buffer[2] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set a(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 4;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector4d_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector4d_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    * @param w - w component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y, z, w) {
        vector4d_set_set(this._buffer, 0, x, y, z, w);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector4d_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector4d_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector4d_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector4d_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector4d_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector4d_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Normalize this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    normalize(result = this) {
        vector4d_normalize_normalize(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Ceil each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    ceil(result = this) {
        vector4d_ceil_ceil(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Floor each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    floor(result = this) {
        vector4d_floor_floor(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Round each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    round(result = this) {
        vector4d_round_round(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector4d_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector4d_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector4d_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector4d_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector4d_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector4d_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector4d_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector4f.ts

class Vector4f_Vector4f {
    /**
    * Create a new 4 float vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    * @param w - w component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y, z, w) {
        return new Vector4f_Vector4f().set(x, y, z, w);
    }
    /**
    * Wrap a Float32Array as a 4 float vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector4f_Vector4f(buffer);
    }
    /**
    * Clone another 4 float vector and return the result.
    *
    * @param vector - A 4 float vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector4f_Vector4f();
        result.x = vector.x;
        result.y = vector.y;
        result.z = vector.z;
        result.w = vector.w;
        return result;
    }
    /**
    * Create a new 4 float vector.
    *
    * @param [buffer = new Float32Array(4)] - A buffer to wrap.
    */
    constructor(buffer = new Float32Array(4)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get z() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set z(value) {
        this._buffer[2] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get w() {
        return this._buffer[3];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set w(value) {
        this._buffer[3] = value;
    }
    /**
    * @return {number} The  component of this vector.
    */
    get r() {
        return this._buffer[0];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get g() {
        return this._buffer[1];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get b() {
        return this._buffer[2];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get a() {
        return this._buffer[3];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set r(value) {
        this._buffer[0] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set g(value) {
        this._buffer[1] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set b(value) {
        this._buffer[2] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set a(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 4;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector4f_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector4f_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    * @param w - w component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y, z, w) {
        vector4f_set_set(this._buffer, 0, x, y, z, w);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector4f_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector4f_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector4f_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector4f_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector4f_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector4f_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Normalize this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    normalize(result = this) {
        vector4f_normalize_normalize(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Ceil each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    ceil(result = this) {
        vector4f_ceil_ceil(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Floor each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    floor(result = this) {
        vector4f_floor_floor(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Round each component of this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    round(result = this) {
        vector4f_round_round(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector4f_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector4f_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector4f_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector4f_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector4f_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector4f_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector4f_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Vector4i.ts

class Vector4i_Vector4i {
    /**
    * Create a new 4 integer vector with initial data.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    * @param w - w component of the new vector
    *
    * @return The new vector instance.
    */
    static create(x, y, z, w) {
        return new Vector4i_Vector4i().set(x, y, z, w);
    }
    /**
    * Wrap a Int32Array as a 4 integer vector.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return The new vector instance.
    */
    static wrap(buffer) {
        return new Vector4i_Vector4i(buffer);
    }
    /**
    * Clone another 4 integer vector and return the result.
    *
    * @param vector - A 4 integer vector to clone.
    *
    * @return The cloned vector instance.
    */
    static clone(vector) {
        const result = new Vector4i_Vector4i();
        result.x = vector.x;
        result.y = vector.y;
        result.z = vector.z;
        result.w = vector.w;
        return result;
    }
    /**
    * Create a new 4 integer vector.
    *
    * @param [buffer = new Int32Array(4)] - A buffer to wrap.
    */
    constructor(buffer = new Int32Array(4)) {
        this._buffer = buffer;
    }
    /**
    * @return The  component of this vector.
    */
    get x() {
        return this._buffer[0];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set x(value) {
        this._buffer[0] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get y() {
        return this._buffer[1];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set y(value) {
        this._buffer[1] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get z() {
        return this._buffer[2];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set z(value) {
        this._buffer[2] = value;
    }
    /**
    * @return The  component of this vector.
    */
    get w() {
        return this._buffer[3];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set w(value) {
        this._buffer[3] = value;
    }
    /**
    * @return {number} The  component of this vector.
    */
    get r() {
        return this._buffer[0];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get g() {
        return this._buffer[1];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get b() {
        return this._buffer[2];
    }
    /**
    * @return {number} The  component of this vector.
    */
    get a() {
        return this._buffer[3];
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set r(value) {
        this._buffer[0] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set g(value) {
        this._buffer[1] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set b(value) {
        this._buffer[2] = value;
    }
    /**
    * Set the value of the  component of this vector.
    *
    * @param value - New value of the  component.
    */
    set a(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the underlying buffer of this vector.
    *
    * @return The underlying buffer of this vector.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * Return the dimension of this vector.
    *
    * @return The dimension of this vector.
    */
    get dimension() {
        return 4;
    }
    /**
    * Return the squared length of this vector.
    *
    * @return The squared length of this vector.
    */
    get squaredLength() {
        return vector4i_squaredLength_squaredLength(this._buffer, 0);
    }
    /**
    * Return the length of this vector.
    *
    * @return The length of this vector.
    */
    get length() {
        return vector4i_length_length(this._buffer, 0);
    }
    /**
    * Set all components of this vector.
    *
    * @param x - x component of the new vector
    * @param y - y component of the new vector
    * @param z - z component of the new vector
    * @param w - w component of the new vector
    *
    * @return This vector instance for chaining purpose.
    */
    set(x, y, z, w) {
        vector4i_set_set(this._buffer, 0, x, y, z, w);
        return this;
    }
    /**
    * Copy the content of another vector.
    *
    * @param toCopy - Vector to copy.
    *
    * @return This vector instance for chaining purpose.
    */
    copy(toCopy) {
        vector4i_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Add another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    add(left, result = this) {
        vector4i_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another vector to this vector.
    *
    * @param left - Left operand vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    subtract(left, result = this) {
        vector4i_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this vector with a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        vector4i_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this vector by a scalar.
    *
    * @param scalar
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        vector4i_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Negate this vector.
    *
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    negate(result = this) {
        vector4i_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector less than the given minimum to the given minimum.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    minimum(minimum, result = this) {
        vector4i_minimum_minimum(this._buffer, 0, minimum, result.buffer, 0);
        return this;
    }
    /**
    * Update each component of this vector greather than the given maximum to the given maximum.
    *
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    maximum(maximum, result = this) {
        vector4i_maximum_maximum(this._buffer, 0, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Clamp each component of this vector between a minimum and a amaximum value.
    *
    * @param minimum - Minimum value allowed for each components of this vector.
    * @param maximum - Maximum value allowed for each components of this vector.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    clamp(minimum, maximum, result = this) {
        vector4i_clamp_clamp(this._buffer, 0, minimum, maximum, result.buffer, 0);
        return this;
    }
    /**
    * Mix this vector with another.
    *
    * @param left - Left operand vector.
    * @param scalar - A value between 0 and 1.
    * @param [result = this] - The result vector.
    *
    * @return This vector instance for chaining purpose.
    */
    mix(left, scalar, result = this) {
        vector4i_mix_mix(this._buffer, 0, left.buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Return the dot product of this vector with another one.
    *
    * @param left - Left operand vector.
    *
    * @return The result of the dot product.
    */
    dot(left) {
        return vector4i_dot_dot(this._buffer, 0, left.buffer, 0);
    }
    /**
    * Iterate over each components of this vector.
    *
    * @return An iterator over each components of this vector.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
    }
    /**
    * Return true if this vector is equal to another.
    *
    * @param left - Left operand vector.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this vector is equal to the given vector, false otherwise.
    */
    equals(left, tolerance = Number.EPSILON) {
        return vector4i_equals_equals(this._buffer, 0, left.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this vector.
    *
    * @return A string representation of this vector.
    */
    toString() {
        return vector4i_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/matrix2f/set.ts
/**
* Set the content of a 2 by 2 float buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix2f_set_set(buffer, bufferOffset, a00, a10, a01, a11) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a01;
    buffer[bufferOffset + 3] = a11;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix2f/multiplyWithVector.ts
/**
* Multiply 2 by 2 float buffered matrix with a 2 float buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/toScale.ts
/**
* Set the content of a 2 by 2 float buffered matrix to the content of a 2 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
*
* @return The buffer, updated with the content of a 2 dimensional scale matrix.
*/
function toScale(matrixBuffer, matrixBufferOffset, x, y) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = y;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/toString.ts
/**
* Transform a 2 by 2 float buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix2f_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 2 by 2 float null';
    }
    else {
        return [
            `matrix 2 by 2 float `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 3].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix2f/copy.ts
/**
* Copy the content of a 2 by 2 float buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix2f_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a01 = sourceBuffer[sourceBufferOffset + 2];
    const a11 = sourceBuffer[sourceBufferOffset + 3];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a01;
    destinationBuffer[destinationBufferOffset + 3] = a11;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/translate.ts
/**
* Apply a 1 dimensional translation to a 2 by 2 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function translate(matrixBuffer, matrixBufferOffset, x, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = x;
    const a01 = 0;
    const a11 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/add.ts
/**
* Add a 2 by 2 float buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2f_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a01 + b01;
    resultBuffer[resultBufferOffset + 3] = a11 + b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 2 by 2 float buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a01, a11, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b01 = leftBuffer[leftBufferOffset + 2];
    const b11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/rotate.ts
/**
* Apply a 2 dimensional rotation to a 2 by 2 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function rotate(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const a00 = cosx;
    const a10 = -sinx;
    const a01 = sinx;
    const a11 = cosx;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/multiplyWithMatrix.ts
/**
* Multiply 2 by 2 float buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/determinant.ts
/**
* Compute and return the determinant of a 2 by 2 float buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 2 by 2 float buffered matrix.
*/
function determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    return a00 * a11 - a10 * a01;
}

// CONCATENATED MODULE: ./src/matrix2f/toRotation.ts
/**
* Set the content of a 2 by 2 float buffered matrix to a 2 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
*
* @return The buffer, updated with the content of a 2 dimensional rotation.
*/
function toRotation(matrixBuffer, matrixBufferOffset, x, y) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    matrixBuffer[matrixBufferOffset + 0] = cosx;
    matrixBuffer[matrixBufferOffset + 1] = -sinx;
    matrixBuffer[matrixBufferOffset + 2] = sinx;
    matrixBuffer[matrixBufferOffset + 3] = cosx;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/extractTranslation.ts
/**
* Extract a translation from a 2 by 2 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 1];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/divideWithScalar.ts
/**
* Divide a 2 by 2 float buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2f_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a01 / scalar;
    resultBuffer[resultBufferOffset + 3] = a11 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/invert.ts

/**
* Invert a 2 by 2 float buffered matrix and write the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function invert(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    const determinantValue = determinant(matrixBuffer, matrixBufferOffset);
    resultBuffer[resultBufferOffset + 0] = a11 / determinantValue;
    resultBuffer[resultBufferOffset + 1] = -a10 / determinantValue;
    resultBuffer[resultBufferOffset + 2] = -a01 / determinantValue;
    resultBuffer[resultBufferOffset + 3] = a00 / determinantValue;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/multiplyWithScalar.ts
/**
* Multiply a 2 by 2 float buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2f_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a01 * scalar;
    resultBuffer[resultBufferOffset + 3] = a11 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 2 by 2 float buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b01, b11, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a01 = rightBuffer[rightBufferOffset + 2];
    const a11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/extract2DRotation.ts
/**
* Extract a 2D rotation from a 2 by 2 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix2f/toIdentity.ts
/**
* Set the content of a 2 by 2 float buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/equals.ts
/**
* Compare two 2 by 2 float buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix2f_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix2f/negate.ts
/**
* Negate a 2 by 2 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2f_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a01;
    resultBuffer[resultBufferOffset + 3] = -a11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/subtract.ts
/**
* Subtract a 2 by 2 float buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2f_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a01 - b01;
    resultBuffer[resultBufferOffset + 3] = a11 - b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/scale.ts
/**
* Apply a 2 dimensional scale to a 2 by 2 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function scale(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = x * b01;
    resultBuffer[resultBufferOffset + 3] = y * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/fill.ts
/**
* Fill a 2 by 2 float buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 2 by 2 float buffered matrix with a 2 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    return a00 * x + a10 * y;
}
/**
* Multiply 2 by 2 float buffered matrix with a 2 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y) {
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    return a01 * x + a11 * y;
}

// CONCATENATED MODULE: ./src/matrix2f/toTranslation.ts
/**
* Set the content of a 2 by 2 float buffered matrix to the content of a 1 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
*
* @return The buffer, updated with the content of a 1 dimensional translation matrix.
*/
function toTranslation(matrixBuffer, matrixBufferOffset, x) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = x;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/transpose.ts
/**
* Transpose a 2 by 2 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a10;
    resultBuffer[resultBufferOffset + 3] = a11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/extractScale.ts
/**
* Extract a scale from a 2 by 2 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 2 dimensional scale vector extracted from the given matrix.
*/
function extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11) * ((a11 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2f/index.ts





























// CONCATENATED MODULE: ./src/matrix2d/set.ts
/**
* Set the content of a 2 by 2 double buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix2d_set_set(buffer, bufferOffset, a00, a10, a01, a11) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a01;
    buffer[bufferOffset + 3] = a11;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix2d/multiplyWithVector.ts
/**
* Multiply 2 by 2 double buffered matrix with a 2 double buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/toScale.ts
/**
* Set the content of a 2 by 2 double buffered matrix to the content of a 2 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
*
* @return The buffer, updated with the content of a 2 dimensional scale matrix.
*/
function toScale_toScale(matrixBuffer, matrixBufferOffset, x, y) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = y;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/toString.ts
/**
* Transform a 2 by 2 double buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix2d_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 2 by 2 double null';
    }
    else {
        return [
            `matrix 2 by 2 double `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 3].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix2d/copy.ts
/**
* Copy the content of a 2 by 2 double buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix2d_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a01 = sourceBuffer[sourceBufferOffset + 2];
    const a11 = sourceBuffer[sourceBufferOffset + 3];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a01;
    destinationBuffer[destinationBufferOffset + 3] = a11;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/translate.ts
/**
* Apply a 1 dimensional translation to a 2 by 2 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function translate_translate(matrixBuffer, matrixBufferOffset, x, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = x;
    const a01 = 0;
    const a11 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/add.ts
/**
* Add a 2 by 2 double buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2d_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a01 + b01;
    resultBuffer[resultBufferOffset + 3] = a11 + b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 2 by 2 double buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a01, a11, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b01 = leftBuffer[leftBufferOffset + 2];
    const b11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/rotate.ts
/**
* Apply a 2 dimensional rotation to a 2 by 2 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const a00 = cosx;
    const a10 = -sinx;
    const a01 = sinx;
    const a11 = cosx;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/multiplyWithMatrix.ts
/**
* Multiply 2 by 2 double buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/determinant.ts
/**
* Compute and return the determinant of a 2 by 2 double buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 2 by 2 double buffered matrix.
*/
function determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    return a00 * a11 - a10 * a01;
}

// CONCATENATED MODULE: ./src/matrix2d/toRotation.ts
/**
* Set the content of a 2 by 2 double buffered matrix to a 2 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
*
* @return The buffer, updated with the content of a 2 dimensional rotation.
*/
function toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    matrixBuffer[matrixBufferOffset + 0] = cosx;
    matrixBuffer[matrixBufferOffset + 1] = -sinx;
    matrixBuffer[matrixBufferOffset + 2] = sinx;
    matrixBuffer[matrixBufferOffset + 3] = cosx;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/extractTranslation.ts
/**
* Extract a translation from a 2 by 2 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 1];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/divideWithScalar.ts
/**
* Divide a 2 by 2 double buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2d_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a01 / scalar;
    resultBuffer[resultBufferOffset + 3] = a11 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/invert.ts

/**
* Invert a 2 by 2 double buffered matrix and write the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function invert_invert(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    const determinantValue = determinant_determinant(matrixBuffer, matrixBufferOffset);
    resultBuffer[resultBufferOffset + 0] = a11 / determinantValue;
    resultBuffer[resultBufferOffset + 1] = -a10 / determinantValue;
    resultBuffer[resultBufferOffset + 2] = -a01 / determinantValue;
    resultBuffer[resultBufferOffset + 3] = a00 / determinantValue;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/multiplyWithScalar.ts
/**
* Multiply a 2 by 2 double buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2d_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a01 * scalar;
    resultBuffer[resultBufferOffset + 3] = a11 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 2 by 2 double buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b01, b11, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a01 = rightBuffer[rightBufferOffset + 2];
    const a11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/extract2DRotation.ts
/**
* Extract a 2D rotation from a 2 by 2 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix2d/toIdentity.ts
/**
* Set the content of a 2 by 2 double buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/equals.ts
/**
* Compare two 2 by 2 double buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix2d_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix2d/negate.ts
/**
* Negate a 2 by 2 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2d_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a01;
    resultBuffer[resultBufferOffset + 3] = -a11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/subtract.ts
/**
* Subtract a 2 by 2 double buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2d_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a01 - b01;
    resultBuffer[resultBufferOffset + 3] = a11 - b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/scale.ts
/**
* Apply a 2 dimensional scale to a 2 by 2 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function scale_scale(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = x * b01;
    resultBuffer[resultBufferOffset + 3] = y * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/fill.ts
/**
* Fill a 2 by 2 double buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 2 by 2 double buffered matrix with a 2 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    return a00 * x + a10 * y;
}
/**
* Multiply 2 by 2 double buffered matrix with a 2 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y) {
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    return a01 * x + a11 * y;
}

// CONCATENATED MODULE: ./src/matrix2d/toTranslation.ts
/**
* Set the content of a 2 by 2 double buffered matrix to the content of a 1 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
*
* @return The buffer, updated with the content of a 1 dimensional translation matrix.
*/
function toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = x;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/transpose.ts
/**
* Transpose a 2 by 2 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a10;
    resultBuffer[resultBufferOffset + 3] = a11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/extractScale.ts
/**
* Extract a scale from a 2 by 2 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 2 dimensional scale vector extracted from the given matrix.
*/
function extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11) * ((a11 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2d/index.ts





























// CONCATENATED MODULE: ./src/matrix2i/set.ts
/**
* Set the content of a 2 by 2 integer buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix2i_set_set(buffer, bufferOffset, a00, a10, a01, a11) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a01;
    buffer[bufferOffset + 3] = a11;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix2i/multiplyWithVector.ts
/**
* Multiply 2 by 2 integer buffered matrix with a 2 integer buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/toScale.ts
/**
* Set the content of a 2 by 2 integer buffered matrix to the content of a 2 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
*
* @return The buffer, updated with the content of a 2 dimensional scale matrix.
*/
function matrix2i_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = y;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/toString.ts
/**
* Transform a 2 by 2 integer buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix2i_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 2 by 2 integer null';
    }
    else {
        return [
            `matrix 2 by 2 integer `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 3].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix2i/copy.ts
/**
* Copy the content of a 2 by 2 integer buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix2i_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a01 = sourceBuffer[sourceBufferOffset + 2];
    const a11 = sourceBuffer[sourceBufferOffset + 3];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a01;
    destinationBuffer[destinationBufferOffset + 3] = a11;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/translate.ts
/**
* Apply a 1 dimensional translation to a 2 by 2 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_translate_translate(matrixBuffer, matrixBufferOffset, x, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = x;
    const a01 = 0;
    const a11 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/add.ts
/**
* Add a 2 by 2 integer buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a01 + b01;
    resultBuffer[resultBufferOffset + 3] = a11 + b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 2 by 2 integer buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a01, a11, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b01 = leftBuffer[leftBufferOffset + 2];
    const b11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/rotate.ts
/**
* Apply a 2 dimensional rotation to a 2 by 2 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const a00 = cosx;
    const a10 = -sinx;
    const a01 = sinx;
    const a11 = cosx;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/multiplyWithMatrix.ts
/**
* Multiply 2 by 2 integer buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/determinant.ts
/**
* Compute and return the determinant of a 2 by 2 integer buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 2 by 2 integer buffered matrix.
*/
function matrix2i_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    return a00 * a11 - a10 * a01;
}

// CONCATENATED MODULE: ./src/matrix2i/toRotation.ts
/**
* Set the content of a 2 by 2 integer buffered matrix to a 2 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
*
* @return The buffer, updated with the content of a 2 dimensional rotation.
*/
function matrix2i_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    matrixBuffer[matrixBufferOffset + 0] = cosx;
    matrixBuffer[matrixBufferOffset + 1] = -sinx;
    matrixBuffer[matrixBufferOffset + 2] = sinx;
    matrixBuffer[matrixBufferOffset + 3] = cosx;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/extractTranslation.ts
/**
* Extract a translation from a 2 by 2 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix2i_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 1];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/divideWithScalar.ts
/**
* Divide a 2 by 2 integer buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a01 / scalar;
    resultBuffer[resultBufferOffset + 3] = a11 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/multiplyWithScalar.ts
/**
* Multiply a 2 by 2 integer buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a01 * scalar;
    resultBuffer[resultBufferOffset + 3] = a11 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 2 by 2 integer buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b01, b11, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a01 = rightBuffer[rightBufferOffset + 2];
    const a11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11;
    resultBuffer[resultBufferOffset + 2] = a01 * b00 + a11 * b01;
    resultBuffer[resultBufferOffset + 3] = a01 * b10 + a11 * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/extract2DRotation.ts
/**
* Extract a 2D rotation from a 2 by 2 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix2i_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix2i/toIdentity.ts
/**
* Set the content of a 2 by 2 integer buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix2i_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/equals.ts
/**
* Compare two 2 by 2 integer buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix2i_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix2i/negate.ts
/**
* Negate a 2 by 2 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a01;
    resultBuffer[resultBufferOffset + 3] = -a11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/subtract.ts
/**
* Subtract a 2 by 2 integer buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a01 = leftBuffer[leftBufferOffset + 2];
    const a11 = leftBuffer[leftBufferOffset + 3];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b01 = rightBuffer[rightBufferOffset + 2];
    const b11 = rightBuffer[rightBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a01 - b01;
    resultBuffer[resultBufferOffset + 3] = a11 - b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/scale.ts
/**
* Apply a 2 dimensional scale to a 2 by 2 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix2i_scale_scale(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b01 = matrixBuffer[matrixBufferOffset + 2];
    const b11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = x * b01;
    resultBuffer[resultBufferOffset + 3] = y * b11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/fill.ts
/**
* Fill a 2 by 2 integer buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix2i_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 2 by 2 integer buffered matrix with a 2 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix2i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    return a00 * x + a10 * y;
}
/**
* Multiply 2 by 2 integer buffered matrix with a 2 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix2i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y) {
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    return a01 * x + a11 * y;
}

// CONCATENATED MODULE: ./src/matrix2i/toTranslation.ts
/**
* Set the content of a 2 by 2 integer buffered matrix to the content of a 1 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
*
* @return The buffer, updated with the content of a 1 dimensional translation matrix.
*/
function matrix2i_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = x;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/transpose.ts
/**
* Transpose a 2 by 2 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix2i_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a10;
    resultBuffer[resultBufferOffset + 3] = a11;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/extractScale.ts
/**
* Extract a scale from a 2 by 2 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 2 dimensional scale vector extracted from the given matrix.
*/
function matrix2i_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a01 = matrixBuffer[matrixBufferOffset + 2];
    const a11 = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11) * ((a11 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix2i/index.ts




























// CONCATENATED MODULE: ./src/matrix3f/set.ts
/**
* Set the content of a 3 by 3 float buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a20 - Value of the cell at column 2 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
* @param a21 - Value of the cell at column 2 and row 1 of the matrix.
* @param a02 - Value of the cell at column 0 and row 2 of the matrix.
* @param a12 - Value of the cell at column 1 and row 2 of the matrix.
* @param a22 - Value of the cell at column 2 and row 2 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix3f_set_set(buffer, bufferOffset, a00, a10, a20, a01, a11, a21, a02, a12, a22) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a20;
    buffer[bufferOffset + 3] = a01;
    buffer[bufferOffset + 4] = a11;
    buffer[bufferOffset + 5] = a21;
    buffer[bufferOffset + 6] = a02;
    buffer[bufferOffset + 7] = a12;
    buffer[bufferOffset + 8] = a22;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix3f/multiplyWithVector.ts
/**
* Multiply 3 by 3 float buffered matrix with a 3 float buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    const b02 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 2] = a02 * b00 + a12 * b01 + a22 * b02;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/toScale.ts
/**
* Set the content of a 3 by 3 float buffered matrix to the content of a 3 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
*
* @return The buffer, updated with the content of a 3 dimensional scale matrix.
*/
function matrix3f_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y, z) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = y;
    matrixBuffer[matrixBufferOffset + 5] = 0;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = z;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/toString.ts
/**
* Transform a 3 by 3 float buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix3f_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 3 by 3 float null';
    }
    else {
        return [
            `matrix 3 by 3 float `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 3].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 4].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 5].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 6].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 7].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 8].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix3f/copy.ts
/**
* Copy the content of a 3 by 3 float buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix3f_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a20 = sourceBuffer[sourceBufferOffset + 2];
    const a01 = sourceBuffer[sourceBufferOffset + 3];
    const a11 = sourceBuffer[sourceBufferOffset + 4];
    const a21 = sourceBuffer[sourceBufferOffset + 5];
    const a02 = sourceBuffer[sourceBufferOffset + 6];
    const a12 = sourceBuffer[sourceBufferOffset + 7];
    const a22 = sourceBuffer[sourceBufferOffset + 8];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a20;
    destinationBuffer[destinationBufferOffset + 3] = a01;
    destinationBuffer[destinationBufferOffset + 4] = a11;
    destinationBuffer[destinationBufferOffset + 5] = a21;
    destinationBuffer[destinationBufferOffset + 6] = a02;
    destinationBuffer[destinationBufferOffset + 7] = a12;
    destinationBuffer[destinationBufferOffset + 8] = a22;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/translate.ts
/**
* Apply a 2 dimensional translation to a 3 by 3 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_translate_translate(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = 0;
    const a20 = x;
    const a01 = 0;
    const a11 = 1;
    const a21 = y;
    const a02 = 0;
    const a12 = 0;
    const a22 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/add.ts
/**
* Add a 3 by 3 float buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a20 + b20;
    resultBuffer[resultBufferOffset + 3] = a01 + b01;
    resultBuffer[resultBufferOffset + 4] = a11 + b11;
    resultBuffer[resultBufferOffset + 5] = a21 + b21;
    resultBuffer[resultBufferOffset + 6] = a02 + b02;
    resultBuffer[resultBufferOffset + 7] = a12 + b12;
    resultBuffer[resultBufferOffset + 8] = a22 + b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 3 by 3 float buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param a21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param a02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param a12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param a22 - Value of the cell of the column 2 and row 2 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a20, a01, a11, a21, a02, a12, a22, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b20 = leftBuffer[leftBufferOffset + 2];
    const b01 = leftBuffer[leftBufferOffset + 3];
    const b11 = leftBuffer[leftBufferOffset + 4];
    const b21 = leftBuffer[leftBufferOffset + 5];
    const b02 = leftBuffer[leftBufferOffset + 6];
    const b12 = leftBuffer[leftBufferOffset + 7];
    const b22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/rotate.ts
/**
* Apply a 3 dimensional rotation to a 3 by 3 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    const a00 = cosy * cosz;
    const a10 = cosy * -sinz;
    const a20 = siny;
    const a01 = (-sinx * -siny * cosz + cosx * sinz);
    const a11 = (-sinx * -siny * -sinz + cosx * cosz);
    const a21 = -sinx * cosy;
    const a02 = (cosx * -siny * cosz + sinx * sinz);
    const a12 = (cosx * -siny * -sinz + sinx * cosz);
    const a22 = cosx * cosy;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/multiplyWithMatrix.ts
/**
* Multiply 3 by 3 float buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/determinant.ts
/**
* Compute and return the determinant of a 3 by 3 float buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 3 by 3 float buffered matrix.
*/
function matrix3f_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    return a11 * a22 * a00 + a21 * a02 * a10 + a01 * a12 * a20 - a21 * a12 * a00 - a01 * a22 * a10 - a11 * a02 * a20;
}

// CONCATENATED MODULE: ./src/matrix3f/toRotation.ts
/**
* Set the content of a 3 by 3 float buffered matrix to a 3 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
*
* @return The buffer, updated with the content of a 3 dimensional rotation.
*/
function matrix3f_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y, z) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    matrixBuffer[matrixBufferOffset + 0] = cosy * cosz;
    matrixBuffer[matrixBufferOffset + 1] = cosy * -sinz;
    matrixBuffer[matrixBufferOffset + 2] = siny;
    matrixBuffer[matrixBufferOffset + 3] = (-sinx * -siny * cosz + cosx * sinz);
    matrixBuffer[matrixBufferOffset + 4] = (-sinx * -siny * -sinz + cosx * cosz);
    matrixBuffer[matrixBufferOffset + 5] = -sinx * cosy;
    matrixBuffer[matrixBufferOffset + 6] = (cosx * -siny * cosz + sinx * sinz);
    matrixBuffer[matrixBufferOffset + 7] = (cosx * -siny * -sinz + sinx * cosz);
    matrixBuffer[matrixBufferOffset + 8] = cosx * cosy;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/extractTranslation.ts
/**
* Extract a translation from a 3 by 3 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix3f_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 2];
    resultBuffer[resultBufferOffset + 1] = matrixBuffer[matrixBufferOffset + 5];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/divideWithScalar.ts
/**
* Divide a 3 by 3 float buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a20 / scalar;
    resultBuffer[resultBufferOffset + 3] = a01 / scalar;
    resultBuffer[resultBufferOffset + 4] = a11 / scalar;
    resultBuffer[resultBufferOffset + 5] = a21 / scalar;
    resultBuffer[resultBufferOffset + 6] = a02 / scalar;
    resultBuffer[resultBufferOffset + 7] = a12 / scalar;
    resultBuffer[resultBufferOffset + 8] = a22 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/invert.ts

/**
* Invert a 3 by 3 float buffered matrix and write the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function matrix3f_invert_invert(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    const determinantValue = matrix3f_determinant_determinant(matrixBuffer, matrixBufferOffset);
    resultBuffer[resultBufferOffset + 0] = (a11 * a22 - a21 * a12) / determinantValue;
    resultBuffer[resultBufferOffset + 1] = -(a10 * a22 - a20 * a12) / determinantValue;
    resultBuffer[resultBufferOffset + 2] = (a10 * a21 - a20 * a11) / determinantValue;
    resultBuffer[resultBufferOffset + 3] = -(a01 * a22 - a21 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 4] = (a00 * a22 - a20 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 5] = -(a00 * a21 - a20 * a01) / determinantValue;
    resultBuffer[resultBufferOffset + 6] = (a01 * a12 - a11 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 7] = -(a00 * a12 - a10 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 8] = (a00 * a11 - a10 * a01) / determinantValue;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/multiplyWithScalar.ts
/**
* Multiply a 3 by 3 float buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a20 * scalar;
    resultBuffer[resultBufferOffset + 3] = a01 * scalar;
    resultBuffer[resultBufferOffset + 4] = a11 * scalar;
    resultBuffer[resultBufferOffset + 5] = a21 * scalar;
    resultBuffer[resultBufferOffset + 6] = a02 * scalar;
    resultBuffer[resultBufferOffset + 7] = a12 * scalar;
    resultBuffer[resultBufferOffset + 8] = a22 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 3 by 3 float buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param b21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param b02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param b12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param b22 - Value of the cell of the column 2 and row 2 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b20, b01, b11, b21, b02, b12, b22, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a20 = rightBuffer[rightBufferOffset + 2];
    const a01 = rightBuffer[rightBufferOffset + 3];
    const a11 = rightBuffer[rightBufferOffset + 4];
    const a21 = rightBuffer[rightBufferOffset + 5];
    const a02 = rightBuffer[rightBufferOffset + 6];
    const a12 = rightBuffer[rightBufferOffset + 7];
    const a22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/extract2DRotation.ts
/**
* Extract a 2D rotation from a 3 by 3 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix3f_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix3f/toIdentity.ts
/**
* Set the content of a 3 by 3 float buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix3f_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 1;
    matrixBuffer[matrixBufferOffset + 5] = 0;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/equals.ts
/**
* Compare two 3 by 3 float buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix3f_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a20 - b20) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance &&
        Math.abs(a21 - b21) < tolerance &&
        Math.abs(a02 - b02) < tolerance &&
        Math.abs(a12 - b12) < tolerance &&
        Math.abs(a22 - b22) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix3f/negate.ts
/**
* Negate a 3 by 3 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a20;
    resultBuffer[resultBufferOffset + 3] = -a01;
    resultBuffer[resultBufferOffset + 4] = -a11;
    resultBuffer[resultBufferOffset + 5] = -a21;
    resultBuffer[resultBufferOffset + 6] = -a02;
    resultBuffer[resultBufferOffset + 7] = -a12;
    resultBuffer[resultBufferOffset + 8] = -a22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/subtract.ts
/**
* Subtract a 3 by 3 float buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a20 - b20;
    resultBuffer[resultBufferOffset + 3] = a01 - b01;
    resultBuffer[resultBufferOffset + 4] = a11 - b11;
    resultBuffer[resultBufferOffset + 5] = a21 - b21;
    resultBuffer[resultBufferOffset + 6] = a02 - b02;
    resultBuffer[resultBufferOffset + 7] = a12 - b12;
    resultBuffer[resultBufferOffset + 8] = a22 - b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/scale.ts
/**
* Apply a 3 dimensional scale to a 3 by 3 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3f_scale_scale(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = z * b20;
    resultBuffer[resultBufferOffset + 3] = x * b01;
    resultBuffer[resultBufferOffset + 4] = y * b11;
    resultBuffer[resultBufferOffset + 5] = z * b21;
    resultBuffer[resultBufferOffset + 6] = x * b02;
    resultBuffer[resultBufferOffset + 7] = y * b12;
    resultBuffer[resultBufferOffset + 8] = z * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/fill.ts
/**
* Fill a 3 by 3 float buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix3f_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    matrixBuffer[matrixBufferOffset + 4] = value;
    matrixBuffer[matrixBufferOffset + 5] = value;
    matrixBuffer[matrixBufferOffset + 6] = value;
    matrixBuffer[matrixBufferOffset + 7] = value;
    matrixBuffer[matrixBufferOffset + 8] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 3 by 3 float buffered matrix with a 3 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3f_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    return a00 * x + a10 * y + a20 * z;
}
/**
* Multiply 3 by 3 float buffered matrix with a 3 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3f_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    return a01 * x + a11 * y + a21 * z;
}
/**
* Multiply 3 by 3 float buffered matrix with a 3 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeZComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    return a02 * x + a12 * y + a22 * z;
}

// CONCATENATED MODULE: ./src/matrix3f/toTranslation.ts
/**
* Set the content of a 3 by 3 float buffered matrix to the content of a 2 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
*
* @return The buffer, updated with the content of a 2 dimensional translation matrix.
*/
function matrix3f_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x, y) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = x;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 1;
    matrixBuffer[matrixBufferOffset + 5] = y;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/transpose.ts
/**
* Transpose a 3 by 3 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix3f_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a02;
    resultBuffer[resultBufferOffset + 3] = a10;
    resultBuffer[resultBufferOffset + 4] = a11;
    resultBuffer[resultBufferOffset + 5] = a12;
    resultBuffer[resultBufferOffset + 6] = a20;
    resultBuffer[resultBufferOffset + 7] = a21;
    resultBuffer[resultBufferOffset + 8] = a22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/extractScale.ts
/**
* Extract a scale from a 3 by 3 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 3 dimensional scale vector extracted from the given matrix.
*/
function matrix3f_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10 + a20 * a20) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11 + a21 * a21) * ((a11 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 2] = Math.sqrt(a02 * a02 + a12 * a12 + a22 * a22) * ((a22 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3f/index.ts





























// CONCATENATED MODULE: ./src/matrix3d/set.ts
/**
* Set the content of a 3 by 3 double buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a20 - Value of the cell at column 2 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
* @param a21 - Value of the cell at column 2 and row 1 of the matrix.
* @param a02 - Value of the cell at column 0 and row 2 of the matrix.
* @param a12 - Value of the cell at column 1 and row 2 of the matrix.
* @param a22 - Value of the cell at column 2 and row 2 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix3d_set_set(buffer, bufferOffset, a00, a10, a20, a01, a11, a21, a02, a12, a22) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a20;
    buffer[bufferOffset + 3] = a01;
    buffer[bufferOffset + 4] = a11;
    buffer[bufferOffset + 5] = a21;
    buffer[bufferOffset + 6] = a02;
    buffer[bufferOffset + 7] = a12;
    buffer[bufferOffset + 8] = a22;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix3d/multiplyWithVector.ts
/**
* Multiply 3 by 3 double buffered matrix with a 3 double buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    const b02 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 2] = a02 * b00 + a12 * b01 + a22 * b02;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/toScale.ts
/**
* Set the content of a 3 by 3 double buffered matrix to the content of a 3 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
*
* @return The buffer, updated with the content of a 3 dimensional scale matrix.
*/
function matrix3d_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y, z) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = y;
    matrixBuffer[matrixBufferOffset + 5] = 0;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = z;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/toString.ts
/**
* Transform a 3 by 3 double buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix3d_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 3 by 3 double null';
    }
    else {
        return [
            `matrix 3 by 3 double `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 3].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 4].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 5].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 6].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 7].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 8].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix3d/copy.ts
/**
* Copy the content of a 3 by 3 double buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix3d_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a20 = sourceBuffer[sourceBufferOffset + 2];
    const a01 = sourceBuffer[sourceBufferOffset + 3];
    const a11 = sourceBuffer[sourceBufferOffset + 4];
    const a21 = sourceBuffer[sourceBufferOffset + 5];
    const a02 = sourceBuffer[sourceBufferOffset + 6];
    const a12 = sourceBuffer[sourceBufferOffset + 7];
    const a22 = sourceBuffer[sourceBufferOffset + 8];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a20;
    destinationBuffer[destinationBufferOffset + 3] = a01;
    destinationBuffer[destinationBufferOffset + 4] = a11;
    destinationBuffer[destinationBufferOffset + 5] = a21;
    destinationBuffer[destinationBufferOffset + 6] = a02;
    destinationBuffer[destinationBufferOffset + 7] = a12;
    destinationBuffer[destinationBufferOffset + 8] = a22;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/translate.ts
/**
* Apply a 2 dimensional translation to a 3 by 3 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_translate_translate(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = 0;
    const a20 = x;
    const a01 = 0;
    const a11 = 1;
    const a21 = y;
    const a02 = 0;
    const a12 = 0;
    const a22 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/add.ts
/**
* Add a 3 by 3 double buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a20 + b20;
    resultBuffer[resultBufferOffset + 3] = a01 + b01;
    resultBuffer[resultBufferOffset + 4] = a11 + b11;
    resultBuffer[resultBufferOffset + 5] = a21 + b21;
    resultBuffer[resultBufferOffset + 6] = a02 + b02;
    resultBuffer[resultBufferOffset + 7] = a12 + b12;
    resultBuffer[resultBufferOffset + 8] = a22 + b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 3 by 3 double buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param a21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param a02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param a12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param a22 - Value of the cell of the column 2 and row 2 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a20, a01, a11, a21, a02, a12, a22, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b20 = leftBuffer[leftBufferOffset + 2];
    const b01 = leftBuffer[leftBufferOffset + 3];
    const b11 = leftBuffer[leftBufferOffset + 4];
    const b21 = leftBuffer[leftBufferOffset + 5];
    const b02 = leftBuffer[leftBufferOffset + 6];
    const b12 = leftBuffer[leftBufferOffset + 7];
    const b22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/rotate.ts
/**
* Apply a 3 dimensional rotation to a 3 by 3 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    const a00 = cosy * cosz;
    const a10 = cosy * -sinz;
    const a20 = siny;
    const a01 = (-sinx * -siny * cosz + cosx * sinz);
    const a11 = (-sinx * -siny * -sinz + cosx * cosz);
    const a21 = -sinx * cosy;
    const a02 = (cosx * -siny * cosz + sinx * sinz);
    const a12 = (cosx * -siny * -sinz + sinx * cosz);
    const a22 = cosx * cosy;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/multiplyWithMatrix.ts
/**
* Multiply 3 by 3 double buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/determinant.ts
/**
* Compute and return the determinant of a 3 by 3 double buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 3 by 3 double buffered matrix.
*/
function matrix3d_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    return a11 * a22 * a00 + a21 * a02 * a10 + a01 * a12 * a20 - a21 * a12 * a00 - a01 * a22 * a10 - a11 * a02 * a20;
}

// CONCATENATED MODULE: ./src/matrix3d/toRotation.ts
/**
* Set the content of a 3 by 3 double buffered matrix to a 3 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
*
* @return The buffer, updated with the content of a 3 dimensional rotation.
*/
function matrix3d_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y, z) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    matrixBuffer[matrixBufferOffset + 0] = cosy * cosz;
    matrixBuffer[matrixBufferOffset + 1] = cosy * -sinz;
    matrixBuffer[matrixBufferOffset + 2] = siny;
    matrixBuffer[matrixBufferOffset + 3] = (-sinx * -siny * cosz + cosx * sinz);
    matrixBuffer[matrixBufferOffset + 4] = (-sinx * -siny * -sinz + cosx * cosz);
    matrixBuffer[matrixBufferOffset + 5] = -sinx * cosy;
    matrixBuffer[matrixBufferOffset + 6] = (cosx * -siny * cosz + sinx * sinz);
    matrixBuffer[matrixBufferOffset + 7] = (cosx * -siny * -sinz + sinx * cosz);
    matrixBuffer[matrixBufferOffset + 8] = cosx * cosy;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/extractTranslation.ts
/**
* Extract a translation from a 3 by 3 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix3d_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 2];
    resultBuffer[resultBufferOffset + 1] = matrixBuffer[matrixBufferOffset + 5];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/divideWithScalar.ts
/**
* Divide a 3 by 3 double buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a20 / scalar;
    resultBuffer[resultBufferOffset + 3] = a01 / scalar;
    resultBuffer[resultBufferOffset + 4] = a11 / scalar;
    resultBuffer[resultBufferOffset + 5] = a21 / scalar;
    resultBuffer[resultBufferOffset + 6] = a02 / scalar;
    resultBuffer[resultBufferOffset + 7] = a12 / scalar;
    resultBuffer[resultBufferOffset + 8] = a22 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/invert.ts

/**
* Invert a 3 by 3 double buffered matrix and write the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function matrix3d_invert_invert(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    const determinantValue = matrix3d_determinant_determinant(matrixBuffer, matrixBufferOffset);
    resultBuffer[resultBufferOffset + 0] = (a11 * a22 - a21 * a12) / determinantValue;
    resultBuffer[resultBufferOffset + 1] = -(a10 * a22 - a20 * a12) / determinantValue;
    resultBuffer[resultBufferOffset + 2] = (a10 * a21 - a20 * a11) / determinantValue;
    resultBuffer[resultBufferOffset + 3] = -(a01 * a22 - a21 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 4] = (a00 * a22 - a20 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 5] = -(a00 * a21 - a20 * a01) / determinantValue;
    resultBuffer[resultBufferOffset + 6] = (a01 * a12 - a11 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 7] = -(a00 * a12 - a10 * a02) / determinantValue;
    resultBuffer[resultBufferOffset + 8] = (a00 * a11 - a10 * a01) / determinantValue;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/multiplyWithScalar.ts
/**
* Multiply a 3 by 3 double buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a20 * scalar;
    resultBuffer[resultBufferOffset + 3] = a01 * scalar;
    resultBuffer[resultBufferOffset + 4] = a11 * scalar;
    resultBuffer[resultBufferOffset + 5] = a21 * scalar;
    resultBuffer[resultBufferOffset + 6] = a02 * scalar;
    resultBuffer[resultBufferOffset + 7] = a12 * scalar;
    resultBuffer[resultBufferOffset + 8] = a22 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 3 by 3 double buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param b21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param b02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param b12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param b22 - Value of the cell of the column 2 and row 2 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b20, b01, b11, b21, b02, b12, b22, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a20 = rightBuffer[rightBufferOffset + 2];
    const a01 = rightBuffer[rightBufferOffset + 3];
    const a11 = rightBuffer[rightBufferOffset + 4];
    const a21 = rightBuffer[rightBufferOffset + 5];
    const a02 = rightBuffer[rightBufferOffset + 6];
    const a12 = rightBuffer[rightBufferOffset + 7];
    const a22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/extract2DRotation.ts
/**
* Extract a 2D rotation from a 3 by 3 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix3d_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix3d/toIdentity.ts
/**
* Set the content of a 3 by 3 double buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix3d_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 1;
    matrixBuffer[matrixBufferOffset + 5] = 0;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/equals.ts
/**
* Compare two 3 by 3 double buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix3d_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a20 - b20) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance &&
        Math.abs(a21 - b21) < tolerance &&
        Math.abs(a02 - b02) < tolerance &&
        Math.abs(a12 - b12) < tolerance &&
        Math.abs(a22 - b22) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix3d/negate.ts
/**
* Negate a 3 by 3 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a20;
    resultBuffer[resultBufferOffset + 3] = -a01;
    resultBuffer[resultBufferOffset + 4] = -a11;
    resultBuffer[resultBufferOffset + 5] = -a21;
    resultBuffer[resultBufferOffset + 6] = -a02;
    resultBuffer[resultBufferOffset + 7] = -a12;
    resultBuffer[resultBufferOffset + 8] = -a22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/subtract.ts
/**
* Subtract a 3 by 3 double buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a20 - b20;
    resultBuffer[resultBufferOffset + 3] = a01 - b01;
    resultBuffer[resultBufferOffset + 4] = a11 - b11;
    resultBuffer[resultBufferOffset + 5] = a21 - b21;
    resultBuffer[resultBufferOffset + 6] = a02 - b02;
    resultBuffer[resultBufferOffset + 7] = a12 - b12;
    resultBuffer[resultBufferOffset + 8] = a22 - b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/scale.ts
/**
* Apply a 3 dimensional scale to a 3 by 3 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3d_scale_scale(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = z * b20;
    resultBuffer[resultBufferOffset + 3] = x * b01;
    resultBuffer[resultBufferOffset + 4] = y * b11;
    resultBuffer[resultBufferOffset + 5] = z * b21;
    resultBuffer[resultBufferOffset + 6] = x * b02;
    resultBuffer[resultBufferOffset + 7] = y * b12;
    resultBuffer[resultBufferOffset + 8] = z * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/fill.ts
/**
* Fill a 3 by 3 double buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix3d_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    matrixBuffer[matrixBufferOffset + 4] = value;
    matrixBuffer[matrixBufferOffset + 5] = value;
    matrixBuffer[matrixBufferOffset + 6] = value;
    matrixBuffer[matrixBufferOffset + 7] = value;
    matrixBuffer[matrixBufferOffset + 8] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 3 by 3 double buffered matrix with a 3 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3d_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    return a00 * x + a10 * y + a20 * z;
}
/**
* Multiply 3 by 3 double buffered matrix with a 3 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3d_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    return a01 * x + a11 * y + a21 * z;
}
/**
* Multiply 3 by 3 double buffered matrix with a 3 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    return a02 * x + a12 * y + a22 * z;
}

// CONCATENATED MODULE: ./src/matrix3d/toTranslation.ts
/**
* Set the content of a 3 by 3 double buffered matrix to the content of a 2 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
*
* @return The buffer, updated with the content of a 2 dimensional translation matrix.
*/
function matrix3d_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x, y) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = x;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 1;
    matrixBuffer[matrixBufferOffset + 5] = y;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/transpose.ts
/**
* Transpose a 3 by 3 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix3d_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a02;
    resultBuffer[resultBufferOffset + 3] = a10;
    resultBuffer[resultBufferOffset + 4] = a11;
    resultBuffer[resultBufferOffset + 5] = a12;
    resultBuffer[resultBufferOffset + 6] = a20;
    resultBuffer[resultBufferOffset + 7] = a21;
    resultBuffer[resultBufferOffset + 8] = a22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/extractScale.ts
/**
* Extract a scale from a 3 by 3 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 3 dimensional scale vector extracted from the given matrix.
*/
function matrix3d_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10 + a20 * a20) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11 + a21 * a21) * ((a11 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 2] = Math.sqrt(a02 * a02 + a12 * a12 + a22 * a22) * ((a22 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3d/index.ts





























// CONCATENATED MODULE: ./src/matrix3i/set.ts
/**
* Set the content of a 3 by 3 integer buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a20 - Value of the cell at column 2 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
* @param a21 - Value of the cell at column 2 and row 1 of the matrix.
* @param a02 - Value of the cell at column 0 and row 2 of the matrix.
* @param a12 - Value of the cell at column 1 and row 2 of the matrix.
* @param a22 - Value of the cell at column 2 and row 2 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix3i_set_set(buffer, bufferOffset, a00, a10, a20, a01, a11, a21, a02, a12, a22) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a20;
    buffer[bufferOffset + 3] = a01;
    buffer[bufferOffset + 4] = a11;
    buffer[bufferOffset + 5] = a21;
    buffer[bufferOffset + 6] = a02;
    buffer[bufferOffset + 7] = a12;
    buffer[bufferOffset + 8] = a22;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix3i/multiplyWithVector.ts
/**
* Multiply 3 by 3 integer buffered matrix with a 3 integer buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    const b02 = vectorBuffer[vectorBufferOffset + 2];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 2] = a02 * b00 + a12 * b01 + a22 * b02;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/toScale.ts
/**
* Set the content of a 3 by 3 integer buffered matrix to the content of a 3 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
*
* @return The buffer, updated with the content of a 3 dimensional scale matrix.
*/
function matrix3i_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y, z) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = y;
    matrixBuffer[matrixBufferOffset + 5] = 0;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = z;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/toString.ts
/**
* Transform a 3 by 3 integer buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix3i_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 3 by 3 integer null';
    }
    else {
        return [
            `matrix 3 by 3 integer `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 3].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 4].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 5].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 6].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 7].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 8].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix3i/copy.ts
/**
* Copy the content of a 3 by 3 integer buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix3i_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a20 = sourceBuffer[sourceBufferOffset + 2];
    const a01 = sourceBuffer[sourceBufferOffset + 3];
    const a11 = sourceBuffer[sourceBufferOffset + 4];
    const a21 = sourceBuffer[sourceBufferOffset + 5];
    const a02 = sourceBuffer[sourceBufferOffset + 6];
    const a12 = sourceBuffer[sourceBufferOffset + 7];
    const a22 = sourceBuffer[sourceBufferOffset + 8];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a20;
    destinationBuffer[destinationBufferOffset + 3] = a01;
    destinationBuffer[destinationBufferOffset + 4] = a11;
    destinationBuffer[destinationBufferOffset + 5] = a21;
    destinationBuffer[destinationBufferOffset + 6] = a02;
    destinationBuffer[destinationBufferOffset + 7] = a12;
    destinationBuffer[destinationBufferOffset + 8] = a22;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/translate.ts
/**
* Apply a 2 dimensional translation to a 3 by 3 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_translate_translate(matrixBuffer, matrixBufferOffset, x, y, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = 0;
    const a20 = x;
    const a01 = 0;
    const a11 = 1;
    const a21 = y;
    const a02 = 0;
    const a12 = 0;
    const a22 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/add.ts
/**
* Add a 3 by 3 integer buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a20 + b20;
    resultBuffer[resultBufferOffset + 3] = a01 + b01;
    resultBuffer[resultBufferOffset + 4] = a11 + b11;
    resultBuffer[resultBufferOffset + 5] = a21 + b21;
    resultBuffer[resultBufferOffset + 6] = a02 + b02;
    resultBuffer[resultBufferOffset + 7] = a12 + b12;
    resultBuffer[resultBufferOffset + 8] = a22 + b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 3 by 3 integer buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param a21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param a02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param a12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param a22 - Value of the cell of the column 2 and row 2 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a20, a01, a11, a21, a02, a12, a22, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b20 = leftBuffer[leftBufferOffset + 2];
    const b01 = leftBuffer[leftBufferOffset + 3];
    const b11 = leftBuffer[leftBufferOffset + 4];
    const b21 = leftBuffer[leftBufferOffset + 5];
    const b02 = leftBuffer[leftBufferOffset + 6];
    const b12 = leftBuffer[leftBufferOffset + 7];
    const b22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/rotate.ts
/**
* Apply a 3 dimensional rotation to a 3 by 3 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    const a00 = cosy * cosz;
    const a10 = cosy * -sinz;
    const a20 = siny;
    const a01 = (-sinx * -siny * cosz + cosx * sinz);
    const a11 = (-sinx * -siny * -sinz + cosx * cosz);
    const a21 = -sinx * cosy;
    const a02 = (cosx * -siny * cosz + sinx * sinz);
    const a12 = (cosx * -siny * -sinz + sinx * cosz);
    const a22 = cosx * cosy;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/multiplyWithMatrix.ts
/**
* Multiply 3 by 3 integer buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/determinant.ts
/**
* Compute and return the determinant of a 3 by 3 integer buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 3 by 3 integer buffered matrix.
*/
function matrix3i_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    return a11 * a22 * a00 + a21 * a02 * a10 + a01 * a12 * a20 - a21 * a12 * a00 - a01 * a22 * a10 - a11 * a02 * a20;
}

// CONCATENATED MODULE: ./src/matrix3i/toRotation.ts
/**
* Set the content of a 3 by 3 integer buffered matrix to a 3 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
*
* @return The buffer, updated with the content of a 3 dimensional rotation.
*/
function matrix3i_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y, z) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    matrixBuffer[matrixBufferOffset + 0] = cosy * cosz;
    matrixBuffer[matrixBufferOffset + 1] = cosy * -sinz;
    matrixBuffer[matrixBufferOffset + 2] = siny;
    matrixBuffer[matrixBufferOffset + 3] = (-sinx * -siny * cosz + cosx * sinz);
    matrixBuffer[matrixBufferOffset + 4] = (-sinx * -siny * -sinz + cosx * cosz);
    matrixBuffer[matrixBufferOffset + 5] = -sinx * cosy;
    matrixBuffer[matrixBufferOffset + 6] = (cosx * -siny * cosz + sinx * sinz);
    matrixBuffer[matrixBufferOffset + 7] = (cosx * -siny * -sinz + sinx * cosz);
    matrixBuffer[matrixBufferOffset + 8] = cosx * cosy;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/extractTranslation.ts
/**
* Extract a translation from a 3 by 3 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix3i_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 2];
    resultBuffer[resultBufferOffset + 1] = matrixBuffer[matrixBufferOffset + 5];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/divideWithScalar.ts
/**
* Divide a 3 by 3 integer buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a20 / scalar;
    resultBuffer[resultBufferOffset + 3] = a01 / scalar;
    resultBuffer[resultBufferOffset + 4] = a11 / scalar;
    resultBuffer[resultBufferOffset + 5] = a21 / scalar;
    resultBuffer[resultBufferOffset + 6] = a02 / scalar;
    resultBuffer[resultBufferOffset + 7] = a12 / scalar;
    resultBuffer[resultBufferOffset + 8] = a22 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/multiplyWithScalar.ts
/**
* Multiply a 3 by 3 integer buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a20 * scalar;
    resultBuffer[resultBufferOffset + 3] = a01 * scalar;
    resultBuffer[resultBufferOffset + 4] = a11 * scalar;
    resultBuffer[resultBufferOffset + 5] = a21 * scalar;
    resultBuffer[resultBufferOffset + 6] = a02 * scalar;
    resultBuffer[resultBufferOffset + 7] = a12 * scalar;
    resultBuffer[resultBufferOffset + 8] = a22 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 3 by 3 integer buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param b21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param b02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param b12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param b22 - Value of the cell of the column 2 and row 2 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b20, b01, b11, b21, b02, b12, b22, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a20 = rightBuffer[rightBufferOffset + 2];
    const a01 = rightBuffer[rightBufferOffset + 3];
    const a11 = rightBuffer[rightBufferOffset + 4];
    const a21 = rightBuffer[rightBufferOffset + 5];
    const a02 = rightBuffer[rightBufferOffset + 6];
    const a12 = rightBuffer[rightBufferOffset + 7];
    const a22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22;
    resultBuffer[resultBufferOffset + 3] = a01 * b00 + a11 * b01 + a21 * b02;
    resultBuffer[resultBufferOffset + 4] = a01 * b10 + a11 * b11 + a21 * b12;
    resultBuffer[resultBufferOffset + 5] = a01 * b20 + a11 * b21 + a21 * b22;
    resultBuffer[resultBufferOffset + 6] = a02 * b00 + a12 * b01 + a22 * b02;
    resultBuffer[resultBufferOffset + 7] = a02 * b10 + a12 * b11 + a22 * b12;
    resultBuffer[resultBufferOffset + 8] = a02 * b20 + a12 * b21 + a22 * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/extract2DRotation.ts
/**
* Extract a 2D rotation from a 3 by 3 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix3i_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix3i/toIdentity.ts
/**
* Set the content of a 3 by 3 integer buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix3i_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 1;
    matrixBuffer[matrixBufferOffset + 5] = 0;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/equals.ts
/**
* Compare two 3 by 3 integer buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix3i_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a20 - b20) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance &&
        Math.abs(a21 - b21) < tolerance &&
        Math.abs(a02 - b02) < tolerance &&
        Math.abs(a12 - b12) < tolerance &&
        Math.abs(a22 - b22) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix3i/negate.ts
/**
* Negate a 3 by 3 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a20;
    resultBuffer[resultBufferOffset + 3] = -a01;
    resultBuffer[resultBufferOffset + 4] = -a11;
    resultBuffer[resultBufferOffset + 5] = -a21;
    resultBuffer[resultBufferOffset + 6] = -a02;
    resultBuffer[resultBufferOffset + 7] = -a12;
    resultBuffer[resultBufferOffset + 8] = -a22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/subtract.ts
/**
* Subtract a 3 by 3 integer buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a01 = leftBuffer[leftBufferOffset + 3];
    const a11 = leftBuffer[leftBufferOffset + 4];
    const a21 = leftBuffer[leftBufferOffset + 5];
    const a02 = leftBuffer[leftBufferOffset + 6];
    const a12 = leftBuffer[leftBufferOffset + 7];
    const a22 = leftBuffer[leftBufferOffset + 8];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b01 = rightBuffer[rightBufferOffset + 3];
    const b11 = rightBuffer[rightBufferOffset + 4];
    const b21 = rightBuffer[rightBufferOffset + 5];
    const b02 = rightBuffer[rightBufferOffset + 6];
    const b12 = rightBuffer[rightBufferOffset + 7];
    const b22 = rightBuffer[rightBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a20 - b20;
    resultBuffer[resultBufferOffset + 3] = a01 - b01;
    resultBuffer[resultBufferOffset + 4] = a11 - b11;
    resultBuffer[resultBufferOffset + 5] = a21 - b21;
    resultBuffer[resultBufferOffset + 6] = a02 - b02;
    resultBuffer[resultBufferOffset + 7] = a12 - b12;
    resultBuffer[resultBufferOffset + 8] = a22 - b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/scale.ts
/**
* Apply a 3 dimensional scale to a 3 by 3 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix3i_scale_scale(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b01 = matrixBuffer[matrixBufferOffset + 3];
    const b11 = matrixBuffer[matrixBufferOffset + 4];
    const b21 = matrixBuffer[matrixBufferOffset + 5];
    const b02 = matrixBuffer[matrixBufferOffset + 6];
    const b12 = matrixBuffer[matrixBufferOffset + 7];
    const b22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = z * b20;
    resultBuffer[resultBufferOffset + 3] = x * b01;
    resultBuffer[resultBufferOffset + 4] = y * b11;
    resultBuffer[resultBufferOffset + 5] = z * b21;
    resultBuffer[resultBufferOffset + 6] = x * b02;
    resultBuffer[resultBufferOffset + 7] = y * b12;
    resultBuffer[resultBufferOffset + 8] = z * b22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/fill.ts
/**
* Fill a 3 by 3 integer buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix3i_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    matrixBuffer[matrixBufferOffset + 4] = value;
    matrixBuffer[matrixBufferOffset + 5] = value;
    matrixBuffer[matrixBufferOffset + 6] = value;
    matrixBuffer[matrixBufferOffset + 7] = value;
    matrixBuffer[matrixBufferOffset + 8] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 3 by 3 integer buffered matrix with a 3 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    return a00 * x + a10 * y + a20 * z;
}
/**
* Multiply 3 by 3 integer buffered matrix with a 3 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    return a01 * x + a11 * y + a21 * z;
}
/**
* Multiply 3 by 3 integer buffered matrix with a 3 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix3i_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z) {
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    return a02 * x + a12 * y + a22 * z;
}

// CONCATENATED MODULE: ./src/matrix3i/toTranslation.ts
/**
* Set the content of a 3 by 3 integer buffered matrix to the content of a 2 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
*
* @return The buffer, updated with the content of a 2 dimensional translation matrix.
*/
function matrix3i_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x, y) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = x;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 1;
    matrixBuffer[matrixBufferOffset + 5] = y;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/transpose.ts
/**
* Transpose a 3 by 3 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix3i_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a02;
    resultBuffer[resultBufferOffset + 3] = a10;
    resultBuffer[resultBufferOffset + 4] = a11;
    resultBuffer[resultBufferOffset + 5] = a12;
    resultBuffer[resultBufferOffset + 6] = a20;
    resultBuffer[resultBufferOffset + 7] = a21;
    resultBuffer[resultBufferOffset + 8] = a22;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/extractScale.ts
/**
* Extract a scale from a 3 by 3 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 3 dimensional scale vector extracted from the given matrix.
*/
function matrix3i_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a01 = matrixBuffer[matrixBufferOffset + 3];
    const a11 = matrixBuffer[matrixBufferOffset + 4];
    const a21 = matrixBuffer[matrixBufferOffset + 5];
    const a02 = matrixBuffer[matrixBufferOffset + 6];
    const a12 = matrixBuffer[matrixBufferOffset + 7];
    const a22 = matrixBuffer[matrixBufferOffset + 8];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10 + a20 * a20) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11 + a21 * a21) * ((a11 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 2] = Math.sqrt(a02 * a02 + a12 * a12 + a22 * a22) * ((a22 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix3i/index.ts




























// CONCATENATED MODULE: ./src/matrix4f/set.ts
/**
* Set the content of a 4 by 4 float buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a20 - Value of the cell at column 2 and row 0 of the matrix.
* @param a30 - Value of the cell at column 3 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
* @param a21 - Value of the cell at column 2 and row 1 of the matrix.
* @param a31 - Value of the cell at column 3 and row 1 of the matrix.
* @param a02 - Value of the cell at column 0 and row 2 of the matrix.
* @param a12 - Value of the cell at column 1 and row 2 of the matrix.
* @param a22 - Value of the cell at column 2 and row 2 of the matrix.
* @param a32 - Value of the cell at column 3 and row 2 of the matrix.
* @param a03 - Value of the cell at column 0 and row 3 of the matrix.
* @param a13 - Value of the cell at column 1 and row 3 of the matrix.
* @param a23 - Value of the cell at column 2 and row 3 of the matrix.
* @param a33 - Value of the cell at column 3 and row 3 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix4f_set_set(buffer, bufferOffset, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a20;
    buffer[bufferOffset + 3] = a30;
    buffer[bufferOffset + 4] = a01;
    buffer[bufferOffset + 5] = a11;
    buffer[bufferOffset + 6] = a21;
    buffer[bufferOffset + 7] = a31;
    buffer[bufferOffset + 8] = a02;
    buffer[bufferOffset + 9] = a12;
    buffer[bufferOffset + 10] = a22;
    buffer[bufferOffset + 11] = a32;
    buffer[bufferOffset + 12] = a03;
    buffer[bufferOffset + 13] = a13;
    buffer[bufferOffset + 14] = a23;
    buffer[bufferOffset + 15] = a33;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix4f/multiplyWithVector.ts
/**
* Multiply 4 by 4 float buffered matrix with a 4 float buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    const b02 = vectorBuffer[vectorBufferOffset + 2];
    const b03 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/toScale.ts
/**
* Set the content of a 4 by 4 float buffered matrix to the content of a 4 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param w - Scale factor of the w axis.
*
* @return The buffer, updated with the content of a 4 dimensional scale matrix.
*/
function matrix4f_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = y;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = z;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = w;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/toString.ts
/**
* Transform a 4 by 4 float buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix4f_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 4 by 4 float null';
    }
    else {
        return [
            `matrix 4 by 4 float `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 3].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 4].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 5].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 6].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 7].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 8].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 9].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 10].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 11].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 12].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 13].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 14].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 15].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix4f/copy.ts
/**
* Copy the content of a 4 by 4 float buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix4f_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a20 = sourceBuffer[sourceBufferOffset + 2];
    const a30 = sourceBuffer[sourceBufferOffset + 3];
    const a01 = sourceBuffer[sourceBufferOffset + 4];
    const a11 = sourceBuffer[sourceBufferOffset + 5];
    const a21 = sourceBuffer[sourceBufferOffset + 6];
    const a31 = sourceBuffer[sourceBufferOffset + 7];
    const a02 = sourceBuffer[sourceBufferOffset + 8];
    const a12 = sourceBuffer[sourceBufferOffset + 9];
    const a22 = sourceBuffer[sourceBufferOffset + 10];
    const a32 = sourceBuffer[sourceBufferOffset + 11];
    const a03 = sourceBuffer[sourceBufferOffset + 12];
    const a13 = sourceBuffer[sourceBufferOffset + 13];
    const a23 = sourceBuffer[sourceBufferOffset + 14];
    const a33 = sourceBuffer[sourceBufferOffset + 15];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a20;
    destinationBuffer[destinationBufferOffset + 3] = a30;
    destinationBuffer[destinationBufferOffset + 4] = a01;
    destinationBuffer[destinationBufferOffset + 5] = a11;
    destinationBuffer[destinationBufferOffset + 6] = a21;
    destinationBuffer[destinationBufferOffset + 7] = a31;
    destinationBuffer[destinationBufferOffset + 8] = a02;
    destinationBuffer[destinationBufferOffset + 9] = a12;
    destinationBuffer[destinationBufferOffset + 10] = a22;
    destinationBuffer[destinationBufferOffset + 11] = a32;
    destinationBuffer[destinationBufferOffset + 12] = a03;
    destinationBuffer[destinationBufferOffset + 13] = a13;
    destinationBuffer[destinationBufferOffset + 14] = a23;
    destinationBuffer[destinationBufferOffset + 15] = a33;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/translate.ts
/**
* Apply a 3 dimensional translation to a 4 by 4 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param z - Translation to apply to the z axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_translate_translate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = 0;
    const a20 = 0;
    const a30 = x;
    const a01 = 0;
    const a11 = 1;
    const a21 = 0;
    const a31 = y;
    const a02 = 0;
    const a12 = 0;
    const a22 = 1;
    const a32 = z;
    const a03 = 0;
    const a13 = 0;
    const a23 = 0;
    const a33 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/add.ts
/**
* Add a 4 by 4 float buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a20 + b20;
    resultBuffer[resultBufferOffset + 3] = a30 + b30;
    resultBuffer[resultBufferOffset + 4] = a01 + b01;
    resultBuffer[resultBufferOffset + 5] = a11 + b11;
    resultBuffer[resultBufferOffset + 6] = a21 + b21;
    resultBuffer[resultBufferOffset + 7] = a31 + b31;
    resultBuffer[resultBufferOffset + 8] = a02 + b02;
    resultBuffer[resultBufferOffset + 9] = a12 + b12;
    resultBuffer[resultBufferOffset + 10] = a22 + b22;
    resultBuffer[resultBufferOffset + 11] = a32 + b32;
    resultBuffer[resultBufferOffset + 12] = a03 + b03;
    resultBuffer[resultBufferOffset + 13] = a13 + b13;
    resultBuffer[resultBufferOffset + 14] = a23 + b23;
    resultBuffer[resultBufferOffset + 15] = a33 + b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 4 by 4 float buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param a30 - Value of the cell of the column 3 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param a21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param a31 - Value of the cell of the column 3 and row 1 of the static matrix.
* @param a02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param a12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param a22 - Value of the cell of the column 2 and row 2 of the static matrix.
* @param a32 - Value of the cell of the column 3 and row 2 of the static matrix.
* @param a03 - Value of the cell of the column 0 and row 3 of the static matrix.
* @param a13 - Value of the cell of the column 1 and row 3 of the static matrix.
* @param a23 - Value of the cell of the column 2 and row 3 of the static matrix.
* @param a33 - Value of the cell of the column 3 and row 3 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b20 = leftBuffer[leftBufferOffset + 2];
    const b30 = leftBuffer[leftBufferOffset + 3];
    const b01 = leftBuffer[leftBufferOffset + 4];
    const b11 = leftBuffer[leftBufferOffset + 5];
    const b21 = leftBuffer[leftBufferOffset + 6];
    const b31 = leftBuffer[leftBufferOffset + 7];
    const b02 = leftBuffer[leftBufferOffset + 8];
    const b12 = leftBuffer[leftBufferOffset + 9];
    const b22 = leftBuffer[leftBufferOffset + 10];
    const b32 = leftBuffer[leftBufferOffset + 11];
    const b03 = leftBuffer[leftBufferOffset + 12];
    const b13 = leftBuffer[leftBufferOffset + 13];
    const b23 = leftBuffer[leftBufferOffset + 14];
    const b33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/rotate.ts
/**
* Apply a 3 dimensional rotation to a 4 by 4 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    const a00 = cosy * cosz;
    const a10 = cosy * -sinz;
    const a20 = siny;
    const a30 = 0;
    const a01 = (-sinx * -siny * cosz + cosx * sinz);
    const a11 = (-sinx * -siny * -sinz + cosx * cosz);
    const a21 = -sinx * cosy;
    const a31 = 0;
    const a02 = (cosx * -siny * cosz + sinx * sinz);
    const a12 = (cosx * -siny * -sinz + sinx * cosz);
    const a22 = cosx * cosy;
    const a32 = 0;
    const a03 = 0;
    const a13 = 0;
    const a23 = 0;
    const a33 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/multiplyWithMatrix.ts
/**
* Multiply 4 by 4 float buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/determinant.ts
/**
* Compute and return the determinant of a 4 by 4 float buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 4 by 4 float buffered matrix.
*/
function matrix4f_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    return a22 * a33 * a11 * a00 + a32 * a13 * a21 * a00 + a12 * a23 * a31 * a00 + a32 * a23 * a01 * a10 + a02 * a33 * a21 * a10 + a22 * a03 * a31 * a10 + a12 * a33 * a01 * a20 + a32 * a03 * a11 * a20 + a02 * a13 * a31 * a20 + a22 * a13 * a01 * a30 + a02 * a23 * a11 * a30 + a12 * a03 * a21 * a30 - a32 * a23 * a11 * a00 - a12 * a33 * a21 * a00 - a22 * a13 * a31 * a00 - a22 * a33 * a01 * a10 - a32 * a03 * a21 * a10 - a02 * a23 * a31 * a10 - a32 * a13 * a01 * a20 - a02 * a33 * a11 * a20 - a12 * a03 * a31 * a20 - a12 * a23 * a01 * a30 - a22 * a03 * a11 * a30 - a02 * a13 * a21 * a30;
}

// CONCATENATED MODULE: ./src/matrix4f/toRotation.ts
/**
* Set the content of a 4 by 4 float buffered matrix to a 3 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
*
* @return The buffer, updated with the content of a 3 dimensional rotation.
*/
function matrix4f_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y, z) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    matrixBuffer[matrixBufferOffset + 0] = cosy * cosz;
    matrixBuffer[matrixBufferOffset + 1] = cosy * -sinz;
    matrixBuffer[matrixBufferOffset + 2] = siny;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = (-sinx * -siny * cosz + cosx * sinz);
    matrixBuffer[matrixBufferOffset + 5] = (-sinx * -siny * -sinz + cosx * cosz);
    matrixBuffer[matrixBufferOffset + 6] = -sinx * cosy;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = (cosx * -siny * cosz + sinx * sinz);
    matrixBuffer[matrixBufferOffset + 9] = (cosx * -siny * -sinz + sinx * cosz);
    matrixBuffer[matrixBufferOffset + 10] = cosx * cosy;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/extractTranslation.ts
/**
* Extract a translation from a 4 by 4 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix4f_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 1] = matrixBuffer[matrixBufferOffset + 7];
    resultBuffer[resultBufferOffset + 2] = matrixBuffer[matrixBufferOffset + 11];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/divideWithScalar.ts
/**
* Divide a 4 by 4 float buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a20 / scalar;
    resultBuffer[resultBufferOffset + 3] = a30 / scalar;
    resultBuffer[resultBufferOffset + 4] = a01 / scalar;
    resultBuffer[resultBufferOffset + 5] = a11 / scalar;
    resultBuffer[resultBufferOffset + 6] = a21 / scalar;
    resultBuffer[resultBufferOffset + 7] = a31 / scalar;
    resultBuffer[resultBufferOffset + 8] = a02 / scalar;
    resultBuffer[resultBufferOffset + 9] = a12 / scalar;
    resultBuffer[resultBufferOffset + 10] = a22 / scalar;
    resultBuffer[resultBufferOffset + 11] = a32 / scalar;
    resultBuffer[resultBufferOffset + 12] = a03 / scalar;
    resultBuffer[resultBufferOffset + 13] = a13 / scalar;
    resultBuffer[resultBufferOffset + 14] = a23 / scalar;
    resultBuffer[resultBufferOffset + 15] = a33 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/invert.ts

/**
* Invert a 4 by 4 float buffered matrix and write the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function matrix4f_invert_invert(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    const determinantValue = matrix4f_determinant_determinant(matrixBuffer, matrixBufferOffset);
    resultBuffer[resultBufferOffset + 0] = (a22 * a33 * a11 + a32 * a13 * a21 + a12 * a23 * a31 - a32 * a23 * a11 - a12 * a33 * a21 - a22 * a13 * a31) / determinantValue;
    resultBuffer[resultBufferOffset + 1] = -(a22 * a33 * a10 + a32 * a13 * a20 + a12 * a23 * a30 - a32 * a23 * a10 - a12 * a33 * a20 - a22 * a13 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 2] = (a21 * a33 * a10 + a31 * a13 * a20 + a11 * a23 * a30 - a31 * a23 * a10 - a11 * a33 * a20 - a21 * a13 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 3] = -(a21 * a32 * a10 + a31 * a12 * a20 + a11 * a22 * a30 - a31 * a22 * a10 - a11 * a32 * a20 - a21 * a12 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 4] = -(a22 * a33 * a01 + a32 * a03 * a21 + a02 * a23 * a31 - a32 * a23 * a01 - a02 * a33 * a21 - a22 * a03 * a31) / determinantValue;
    resultBuffer[resultBufferOffset + 5] = (a22 * a33 * a00 + a32 * a03 * a20 + a02 * a23 * a30 - a32 * a23 * a00 - a02 * a33 * a20 - a22 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 6] = -(a21 * a33 * a00 + a31 * a03 * a20 + a01 * a23 * a30 - a31 * a23 * a00 - a01 * a33 * a20 - a21 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 7] = (a21 * a32 * a00 + a31 * a02 * a20 + a01 * a22 * a30 - a31 * a22 * a00 - a01 * a32 * a20 - a21 * a02 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 8] = (a12 * a33 * a01 + a32 * a03 * a11 + a02 * a13 * a31 - a32 * a13 * a01 - a02 * a33 * a11 - a12 * a03 * a31) / determinantValue;
    resultBuffer[resultBufferOffset + 9] = -(a12 * a33 * a00 + a32 * a03 * a10 + a02 * a13 * a30 - a32 * a13 * a00 - a02 * a33 * a10 - a12 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 10] = (a11 * a33 * a00 + a31 * a03 * a10 + a01 * a13 * a30 - a31 * a13 * a00 - a01 * a33 * a10 - a11 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 11] = -(a11 * a32 * a00 + a31 * a02 * a10 + a01 * a12 * a30 - a31 * a12 * a00 - a01 * a32 * a10 - a11 * a02 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 12] = -(a12 * a23 * a01 + a22 * a03 * a11 + a02 * a13 * a21 - a22 * a13 * a01 - a02 * a23 * a11 - a12 * a03 * a21) / determinantValue;
    resultBuffer[resultBufferOffset + 13] = (a12 * a23 * a00 + a22 * a03 * a10 + a02 * a13 * a20 - a22 * a13 * a00 - a02 * a23 * a10 - a12 * a03 * a20) / determinantValue;
    resultBuffer[resultBufferOffset + 14] = -(a11 * a23 * a00 + a21 * a03 * a10 + a01 * a13 * a20 - a21 * a13 * a00 - a01 * a23 * a10 - a11 * a03 * a20) / determinantValue;
    resultBuffer[resultBufferOffset + 15] = (a11 * a22 * a00 + a21 * a02 * a10 + a01 * a12 * a20 - a21 * a12 * a00 - a01 * a22 * a10 - a11 * a02 * a20) / determinantValue;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/multiplyWithScalar.ts
/**
* Multiply a 4 by 4 float buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a20 * scalar;
    resultBuffer[resultBufferOffset + 3] = a30 * scalar;
    resultBuffer[resultBufferOffset + 4] = a01 * scalar;
    resultBuffer[resultBufferOffset + 5] = a11 * scalar;
    resultBuffer[resultBufferOffset + 6] = a21 * scalar;
    resultBuffer[resultBufferOffset + 7] = a31 * scalar;
    resultBuffer[resultBufferOffset + 8] = a02 * scalar;
    resultBuffer[resultBufferOffset + 9] = a12 * scalar;
    resultBuffer[resultBufferOffset + 10] = a22 * scalar;
    resultBuffer[resultBufferOffset + 11] = a32 * scalar;
    resultBuffer[resultBufferOffset + 12] = a03 * scalar;
    resultBuffer[resultBufferOffset + 13] = a13 * scalar;
    resultBuffer[resultBufferOffset + 14] = a23 * scalar;
    resultBuffer[resultBufferOffset + 15] = a33 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 4 by 4 float buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param b30 - Value of the cell of the column 3 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param b21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param b31 - Value of the cell of the column 3 and row 1 of the static matrix.
* @param b02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param b12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param b22 - Value of the cell of the column 2 and row 2 of the static matrix.
* @param b32 - Value of the cell of the column 3 and row 2 of the static matrix.
* @param b03 - Value of the cell of the column 0 and row 3 of the static matrix.
* @param b13 - Value of the cell of the column 1 and row 3 of the static matrix.
* @param b23 - Value of the cell of the column 2 and row 3 of the static matrix.
* @param b33 - Value of the cell of the column 3 and row 3 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b20, b30, b01, b11, b21, b31, b02, b12, b22, b32, b03, b13, b23, b33, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a20 = rightBuffer[rightBufferOffset + 2];
    const a30 = rightBuffer[rightBufferOffset + 3];
    const a01 = rightBuffer[rightBufferOffset + 4];
    const a11 = rightBuffer[rightBufferOffset + 5];
    const a21 = rightBuffer[rightBufferOffset + 6];
    const a31 = rightBuffer[rightBufferOffset + 7];
    const a02 = rightBuffer[rightBufferOffset + 8];
    const a12 = rightBuffer[rightBufferOffset + 9];
    const a22 = rightBuffer[rightBufferOffset + 10];
    const a32 = rightBuffer[rightBufferOffset + 11];
    const a03 = rightBuffer[rightBufferOffset + 12];
    const a13 = rightBuffer[rightBufferOffset + 13];
    const a23 = rightBuffer[rightBufferOffset + 14];
    const a33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/extract2DRotation.ts
/**
* Extract a 2D rotation from a 4 by 4 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix4f_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix4f/toIdentity.ts
/**
* Set the content of a 4 by 4 float buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix4f_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = 1;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = 1;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/equals.ts
/**
* Compare two 4 by 4 float buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix4f_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a20 - b20) < tolerance &&
        Math.abs(a30 - b30) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance &&
        Math.abs(a21 - b21) < tolerance &&
        Math.abs(a31 - b31) < tolerance &&
        Math.abs(a02 - b02) < tolerance &&
        Math.abs(a12 - b12) < tolerance &&
        Math.abs(a22 - b22) < tolerance &&
        Math.abs(a32 - b32) < tolerance &&
        Math.abs(a03 - b03) < tolerance &&
        Math.abs(a13 - b13) < tolerance &&
        Math.abs(a23 - b23) < tolerance &&
        Math.abs(a33 - b33) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix4f/negate.ts
/**
* Negate a 4 by 4 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a20;
    resultBuffer[resultBufferOffset + 3] = -a30;
    resultBuffer[resultBufferOffset + 4] = -a01;
    resultBuffer[resultBufferOffset + 5] = -a11;
    resultBuffer[resultBufferOffset + 6] = -a21;
    resultBuffer[resultBufferOffset + 7] = -a31;
    resultBuffer[resultBufferOffset + 8] = -a02;
    resultBuffer[resultBufferOffset + 9] = -a12;
    resultBuffer[resultBufferOffset + 10] = -a22;
    resultBuffer[resultBufferOffset + 11] = -a32;
    resultBuffer[resultBufferOffset + 12] = -a03;
    resultBuffer[resultBufferOffset + 13] = -a13;
    resultBuffer[resultBufferOffset + 14] = -a23;
    resultBuffer[resultBufferOffset + 15] = -a33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/subtract.ts
/**
* Subtract a 4 by 4 float buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a20 - b20;
    resultBuffer[resultBufferOffset + 3] = a30 - b30;
    resultBuffer[resultBufferOffset + 4] = a01 - b01;
    resultBuffer[resultBufferOffset + 5] = a11 - b11;
    resultBuffer[resultBufferOffset + 6] = a21 - b21;
    resultBuffer[resultBufferOffset + 7] = a31 - b31;
    resultBuffer[resultBufferOffset + 8] = a02 - b02;
    resultBuffer[resultBufferOffset + 9] = a12 - b12;
    resultBuffer[resultBufferOffset + 10] = a22 - b22;
    resultBuffer[resultBufferOffset + 11] = a32 - b32;
    resultBuffer[resultBufferOffset + 12] = a03 - b03;
    resultBuffer[resultBufferOffset + 13] = a13 - b13;
    resultBuffer[resultBufferOffset + 14] = a23 - b23;
    resultBuffer[resultBufferOffset + 15] = a33 - b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/scale.ts
/**
* Apply a 4 dimensional scale to a 4 by 4 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param w - Scale factor of the w axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4f_scale_scale(matrixBuffer, matrixBufferOffset, x, y, z, w, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = z * b20;
    resultBuffer[resultBufferOffset + 3] = w * b30;
    resultBuffer[resultBufferOffset + 4] = x * b01;
    resultBuffer[resultBufferOffset + 5] = y * b11;
    resultBuffer[resultBufferOffset + 6] = z * b21;
    resultBuffer[resultBufferOffset + 7] = w * b31;
    resultBuffer[resultBufferOffset + 8] = x * b02;
    resultBuffer[resultBufferOffset + 9] = y * b12;
    resultBuffer[resultBufferOffset + 10] = z * b22;
    resultBuffer[resultBufferOffset + 11] = w * b32;
    resultBuffer[resultBufferOffset + 12] = x * b03;
    resultBuffer[resultBufferOffset + 13] = y * b13;
    resultBuffer[resultBufferOffset + 14] = z * b23;
    resultBuffer[resultBufferOffset + 15] = w * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/fill.ts
/**
* Fill a 4 by 4 float buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix4f_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    matrixBuffer[matrixBufferOffset + 4] = value;
    matrixBuffer[matrixBufferOffset + 5] = value;
    matrixBuffer[matrixBufferOffset + 6] = value;
    matrixBuffer[matrixBufferOffset + 7] = value;
    matrixBuffer[matrixBufferOffset + 8] = value;
    matrixBuffer[matrixBufferOffset + 9] = value;
    matrixBuffer[matrixBufferOffset + 10] = value;
    matrixBuffer[matrixBufferOffset + 11] = value;
    matrixBuffer[matrixBufferOffset + 12] = value;
    matrixBuffer[matrixBufferOffset + 13] = value;
    matrixBuffer[matrixBufferOffset + 14] = value;
    matrixBuffer[matrixBufferOffset + 15] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4f_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    return a00 * x + a10 * y + a20 * z + a30 * w;
}
/**
* Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4f_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    return a01 * x + a11 * y + a21 * z + a31 * w;
}
/**
* Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4f_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    return a02 * x + a12 * y + a22 * z + a32 * w;
}
/**
* Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeWComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    return a03 * x + a13 * y + a23 * z + a33 * w;
}

// CONCATENATED MODULE: ./src/matrix4f/toTranslation.ts
/**
* Set the content of a 4 by 4 float buffered matrix to the content of a 3 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param z - Translation to apply to the z axis.
*
* @return The buffer, updated with the content of a 3 dimensional translation matrix.
*/
function matrix4f_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x, y, z) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = x;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = 1;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = y;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = 1;
    matrixBuffer[matrixBufferOffset + 11] = z;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/transpose.ts
/**
* Transpose a 4 by 4 float buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix4f_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a02;
    resultBuffer[resultBufferOffset + 3] = a03;
    resultBuffer[resultBufferOffset + 4] = a10;
    resultBuffer[resultBufferOffset + 5] = a11;
    resultBuffer[resultBufferOffset + 6] = a12;
    resultBuffer[resultBufferOffset + 7] = a13;
    resultBuffer[resultBufferOffset + 8] = a20;
    resultBuffer[resultBufferOffset + 9] = a21;
    resultBuffer[resultBufferOffset + 10] = a22;
    resultBuffer[resultBufferOffset + 11] = a23;
    resultBuffer[resultBufferOffset + 12] = a30;
    resultBuffer[resultBufferOffset + 13] = a31;
    resultBuffer[resultBufferOffset + 14] = a32;
    resultBuffer[resultBufferOffset + 15] = a33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/extractScale.ts
/**
* Extract a scale from a 4 by 4 float buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 4 dimensional scale vector extracted from the given matrix.
*/
function matrix4f_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10 + a20 * a20 + a30 * a30) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11 + a21 * a21 + a31 * a31) * ((a11 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 2] = Math.sqrt(a02 * a02 + a12 * a12 + a22 * a22 + a32 * a32) * ((a22 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 3] = Math.sqrt(a03 * a03 + a13 * a13 + a23 * a23 + a33 * a33) * ((a33 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4f/index.ts





























// CONCATENATED MODULE: ./src/matrix4d/set.ts
/**
* Set the content of a 4 by 4 double buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a20 - Value of the cell at column 2 and row 0 of the matrix.
* @param a30 - Value of the cell at column 3 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
* @param a21 - Value of the cell at column 2 and row 1 of the matrix.
* @param a31 - Value of the cell at column 3 and row 1 of the matrix.
* @param a02 - Value of the cell at column 0 and row 2 of the matrix.
* @param a12 - Value of the cell at column 1 and row 2 of the matrix.
* @param a22 - Value of the cell at column 2 and row 2 of the matrix.
* @param a32 - Value of the cell at column 3 and row 2 of the matrix.
* @param a03 - Value of the cell at column 0 and row 3 of the matrix.
* @param a13 - Value of the cell at column 1 and row 3 of the matrix.
* @param a23 - Value of the cell at column 2 and row 3 of the matrix.
* @param a33 - Value of the cell at column 3 and row 3 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix4d_set_set(buffer, bufferOffset, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a20;
    buffer[bufferOffset + 3] = a30;
    buffer[bufferOffset + 4] = a01;
    buffer[bufferOffset + 5] = a11;
    buffer[bufferOffset + 6] = a21;
    buffer[bufferOffset + 7] = a31;
    buffer[bufferOffset + 8] = a02;
    buffer[bufferOffset + 9] = a12;
    buffer[bufferOffset + 10] = a22;
    buffer[bufferOffset + 11] = a32;
    buffer[bufferOffset + 12] = a03;
    buffer[bufferOffset + 13] = a13;
    buffer[bufferOffset + 14] = a23;
    buffer[bufferOffset + 15] = a33;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix4d/multiplyWithVector.ts
/**
* Multiply 4 by 4 double buffered matrix with a 4 double buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    const b02 = vectorBuffer[vectorBufferOffset + 2];
    const b03 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/toScale.ts
/**
* Set the content of a 4 by 4 double buffered matrix to the content of a 4 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param w - Scale factor of the w axis.
*
* @return The buffer, updated with the content of a 4 dimensional scale matrix.
*/
function matrix4d_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = y;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = z;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = w;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/toString.ts
/**
* Transform a 4 by 4 double buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix4d_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 4 by 4 double null';
    }
    else {
        return [
            `matrix 4 by 4 double `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 3].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 4].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 5].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 6].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 7].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 8].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 9].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 10].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 11].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 12].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 13].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 14].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 15].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix4d/copy.ts
/**
* Copy the content of a 4 by 4 double buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix4d_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a20 = sourceBuffer[sourceBufferOffset + 2];
    const a30 = sourceBuffer[sourceBufferOffset + 3];
    const a01 = sourceBuffer[sourceBufferOffset + 4];
    const a11 = sourceBuffer[sourceBufferOffset + 5];
    const a21 = sourceBuffer[sourceBufferOffset + 6];
    const a31 = sourceBuffer[sourceBufferOffset + 7];
    const a02 = sourceBuffer[sourceBufferOffset + 8];
    const a12 = sourceBuffer[sourceBufferOffset + 9];
    const a22 = sourceBuffer[sourceBufferOffset + 10];
    const a32 = sourceBuffer[sourceBufferOffset + 11];
    const a03 = sourceBuffer[sourceBufferOffset + 12];
    const a13 = sourceBuffer[sourceBufferOffset + 13];
    const a23 = sourceBuffer[sourceBufferOffset + 14];
    const a33 = sourceBuffer[sourceBufferOffset + 15];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a20;
    destinationBuffer[destinationBufferOffset + 3] = a30;
    destinationBuffer[destinationBufferOffset + 4] = a01;
    destinationBuffer[destinationBufferOffset + 5] = a11;
    destinationBuffer[destinationBufferOffset + 6] = a21;
    destinationBuffer[destinationBufferOffset + 7] = a31;
    destinationBuffer[destinationBufferOffset + 8] = a02;
    destinationBuffer[destinationBufferOffset + 9] = a12;
    destinationBuffer[destinationBufferOffset + 10] = a22;
    destinationBuffer[destinationBufferOffset + 11] = a32;
    destinationBuffer[destinationBufferOffset + 12] = a03;
    destinationBuffer[destinationBufferOffset + 13] = a13;
    destinationBuffer[destinationBufferOffset + 14] = a23;
    destinationBuffer[destinationBufferOffset + 15] = a33;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/translate.ts
/**
* Apply a 3 dimensional translation to a 4 by 4 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param z - Translation to apply to the z axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_translate_translate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = 0;
    const a20 = 0;
    const a30 = x;
    const a01 = 0;
    const a11 = 1;
    const a21 = 0;
    const a31 = y;
    const a02 = 0;
    const a12 = 0;
    const a22 = 1;
    const a32 = z;
    const a03 = 0;
    const a13 = 0;
    const a23 = 0;
    const a33 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/add.ts
/**
* Add a 4 by 4 double buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a20 + b20;
    resultBuffer[resultBufferOffset + 3] = a30 + b30;
    resultBuffer[resultBufferOffset + 4] = a01 + b01;
    resultBuffer[resultBufferOffset + 5] = a11 + b11;
    resultBuffer[resultBufferOffset + 6] = a21 + b21;
    resultBuffer[resultBufferOffset + 7] = a31 + b31;
    resultBuffer[resultBufferOffset + 8] = a02 + b02;
    resultBuffer[resultBufferOffset + 9] = a12 + b12;
    resultBuffer[resultBufferOffset + 10] = a22 + b22;
    resultBuffer[resultBufferOffset + 11] = a32 + b32;
    resultBuffer[resultBufferOffset + 12] = a03 + b03;
    resultBuffer[resultBufferOffset + 13] = a13 + b13;
    resultBuffer[resultBufferOffset + 14] = a23 + b23;
    resultBuffer[resultBufferOffset + 15] = a33 + b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 4 by 4 double buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param a30 - Value of the cell of the column 3 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param a21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param a31 - Value of the cell of the column 3 and row 1 of the static matrix.
* @param a02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param a12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param a22 - Value of the cell of the column 2 and row 2 of the static matrix.
* @param a32 - Value of the cell of the column 3 and row 2 of the static matrix.
* @param a03 - Value of the cell of the column 0 and row 3 of the static matrix.
* @param a13 - Value of the cell of the column 1 and row 3 of the static matrix.
* @param a23 - Value of the cell of the column 2 and row 3 of the static matrix.
* @param a33 - Value of the cell of the column 3 and row 3 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b20 = leftBuffer[leftBufferOffset + 2];
    const b30 = leftBuffer[leftBufferOffset + 3];
    const b01 = leftBuffer[leftBufferOffset + 4];
    const b11 = leftBuffer[leftBufferOffset + 5];
    const b21 = leftBuffer[leftBufferOffset + 6];
    const b31 = leftBuffer[leftBufferOffset + 7];
    const b02 = leftBuffer[leftBufferOffset + 8];
    const b12 = leftBuffer[leftBufferOffset + 9];
    const b22 = leftBuffer[leftBufferOffset + 10];
    const b32 = leftBuffer[leftBufferOffset + 11];
    const b03 = leftBuffer[leftBufferOffset + 12];
    const b13 = leftBuffer[leftBufferOffset + 13];
    const b23 = leftBuffer[leftBufferOffset + 14];
    const b33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/rotate.ts
/**
* Apply a 3 dimensional rotation to a 4 by 4 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    const a00 = cosy * cosz;
    const a10 = cosy * -sinz;
    const a20 = siny;
    const a30 = 0;
    const a01 = (-sinx * -siny * cosz + cosx * sinz);
    const a11 = (-sinx * -siny * -sinz + cosx * cosz);
    const a21 = -sinx * cosy;
    const a31 = 0;
    const a02 = (cosx * -siny * cosz + sinx * sinz);
    const a12 = (cosx * -siny * -sinz + sinx * cosz);
    const a22 = cosx * cosy;
    const a32 = 0;
    const a03 = 0;
    const a13 = 0;
    const a23 = 0;
    const a33 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/multiplyWithMatrix.ts
/**
* Multiply 4 by 4 double buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/determinant.ts
/**
* Compute and return the determinant of a 4 by 4 double buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 4 by 4 double buffered matrix.
*/
function matrix4d_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    return a22 * a33 * a11 * a00 + a32 * a13 * a21 * a00 + a12 * a23 * a31 * a00 + a32 * a23 * a01 * a10 + a02 * a33 * a21 * a10 + a22 * a03 * a31 * a10 + a12 * a33 * a01 * a20 + a32 * a03 * a11 * a20 + a02 * a13 * a31 * a20 + a22 * a13 * a01 * a30 + a02 * a23 * a11 * a30 + a12 * a03 * a21 * a30 - a32 * a23 * a11 * a00 - a12 * a33 * a21 * a00 - a22 * a13 * a31 * a00 - a22 * a33 * a01 * a10 - a32 * a03 * a21 * a10 - a02 * a23 * a31 * a10 - a32 * a13 * a01 * a20 - a02 * a33 * a11 * a20 - a12 * a03 * a31 * a20 - a12 * a23 * a01 * a30 - a22 * a03 * a11 * a30 - a02 * a13 * a21 * a30;
}

// CONCATENATED MODULE: ./src/matrix4d/toRotation.ts
/**
* Set the content of a 4 by 4 double buffered matrix to a 3 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
*
* @return The buffer, updated with the content of a 3 dimensional rotation.
*/
function matrix4d_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y, z) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    matrixBuffer[matrixBufferOffset + 0] = cosy * cosz;
    matrixBuffer[matrixBufferOffset + 1] = cosy * -sinz;
    matrixBuffer[matrixBufferOffset + 2] = siny;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = (-sinx * -siny * cosz + cosx * sinz);
    matrixBuffer[matrixBufferOffset + 5] = (-sinx * -siny * -sinz + cosx * cosz);
    matrixBuffer[matrixBufferOffset + 6] = -sinx * cosy;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = (cosx * -siny * cosz + sinx * sinz);
    matrixBuffer[matrixBufferOffset + 9] = (cosx * -siny * -sinz + sinx * cosz);
    matrixBuffer[matrixBufferOffset + 10] = cosx * cosy;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/extractTranslation.ts
/**
* Extract a translation from a 4 by 4 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix4d_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 1] = matrixBuffer[matrixBufferOffset + 7];
    resultBuffer[resultBufferOffset + 2] = matrixBuffer[matrixBufferOffset + 11];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/divideWithScalar.ts
/**
* Divide a 4 by 4 double buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a20 / scalar;
    resultBuffer[resultBufferOffset + 3] = a30 / scalar;
    resultBuffer[resultBufferOffset + 4] = a01 / scalar;
    resultBuffer[resultBufferOffset + 5] = a11 / scalar;
    resultBuffer[resultBufferOffset + 6] = a21 / scalar;
    resultBuffer[resultBufferOffset + 7] = a31 / scalar;
    resultBuffer[resultBufferOffset + 8] = a02 / scalar;
    resultBuffer[resultBufferOffset + 9] = a12 / scalar;
    resultBuffer[resultBufferOffset + 10] = a22 / scalar;
    resultBuffer[resultBufferOffset + 11] = a32 / scalar;
    resultBuffer[resultBufferOffset + 12] = a03 / scalar;
    resultBuffer[resultBufferOffset + 13] = a13 / scalar;
    resultBuffer[resultBufferOffset + 14] = a23 / scalar;
    resultBuffer[resultBufferOffset + 15] = a33 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/invert.ts

/**
* Invert a 4 by 4 double buffered matrix and write the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the result of this operation.
*/
function matrix4d_invert_invert(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    const determinantValue = matrix4d_determinant_determinant(matrixBuffer, matrixBufferOffset);
    resultBuffer[resultBufferOffset + 0] = (a22 * a33 * a11 + a32 * a13 * a21 + a12 * a23 * a31 - a32 * a23 * a11 - a12 * a33 * a21 - a22 * a13 * a31) / determinantValue;
    resultBuffer[resultBufferOffset + 1] = -(a22 * a33 * a10 + a32 * a13 * a20 + a12 * a23 * a30 - a32 * a23 * a10 - a12 * a33 * a20 - a22 * a13 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 2] = (a21 * a33 * a10 + a31 * a13 * a20 + a11 * a23 * a30 - a31 * a23 * a10 - a11 * a33 * a20 - a21 * a13 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 3] = -(a21 * a32 * a10 + a31 * a12 * a20 + a11 * a22 * a30 - a31 * a22 * a10 - a11 * a32 * a20 - a21 * a12 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 4] = -(a22 * a33 * a01 + a32 * a03 * a21 + a02 * a23 * a31 - a32 * a23 * a01 - a02 * a33 * a21 - a22 * a03 * a31) / determinantValue;
    resultBuffer[resultBufferOffset + 5] = (a22 * a33 * a00 + a32 * a03 * a20 + a02 * a23 * a30 - a32 * a23 * a00 - a02 * a33 * a20 - a22 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 6] = -(a21 * a33 * a00 + a31 * a03 * a20 + a01 * a23 * a30 - a31 * a23 * a00 - a01 * a33 * a20 - a21 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 7] = (a21 * a32 * a00 + a31 * a02 * a20 + a01 * a22 * a30 - a31 * a22 * a00 - a01 * a32 * a20 - a21 * a02 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 8] = (a12 * a33 * a01 + a32 * a03 * a11 + a02 * a13 * a31 - a32 * a13 * a01 - a02 * a33 * a11 - a12 * a03 * a31) / determinantValue;
    resultBuffer[resultBufferOffset + 9] = -(a12 * a33 * a00 + a32 * a03 * a10 + a02 * a13 * a30 - a32 * a13 * a00 - a02 * a33 * a10 - a12 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 10] = (a11 * a33 * a00 + a31 * a03 * a10 + a01 * a13 * a30 - a31 * a13 * a00 - a01 * a33 * a10 - a11 * a03 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 11] = -(a11 * a32 * a00 + a31 * a02 * a10 + a01 * a12 * a30 - a31 * a12 * a00 - a01 * a32 * a10 - a11 * a02 * a30) / determinantValue;
    resultBuffer[resultBufferOffset + 12] = -(a12 * a23 * a01 + a22 * a03 * a11 + a02 * a13 * a21 - a22 * a13 * a01 - a02 * a23 * a11 - a12 * a03 * a21) / determinantValue;
    resultBuffer[resultBufferOffset + 13] = (a12 * a23 * a00 + a22 * a03 * a10 + a02 * a13 * a20 - a22 * a13 * a00 - a02 * a23 * a10 - a12 * a03 * a20) / determinantValue;
    resultBuffer[resultBufferOffset + 14] = -(a11 * a23 * a00 + a21 * a03 * a10 + a01 * a13 * a20 - a21 * a13 * a00 - a01 * a23 * a10 - a11 * a03 * a20) / determinantValue;
    resultBuffer[resultBufferOffset + 15] = (a11 * a22 * a00 + a21 * a02 * a10 + a01 * a12 * a20 - a21 * a12 * a00 - a01 * a22 * a10 - a11 * a02 * a20) / determinantValue;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/multiplyWithScalar.ts
/**
* Multiply a 4 by 4 double buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a20 * scalar;
    resultBuffer[resultBufferOffset + 3] = a30 * scalar;
    resultBuffer[resultBufferOffset + 4] = a01 * scalar;
    resultBuffer[resultBufferOffset + 5] = a11 * scalar;
    resultBuffer[resultBufferOffset + 6] = a21 * scalar;
    resultBuffer[resultBufferOffset + 7] = a31 * scalar;
    resultBuffer[resultBufferOffset + 8] = a02 * scalar;
    resultBuffer[resultBufferOffset + 9] = a12 * scalar;
    resultBuffer[resultBufferOffset + 10] = a22 * scalar;
    resultBuffer[resultBufferOffset + 11] = a32 * scalar;
    resultBuffer[resultBufferOffset + 12] = a03 * scalar;
    resultBuffer[resultBufferOffset + 13] = a13 * scalar;
    resultBuffer[resultBufferOffset + 14] = a23 * scalar;
    resultBuffer[resultBufferOffset + 15] = a33 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 4 by 4 double buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param b30 - Value of the cell of the column 3 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param b21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param b31 - Value of the cell of the column 3 and row 1 of the static matrix.
* @param b02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param b12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param b22 - Value of the cell of the column 2 and row 2 of the static matrix.
* @param b32 - Value of the cell of the column 3 and row 2 of the static matrix.
* @param b03 - Value of the cell of the column 0 and row 3 of the static matrix.
* @param b13 - Value of the cell of the column 1 and row 3 of the static matrix.
* @param b23 - Value of the cell of the column 2 and row 3 of the static matrix.
* @param b33 - Value of the cell of the column 3 and row 3 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b20, b30, b01, b11, b21, b31, b02, b12, b22, b32, b03, b13, b23, b33, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a20 = rightBuffer[rightBufferOffset + 2];
    const a30 = rightBuffer[rightBufferOffset + 3];
    const a01 = rightBuffer[rightBufferOffset + 4];
    const a11 = rightBuffer[rightBufferOffset + 5];
    const a21 = rightBuffer[rightBufferOffset + 6];
    const a31 = rightBuffer[rightBufferOffset + 7];
    const a02 = rightBuffer[rightBufferOffset + 8];
    const a12 = rightBuffer[rightBufferOffset + 9];
    const a22 = rightBuffer[rightBufferOffset + 10];
    const a32 = rightBuffer[rightBufferOffset + 11];
    const a03 = rightBuffer[rightBufferOffset + 12];
    const a13 = rightBuffer[rightBufferOffset + 13];
    const a23 = rightBuffer[rightBufferOffset + 14];
    const a33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/extract2DRotation.ts
/**
* Extract a 2D rotation from a 4 by 4 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix4d_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix4d/toIdentity.ts
/**
* Set the content of a 4 by 4 double buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix4d_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = 1;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = 1;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/equals.ts
/**
* Compare two 4 by 4 double buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix4d_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a20 - b20) < tolerance &&
        Math.abs(a30 - b30) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance &&
        Math.abs(a21 - b21) < tolerance &&
        Math.abs(a31 - b31) < tolerance &&
        Math.abs(a02 - b02) < tolerance &&
        Math.abs(a12 - b12) < tolerance &&
        Math.abs(a22 - b22) < tolerance &&
        Math.abs(a32 - b32) < tolerance &&
        Math.abs(a03 - b03) < tolerance &&
        Math.abs(a13 - b13) < tolerance &&
        Math.abs(a23 - b23) < tolerance &&
        Math.abs(a33 - b33) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix4d/negate.ts
/**
* Negate a 4 by 4 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a20;
    resultBuffer[resultBufferOffset + 3] = -a30;
    resultBuffer[resultBufferOffset + 4] = -a01;
    resultBuffer[resultBufferOffset + 5] = -a11;
    resultBuffer[resultBufferOffset + 6] = -a21;
    resultBuffer[resultBufferOffset + 7] = -a31;
    resultBuffer[resultBufferOffset + 8] = -a02;
    resultBuffer[resultBufferOffset + 9] = -a12;
    resultBuffer[resultBufferOffset + 10] = -a22;
    resultBuffer[resultBufferOffset + 11] = -a32;
    resultBuffer[resultBufferOffset + 12] = -a03;
    resultBuffer[resultBufferOffset + 13] = -a13;
    resultBuffer[resultBufferOffset + 14] = -a23;
    resultBuffer[resultBufferOffset + 15] = -a33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/subtract.ts
/**
* Subtract a 4 by 4 double buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a20 - b20;
    resultBuffer[resultBufferOffset + 3] = a30 - b30;
    resultBuffer[resultBufferOffset + 4] = a01 - b01;
    resultBuffer[resultBufferOffset + 5] = a11 - b11;
    resultBuffer[resultBufferOffset + 6] = a21 - b21;
    resultBuffer[resultBufferOffset + 7] = a31 - b31;
    resultBuffer[resultBufferOffset + 8] = a02 - b02;
    resultBuffer[resultBufferOffset + 9] = a12 - b12;
    resultBuffer[resultBufferOffset + 10] = a22 - b22;
    resultBuffer[resultBufferOffset + 11] = a32 - b32;
    resultBuffer[resultBufferOffset + 12] = a03 - b03;
    resultBuffer[resultBufferOffset + 13] = a13 - b13;
    resultBuffer[resultBufferOffset + 14] = a23 - b23;
    resultBuffer[resultBufferOffset + 15] = a33 - b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/scale.ts
/**
* Apply a 4 dimensional scale to a 4 by 4 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param w - Scale factor of the w axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4d_scale_scale(matrixBuffer, matrixBufferOffset, x, y, z, w, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = z * b20;
    resultBuffer[resultBufferOffset + 3] = w * b30;
    resultBuffer[resultBufferOffset + 4] = x * b01;
    resultBuffer[resultBufferOffset + 5] = y * b11;
    resultBuffer[resultBufferOffset + 6] = z * b21;
    resultBuffer[resultBufferOffset + 7] = w * b31;
    resultBuffer[resultBufferOffset + 8] = x * b02;
    resultBuffer[resultBufferOffset + 9] = y * b12;
    resultBuffer[resultBufferOffset + 10] = z * b22;
    resultBuffer[resultBufferOffset + 11] = w * b32;
    resultBuffer[resultBufferOffset + 12] = x * b03;
    resultBuffer[resultBufferOffset + 13] = y * b13;
    resultBuffer[resultBufferOffset + 14] = z * b23;
    resultBuffer[resultBufferOffset + 15] = w * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/fill.ts
/**
* Fill a 4 by 4 double buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix4d_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    matrixBuffer[matrixBufferOffset + 4] = value;
    matrixBuffer[matrixBufferOffset + 5] = value;
    matrixBuffer[matrixBufferOffset + 6] = value;
    matrixBuffer[matrixBufferOffset + 7] = value;
    matrixBuffer[matrixBufferOffset + 8] = value;
    matrixBuffer[matrixBufferOffset + 9] = value;
    matrixBuffer[matrixBufferOffset + 10] = value;
    matrixBuffer[matrixBufferOffset + 11] = value;
    matrixBuffer[matrixBufferOffset + 12] = value;
    matrixBuffer[matrixBufferOffset + 13] = value;
    matrixBuffer[matrixBufferOffset + 14] = value;
    matrixBuffer[matrixBufferOffset + 15] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4d_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    return a00 * x + a10 * y + a20 * z + a30 * w;
}
/**
* Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4d_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    return a01 * x + a11 * y + a21 * z + a31 * w;
}
/**
* Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4d_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    return a02 * x + a12 * y + a22 * z + a32 * w;
}
/**
* Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function computeComponentOfMultiplicationWithVector_computeWComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    return a03 * x + a13 * y + a23 * z + a33 * w;
}

// CONCATENATED MODULE: ./src/matrix4d/toTranslation.ts
/**
* Set the content of a 4 by 4 double buffered matrix to the content of a 3 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param z - Translation to apply to the z axis.
*
* @return The buffer, updated with the content of a 3 dimensional translation matrix.
*/
function matrix4d_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x, y, z) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = x;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = 1;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = y;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = 1;
    matrixBuffer[matrixBufferOffset + 11] = z;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/transpose.ts
/**
* Transpose a 4 by 4 double buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix4d_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a02;
    resultBuffer[resultBufferOffset + 3] = a03;
    resultBuffer[resultBufferOffset + 4] = a10;
    resultBuffer[resultBufferOffset + 5] = a11;
    resultBuffer[resultBufferOffset + 6] = a12;
    resultBuffer[resultBufferOffset + 7] = a13;
    resultBuffer[resultBufferOffset + 8] = a20;
    resultBuffer[resultBufferOffset + 9] = a21;
    resultBuffer[resultBufferOffset + 10] = a22;
    resultBuffer[resultBufferOffset + 11] = a23;
    resultBuffer[resultBufferOffset + 12] = a30;
    resultBuffer[resultBufferOffset + 13] = a31;
    resultBuffer[resultBufferOffset + 14] = a32;
    resultBuffer[resultBufferOffset + 15] = a33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/extractScale.ts
/**
* Extract a scale from a 4 by 4 double buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 4 dimensional scale vector extracted from the given matrix.
*/
function matrix4d_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10 + a20 * a20 + a30 * a30) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11 + a21 * a21 + a31 * a31) * ((a11 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 2] = Math.sqrt(a02 * a02 + a12 * a12 + a22 * a22 + a32 * a32) * ((a22 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 3] = Math.sqrt(a03 * a03 + a13 * a13 + a23 * a23 + a33 * a33) * ((a33 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4d/index.ts





























// CONCATENATED MODULE: ./src/matrix4i/set.ts
/**
* Set the content of a 4 by 4 integer buffered matrix.
*
* @param buffer - Buffer to mutate.
* @param bufferOffset - Offset to apply when we mutate the buffer.
* @param a00 - Value of the cell at column 0 and row 0 of the matrix.
* @param a10 - Value of the cell at column 1 and row 0 of the matrix.
* @param a20 - Value of the cell at column 2 and row 0 of the matrix.
* @param a30 - Value of the cell at column 3 and row 0 of the matrix.
* @param a01 - Value of the cell at column 0 and row 1 of the matrix.
* @param a11 - Value of the cell at column 1 and row 1 of the matrix.
* @param a21 - Value of the cell at column 2 and row 1 of the matrix.
* @param a31 - Value of the cell at column 3 and row 1 of the matrix.
* @param a02 - Value of the cell at column 0 and row 2 of the matrix.
* @param a12 - Value of the cell at column 1 and row 2 of the matrix.
* @param a22 - Value of the cell at column 2 and row 2 of the matrix.
* @param a32 - Value of the cell at column 3 and row 2 of the matrix.
* @param a03 - Value of the cell at column 0 and row 3 of the matrix.
* @param a13 - Value of the cell at column 1 and row 3 of the matrix.
* @param a23 - Value of the cell at column 2 and row 3 of the matrix.
* @param a33 - Value of the cell at column 3 and row 3 of the matrix.
*
* @return The buffer, updated with the given data.
*/
function matrix4i_set_set(buffer, bufferOffset, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
    buffer[bufferOffset + 0] = a00;
    buffer[bufferOffset + 1] = a10;
    buffer[bufferOffset + 2] = a20;
    buffer[bufferOffset + 3] = a30;
    buffer[bufferOffset + 4] = a01;
    buffer[bufferOffset + 5] = a11;
    buffer[bufferOffset + 6] = a21;
    buffer[bufferOffset + 7] = a31;
    buffer[bufferOffset + 8] = a02;
    buffer[bufferOffset + 9] = a12;
    buffer[bufferOffset + 10] = a22;
    buffer[bufferOffset + 11] = a32;
    buffer[bufferOffset + 12] = a03;
    buffer[bufferOffset + 13] = a13;
    buffer[bufferOffset + 14] = a23;
    buffer[bufferOffset + 15] = a33;
    return buffer;
}

// CONCATENATED MODULE: ./src/matrix4i/multiplyWithVector.ts
/**
* Multiply 4 by 4 integer buffered matrix with a 4 integer buffered vector and put the result into a third buffer.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param vectorBuffer - Buffer that contains the right operand vector.
* @param vectorBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_multiplyWithVector_multiplyWithVector(matrixBuffer, matrixBufferOffset, vectorBuffer, vectorBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    const b00 = vectorBuffer[vectorBufferOffset + 0];
    const b01 = vectorBuffer[vectorBufferOffset + 1];
    const b02 = vectorBuffer[vectorBufferOffset + 2];
    const b03 = vectorBuffer[vectorBufferOffset + 3];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/toScale.ts
/**
* Set the content of a 4 by 4 integer buffered matrix to the content of a 4 dimensional scale matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param w - Scale factor of the w axis.
*
* @return The buffer, updated with the content of a 4 dimensional scale matrix.
*/
function matrix4i_toScale_toScale(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    matrixBuffer[matrixBufferOffset + 0] = x;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = y;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = z;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = w;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/toString.ts
/**
* Transform a 4 by 4 integer buffered matrix into a string.
*
* @param matrixBuffer - The buffer that contains the matrix to transform.
* @param matrixBufferOffset - The offset to apply when we read the given buffer.
*
* @return A string representation of the given matrix.
*/
function matrix4i_toString_toString(matrixBuffer, matrixBufferOffset) {
    if (matrixBuffer == null) {
        return 'matrix 4 by 4 integer null';
    }
    else {
        return [
            `matrix 4 by 4 integer `,
            '[',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 0].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 1].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 2].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 3].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 4].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 5].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 6].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 7].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 8].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 9].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 10].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 11].toPrecision(8), ',',
            '\n\r\t', matrixBuffer[matrixBufferOffset + 12].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 13].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 14].toPrecision(8), ', ', matrixBuffer[matrixBufferOffset + 15].toPrecision(8),
            '\n\r]'
        ].join('');
    }
}

// CONCATENATED MODULE: ./src/matrix4i/copy.ts
/**
* Copy the content of a 4 by 4 integer buffered matrix into another.
*
* @param sourceBuffer - Buffer to read.
* @param sourceBufferOffset - Offset to apply when we read the source buffer.
* @param destinationBuffer - Buffer to write.
* @param destinationBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the source data.
*/
function matrix4i_copy_copy(sourceBuffer, sourceBufferOffset, destinationBuffer, destinationBufferOffset) {
    const a00 = sourceBuffer[sourceBufferOffset + 0];
    const a10 = sourceBuffer[sourceBufferOffset + 1];
    const a20 = sourceBuffer[sourceBufferOffset + 2];
    const a30 = sourceBuffer[sourceBufferOffset + 3];
    const a01 = sourceBuffer[sourceBufferOffset + 4];
    const a11 = sourceBuffer[sourceBufferOffset + 5];
    const a21 = sourceBuffer[sourceBufferOffset + 6];
    const a31 = sourceBuffer[sourceBufferOffset + 7];
    const a02 = sourceBuffer[sourceBufferOffset + 8];
    const a12 = sourceBuffer[sourceBufferOffset + 9];
    const a22 = sourceBuffer[sourceBufferOffset + 10];
    const a32 = sourceBuffer[sourceBufferOffset + 11];
    const a03 = sourceBuffer[sourceBufferOffset + 12];
    const a13 = sourceBuffer[sourceBufferOffset + 13];
    const a23 = sourceBuffer[sourceBufferOffset + 14];
    const a33 = sourceBuffer[sourceBufferOffset + 15];
    destinationBuffer[destinationBufferOffset + 0] = a00;
    destinationBuffer[destinationBufferOffset + 1] = a10;
    destinationBuffer[destinationBufferOffset + 2] = a20;
    destinationBuffer[destinationBufferOffset + 3] = a30;
    destinationBuffer[destinationBufferOffset + 4] = a01;
    destinationBuffer[destinationBufferOffset + 5] = a11;
    destinationBuffer[destinationBufferOffset + 6] = a21;
    destinationBuffer[destinationBufferOffset + 7] = a31;
    destinationBuffer[destinationBufferOffset + 8] = a02;
    destinationBuffer[destinationBufferOffset + 9] = a12;
    destinationBuffer[destinationBufferOffset + 10] = a22;
    destinationBuffer[destinationBufferOffset + 11] = a32;
    destinationBuffer[destinationBufferOffset + 12] = a03;
    destinationBuffer[destinationBufferOffset + 13] = a13;
    destinationBuffer[destinationBufferOffset + 14] = a23;
    destinationBuffer[destinationBufferOffset + 15] = a33;
    return destinationBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/translate.ts
/**
* Apply a 3 dimensional translation to a 4 by 4 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param z - Translation to apply to the z axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_translate_translate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const a00 = 1;
    const a10 = 0;
    const a20 = 0;
    const a30 = x;
    const a01 = 0;
    const a11 = 1;
    const a21 = 0;
    const a31 = y;
    const a02 = 0;
    const a12 = 0;
    const a22 = 1;
    const a32 = z;
    const a03 = 0;
    const a13 = 0;
    const a23 = 0;
    const a33 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/add.ts
/**
* Add a 4 by 4 integer buffered matrix to another one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_add_add(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 + b00;
    resultBuffer[resultBufferOffset + 1] = a10 + b10;
    resultBuffer[resultBufferOffset + 2] = a20 + b20;
    resultBuffer[resultBufferOffset + 3] = a30 + b30;
    resultBuffer[resultBufferOffset + 4] = a01 + b01;
    resultBuffer[resultBufferOffset + 5] = a11 + b11;
    resultBuffer[resultBufferOffset + 6] = a21 + b21;
    resultBuffer[resultBufferOffset + 7] = a31 + b31;
    resultBuffer[resultBufferOffset + 8] = a02 + b02;
    resultBuffer[resultBufferOffset + 9] = a12 + b12;
    resultBuffer[resultBufferOffset + 10] = a22 + b22;
    resultBuffer[resultBufferOffset + 11] = a32 + b32;
    resultBuffer[resultBufferOffset + 12] = a03 + b03;
    resultBuffer[resultBufferOffset + 13] = a13 + b13;
    resultBuffer[resultBufferOffset + 14] = a23 + b23;
    resultBuffer[resultBufferOffset + 15] = a33 + b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/multiplyWithStaticMatrixAsRightOperand.ts
/**
* Multiply a 4 by 4 integer buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param a00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param a10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param a20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param a30 - Value of the cell of the column 3 and row 0 of the static matrix.
* @param a01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param a11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param a21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param a31 - Value of the cell of the column 3 and row 1 of the static matrix.
* @param a02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param a12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param a22 - Value of the cell of the column 2 and row 2 of the static matrix.
* @param a32 - Value of the cell of the column 3 and row 2 of the static matrix.
* @param a03 - Value of the cell of the column 0 and row 3 of the static matrix.
* @param a13 - Value of the cell of the column 1 and row 3 of the static matrix.
* @param a23 - Value of the cell of the column 2 and row 3 of the static matrix.
* @param a33 - Value of the cell of the column 3 and row 3 of the static matrix.

* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(leftBuffer, leftBufferOffset, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, resultBuffer, resultBufferOffset) {
    const b00 = leftBuffer[leftBufferOffset + 0];
    const b10 = leftBuffer[leftBufferOffset + 1];
    const b20 = leftBuffer[leftBufferOffset + 2];
    const b30 = leftBuffer[leftBufferOffset + 3];
    const b01 = leftBuffer[leftBufferOffset + 4];
    const b11 = leftBuffer[leftBufferOffset + 5];
    const b21 = leftBuffer[leftBufferOffset + 6];
    const b31 = leftBuffer[leftBufferOffset + 7];
    const b02 = leftBuffer[leftBufferOffset + 8];
    const b12 = leftBuffer[leftBufferOffset + 9];
    const b22 = leftBuffer[leftBufferOffset + 10];
    const b32 = leftBuffer[leftBufferOffset + 11];
    const b03 = leftBuffer[leftBufferOffset + 12];
    const b13 = leftBuffer[leftBufferOffset + 13];
    const b23 = leftBuffer[leftBufferOffset + 14];
    const b33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/rotate.ts
/**
* Apply a 3 dimensional rotation to a 4 by 4 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_rotate_rotate(matrixBuffer, matrixBufferOffset, x, y, z, resultBuffer, resultBufferOffset) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    const a00 = cosy * cosz;
    const a10 = cosy * -sinz;
    const a20 = siny;
    const a30 = 0;
    const a01 = (-sinx * -siny * cosz + cosx * sinz);
    const a11 = (-sinx * -siny * -sinz + cosx * cosz);
    const a21 = -sinx * cosy;
    const a31 = 0;
    const a02 = (cosx * -siny * cosz + sinx * sinz);
    const a12 = (cosx * -siny * -sinz + sinx * cosz);
    const a22 = cosx * cosy;
    const a32 = 0;
    const a03 = 0;
    const a13 = 0;
    const a23 = 0;
    const a33 = 1;
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/multiplyWithMatrix.ts
/**
* Multiply 4 by 4 integer buffered matrix with another and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_multiplyWithMatrix_multiplyWithMatrix(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/determinant.ts
/**
* Compute and return the determinant of a 4 by 4 integer buffered matrix.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The determinant of the given 4 by 4 integer buffered matrix.
*/
function matrix4i_determinant_determinant(matrixBuffer, matrixBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    return a22 * a33 * a11 * a00 + a32 * a13 * a21 * a00 + a12 * a23 * a31 * a00 + a32 * a23 * a01 * a10 + a02 * a33 * a21 * a10 + a22 * a03 * a31 * a10 + a12 * a33 * a01 * a20 + a32 * a03 * a11 * a20 + a02 * a13 * a31 * a20 + a22 * a13 * a01 * a30 + a02 * a23 * a11 * a30 + a12 * a03 * a21 * a30 - a32 * a23 * a11 * a00 - a12 * a33 * a21 * a00 - a22 * a13 * a31 * a00 - a22 * a33 * a01 * a10 - a32 * a03 * a21 * a10 - a02 * a23 * a31 * a10 - a32 * a13 * a01 * a20 - a02 * a33 * a11 * a20 - a12 * a03 * a31 * a20 - a12 * a23 * a01 * a30 - a22 * a03 * a11 * a30 - a02 * a13 * a21 * a30;
}

// CONCATENATED MODULE: ./src/matrix4i/toRotation.ts
/**
* Set the content of a 4 by 4 integer buffered matrix to a 3 dimensional rotation.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Rotation for the x axis in radians.
* @param y - Rotation for the y axis in radians.
* @param z - Rotation for the z axis in radians.
*
* @return The buffer, updated with the content of a 3 dimensional rotation.
*/
function matrix4i_toRotation_toRotation(matrixBuffer, matrixBufferOffset, x, y, z) {
    const cosx = Math.cos(x);
    const sinx = Math.sin(x);
    const cosy = Math.cos(y);
    const siny = Math.sin(y);
    const cosz = Math.cos(z);
    const sinz = Math.sin(z);
    matrixBuffer[matrixBufferOffset + 0] = cosy * cosz;
    matrixBuffer[matrixBufferOffset + 1] = cosy * -sinz;
    matrixBuffer[matrixBufferOffset + 2] = siny;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = (-sinx * -siny * cosz + cosx * sinz);
    matrixBuffer[matrixBufferOffset + 5] = (-sinx * -siny * -sinz + cosx * cosz);
    matrixBuffer[matrixBufferOffset + 6] = -sinx * cosy;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = (cosx * -siny * cosz + sinx * sinz);
    matrixBuffer[matrixBufferOffset + 9] = (cosx * -siny * -sinz + sinx * cosz);
    matrixBuffer[matrixBufferOffset + 10] = cosx * cosy;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/extractTranslation.ts
/**
* Extract a translation from a 4 by 4 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the translation vector extracted from the given matrix.
*/
function matrix4i_extractTranslation_extractTranslation(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    resultBuffer[resultBufferOffset + 0] = matrixBuffer[matrixBufferOffset + 3];
    resultBuffer[resultBufferOffset + 1] = matrixBuffer[matrixBufferOffset + 7];
    resultBuffer[resultBufferOffset + 2] = matrixBuffer[matrixBufferOffset + 11];
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/divideWithScalar.ts
/**
* Divide a 4 by 4 integer buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_divideWithScalar_divideWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 / scalar;
    resultBuffer[resultBufferOffset + 1] = a10 / scalar;
    resultBuffer[resultBufferOffset + 2] = a20 / scalar;
    resultBuffer[resultBufferOffset + 3] = a30 / scalar;
    resultBuffer[resultBufferOffset + 4] = a01 / scalar;
    resultBuffer[resultBufferOffset + 5] = a11 / scalar;
    resultBuffer[resultBufferOffset + 6] = a21 / scalar;
    resultBuffer[resultBufferOffset + 7] = a31 / scalar;
    resultBuffer[resultBufferOffset + 8] = a02 / scalar;
    resultBuffer[resultBufferOffset + 9] = a12 / scalar;
    resultBuffer[resultBufferOffset + 10] = a22 / scalar;
    resultBuffer[resultBufferOffset + 11] = a32 / scalar;
    resultBuffer[resultBufferOffset + 12] = a03 / scalar;
    resultBuffer[resultBufferOffset + 13] = a13 / scalar;
    resultBuffer[resultBufferOffset + 14] = a23 / scalar;
    resultBuffer[resultBufferOffset + 15] = a33 / scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/multiplyWithScalar.ts
/**
* Multiply a 4 by 4 integer buffered matrix with a scalar and put the result into another buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param scalar - Scalar to use as right operand.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_multiplyWithScalar_multiplyWithScalar(leftBuffer, leftBufferOffset, scalar, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * scalar;
    resultBuffer[resultBufferOffset + 1] = a10 * scalar;
    resultBuffer[resultBufferOffset + 2] = a20 * scalar;
    resultBuffer[resultBufferOffset + 3] = a30 * scalar;
    resultBuffer[resultBufferOffset + 4] = a01 * scalar;
    resultBuffer[resultBufferOffset + 5] = a11 * scalar;
    resultBuffer[resultBufferOffset + 6] = a21 * scalar;
    resultBuffer[resultBufferOffset + 7] = a31 * scalar;
    resultBuffer[resultBufferOffset + 8] = a02 * scalar;
    resultBuffer[resultBufferOffset + 9] = a12 * scalar;
    resultBuffer[resultBufferOffset + 10] = a22 * scalar;
    resultBuffer[resultBufferOffset + 11] = a32 * scalar;
    resultBuffer[resultBufferOffset + 12] = a03 * scalar;
    resultBuffer[resultBufferOffset + 13] = a13 * scalar;
    resultBuffer[resultBufferOffset + 14] = a23 * scalar;
    resultBuffer[resultBufferOffset + 15] = a33 * scalar;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/multiplyWithStaticMatrixAsLeftOperand.ts
/**
* Multiply a 4 by 4 integer buffered matrix with another static matrix, the buffered matrix will be used as a left operand.
*
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the first buffer.
* @param b00 - Value of the cell of the column 0 and row 0 of the static matrix.
* @param b10 - Value of the cell of the column 1 and row 0 of the static matrix.
* @param b20 - Value of the cell of the column 2 and row 0 of the static matrix.
* @param b30 - Value of the cell of the column 3 and row 0 of the static matrix.
* @param b01 - Value of the cell of the column 0 and row 1 of the static matrix.
* @param b11 - Value of the cell of the column 1 and row 1 of the static matrix.
* @param b21 - Value of the cell of the column 2 and row 1 of the static matrix.
* @param b31 - Value of the cell of the column 3 and row 1 of the static matrix.
* @param b02 - Value of the cell of the column 0 and row 2 of the static matrix.
* @param b12 - Value of the cell of the column 1 and row 2 of the static matrix.
* @param b22 - Value of the cell of the column 2 and row 2 of the static matrix.
* @param b32 - Value of the cell of the column 3 and row 2 of the static matrix.
* @param b03 - Value of the cell of the column 0 and row 3 of the static matrix.
* @param b13 - Value of the cell of the column 1 and row 3 of the static matrix.
* @param b23 - Value of the cell of the column 2 and row 3 of the static matrix.
* @param b33 - Value of the cell of the column 3 and row 3 of the static matrix.
,
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(rightBuffer, rightBufferOffset, b00, b10, b20, b30, b01, b11, b21, b31, b02, b12, b22, b32, b03, b13, b23, b33, resultBuffer, resultBufferOffset) {
    const a00 = rightBuffer[rightBufferOffset + 0];
    const a10 = rightBuffer[rightBufferOffset + 1];
    const a20 = rightBuffer[rightBufferOffset + 2];
    const a30 = rightBuffer[rightBufferOffset + 3];
    const a01 = rightBuffer[rightBufferOffset + 4];
    const a11 = rightBuffer[rightBufferOffset + 5];
    const a21 = rightBuffer[rightBufferOffset + 6];
    const a31 = rightBuffer[rightBufferOffset + 7];
    const a02 = rightBuffer[rightBufferOffset + 8];
    const a12 = rightBuffer[rightBufferOffset + 9];
    const a22 = rightBuffer[rightBufferOffset + 10];
    const a32 = rightBuffer[rightBufferOffset + 11];
    const a03 = rightBuffer[rightBufferOffset + 12];
    const a13 = rightBuffer[rightBufferOffset + 13];
    const a23 = rightBuffer[rightBufferOffset + 14];
    const a33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
    resultBuffer[resultBufferOffset + 1] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
    resultBuffer[resultBufferOffset + 2] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
    resultBuffer[resultBufferOffset + 3] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
    resultBuffer[resultBufferOffset + 4] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
    resultBuffer[resultBufferOffset + 5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
    resultBuffer[resultBufferOffset + 6] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
    resultBuffer[resultBufferOffset + 7] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
    resultBuffer[resultBufferOffset + 8] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
    resultBuffer[resultBufferOffset + 9] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
    resultBuffer[resultBufferOffset + 10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
    resultBuffer[resultBufferOffset + 11] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
    resultBuffer[resultBufferOffset + 12] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
    resultBuffer[resultBufferOffset + 13] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
    resultBuffer[resultBufferOffset + 14] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
    resultBuffer[resultBufferOffset + 15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/extract2DRotation.ts
/**
* Extract a 2D rotation from a 4 by 4 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
*
* @return The 2D rotation angle in radians extracted from the given matrix.
*/
function matrix4i_extract2DRotation_extract2DRotation(matrixBuffer, matrixBufferOffset) {
    const a = matrixBuffer[matrixBufferOffset + 0];
    const b = matrixBuffer[matrixBufferOffset + 1];
    return Math.atan(-b / a);
}

// CONCATENATED MODULE: ./src/matrix4i/toIdentity.ts
/**
* Set the content of a 4 by 4 integer buffered matrix to the content of an identity matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
*
* @return The buffer, updated with content of an identity matrix.
*/
function matrix4i_toIdentity_toIdentity(matrixBuffer, matrixBufferOffset) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = 0;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = 1;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = 0;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = 1;
    matrixBuffer[matrixBufferOffset + 11] = 0;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/equals.ts
/**
* Compare two 4 by 4 integer buffered matrix and return true if they are both equals.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the buffer that contains the left operand matrix.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the buffer that contains the right operand matrix.
* @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
*
* @return True if both matrices are equals.
*/
function matrix4i_equals_equals(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, tolerance = Number.EPSILON) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    return Math.abs(a00 - b00) < tolerance &&
        Math.abs(a10 - b10) < tolerance &&
        Math.abs(a20 - b20) < tolerance &&
        Math.abs(a30 - b30) < tolerance &&
        Math.abs(a01 - b01) < tolerance &&
        Math.abs(a11 - b11) < tolerance &&
        Math.abs(a21 - b21) < tolerance &&
        Math.abs(a31 - b31) < tolerance &&
        Math.abs(a02 - b02) < tolerance &&
        Math.abs(a12 - b12) < tolerance &&
        Math.abs(a22 - b22) < tolerance &&
        Math.abs(a32 - b32) < tolerance &&
        Math.abs(a03 - b03) < tolerance &&
        Math.abs(a13 - b13) < tolerance &&
        Math.abs(a23 - b23) < tolerance &&
        Math.abs(a33 - b33) < tolerance;
}

// CONCATENATED MODULE: ./src/matrix4i/negate.ts
/**
* Negate a 4 by 4 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_negate_negate(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = -a00;
    resultBuffer[resultBufferOffset + 1] = -a10;
    resultBuffer[resultBufferOffset + 2] = -a20;
    resultBuffer[resultBufferOffset + 3] = -a30;
    resultBuffer[resultBufferOffset + 4] = -a01;
    resultBuffer[resultBufferOffset + 5] = -a11;
    resultBuffer[resultBufferOffset + 6] = -a21;
    resultBuffer[resultBufferOffset + 7] = -a31;
    resultBuffer[resultBufferOffset + 8] = -a02;
    resultBuffer[resultBufferOffset + 9] = -a12;
    resultBuffer[resultBufferOffset + 10] = -a22;
    resultBuffer[resultBufferOffset + 11] = -a32;
    resultBuffer[resultBufferOffset + 12] = -a03;
    resultBuffer[resultBufferOffset + 13] = -a13;
    resultBuffer[resultBufferOffset + 14] = -a23;
    resultBuffer[resultBufferOffset + 15] = -a33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/subtract.ts
/**
* Subtract a 4 by 4 integer buffered matrix to one and put the result into a third buffer.
*
* @param leftBuffer - Buffer that contains the left operand matrix.
* @param leftBufferOffset - Offset to apply when we read the first buffer.
* @param rightBuffer - Buffer that contains the right operand matrix.
* @param rightBufferOffset - Offset to apply when we read the second buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_subtract_subtract(leftBuffer, leftBufferOffset, rightBuffer, rightBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = leftBuffer[leftBufferOffset + 0];
    const a10 = leftBuffer[leftBufferOffset + 1];
    const a20 = leftBuffer[leftBufferOffset + 2];
    const a30 = leftBuffer[leftBufferOffset + 3];
    const a01 = leftBuffer[leftBufferOffset + 4];
    const a11 = leftBuffer[leftBufferOffset + 5];
    const a21 = leftBuffer[leftBufferOffset + 6];
    const a31 = leftBuffer[leftBufferOffset + 7];
    const a02 = leftBuffer[leftBufferOffset + 8];
    const a12 = leftBuffer[leftBufferOffset + 9];
    const a22 = leftBuffer[leftBufferOffset + 10];
    const a32 = leftBuffer[leftBufferOffset + 11];
    const a03 = leftBuffer[leftBufferOffset + 12];
    const a13 = leftBuffer[leftBufferOffset + 13];
    const a23 = leftBuffer[leftBufferOffset + 14];
    const a33 = leftBuffer[leftBufferOffset + 15];
    const b00 = rightBuffer[rightBufferOffset + 0];
    const b10 = rightBuffer[rightBufferOffset + 1];
    const b20 = rightBuffer[rightBufferOffset + 2];
    const b30 = rightBuffer[rightBufferOffset + 3];
    const b01 = rightBuffer[rightBufferOffset + 4];
    const b11 = rightBuffer[rightBufferOffset + 5];
    const b21 = rightBuffer[rightBufferOffset + 6];
    const b31 = rightBuffer[rightBufferOffset + 7];
    const b02 = rightBuffer[rightBufferOffset + 8];
    const b12 = rightBuffer[rightBufferOffset + 9];
    const b22 = rightBuffer[rightBufferOffset + 10];
    const b32 = rightBuffer[rightBufferOffset + 11];
    const b03 = rightBuffer[rightBufferOffset + 12];
    const b13 = rightBuffer[rightBufferOffset + 13];
    const b23 = rightBuffer[rightBufferOffset + 14];
    const b33 = rightBuffer[rightBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00 - b00;
    resultBuffer[resultBufferOffset + 1] = a10 - b10;
    resultBuffer[resultBufferOffset + 2] = a20 - b20;
    resultBuffer[resultBufferOffset + 3] = a30 - b30;
    resultBuffer[resultBufferOffset + 4] = a01 - b01;
    resultBuffer[resultBufferOffset + 5] = a11 - b11;
    resultBuffer[resultBufferOffset + 6] = a21 - b21;
    resultBuffer[resultBufferOffset + 7] = a31 - b31;
    resultBuffer[resultBufferOffset + 8] = a02 - b02;
    resultBuffer[resultBufferOffset + 9] = a12 - b12;
    resultBuffer[resultBufferOffset + 10] = a22 - b22;
    resultBuffer[resultBufferOffset + 11] = a32 - b32;
    resultBuffer[resultBufferOffset + 12] = a03 - b03;
    resultBuffer[resultBufferOffset + 13] = a13 - b13;
    resultBuffer[resultBufferOffset + 14] = a23 - b23;
    resultBuffer[resultBufferOffset + 15] = a33 - b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/scale.ts
/**
* Apply a 4 dimensional scale to a 4 by 4 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer that contains the matrix to transform.
* @param matrixBufferOffset - Offset to apply when we read the matrix buffer.
* @param x - Scale factor of the x axis.
* @param y - Scale factor of the y axis.
* @param z - Scale factor of the z axis.
* @param w - Scale factor of the w axis.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the result of the operation.
*/
function matrix4i_scale_scale(matrixBuffer, matrixBufferOffset, x, y, z, w, resultBuffer, resultBufferOffset) {
    const b00 = matrixBuffer[matrixBufferOffset + 0];
    const b10 = matrixBuffer[matrixBufferOffset + 1];
    const b20 = matrixBuffer[matrixBufferOffset + 2];
    const b30 = matrixBuffer[matrixBufferOffset + 3];
    const b01 = matrixBuffer[matrixBufferOffset + 4];
    const b11 = matrixBuffer[matrixBufferOffset + 5];
    const b21 = matrixBuffer[matrixBufferOffset + 6];
    const b31 = matrixBuffer[matrixBufferOffset + 7];
    const b02 = matrixBuffer[matrixBufferOffset + 8];
    const b12 = matrixBuffer[matrixBufferOffset + 9];
    const b22 = matrixBuffer[matrixBufferOffset + 10];
    const b32 = matrixBuffer[matrixBufferOffset + 11];
    const b03 = matrixBuffer[matrixBufferOffset + 12];
    const b13 = matrixBuffer[matrixBufferOffset + 13];
    const b23 = matrixBuffer[matrixBufferOffset + 14];
    const b33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = x * b00;
    resultBuffer[resultBufferOffset + 1] = y * b10;
    resultBuffer[resultBufferOffset + 2] = z * b20;
    resultBuffer[resultBufferOffset + 3] = w * b30;
    resultBuffer[resultBufferOffset + 4] = x * b01;
    resultBuffer[resultBufferOffset + 5] = y * b11;
    resultBuffer[resultBufferOffset + 6] = z * b21;
    resultBuffer[resultBufferOffset + 7] = w * b31;
    resultBuffer[resultBufferOffset + 8] = x * b02;
    resultBuffer[resultBufferOffset + 9] = y * b12;
    resultBuffer[resultBufferOffset + 10] = z * b22;
    resultBuffer[resultBufferOffset + 11] = w * b32;
    resultBuffer[resultBufferOffset + 12] = x * b03;
    resultBuffer[resultBufferOffset + 13] = y * b13;
    resultBuffer[resultBufferOffset + 14] = z * b23;
    resultBuffer[resultBufferOffset + 15] = w * b33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/fill.ts
/**
* Fill a 4 by 4 integer buffered matrix with a given value.
*
* @param matrixBuffer - Buffer that contains the matrix to fill.
* @param matrixBufferOffset - Offset to apply when we write into the given buffer.
* @param value - Value to set in each cell of the given matrix.
*
* @return The buffer with the updated matrix.
*/
function matrix4i_fill_fill(matrixBuffer, matrixBufferOffset, value) {
    matrixBuffer[matrixBufferOffset + 0] = value;
    matrixBuffer[matrixBufferOffset + 1] = value;
    matrixBuffer[matrixBufferOffset + 2] = value;
    matrixBuffer[matrixBufferOffset + 3] = value;
    matrixBuffer[matrixBufferOffset + 4] = value;
    matrixBuffer[matrixBufferOffset + 5] = value;
    matrixBuffer[matrixBufferOffset + 6] = value;
    matrixBuffer[matrixBufferOffset + 7] = value;
    matrixBuffer[matrixBufferOffset + 8] = value;
    matrixBuffer[matrixBufferOffset + 9] = value;
    matrixBuffer[matrixBufferOffset + 10] = value;
    matrixBuffer[matrixBufferOffset + 11] = value;
    matrixBuffer[matrixBufferOffset + 12] = value;
    matrixBuffer[matrixBufferOffset + 13] = value;
    matrixBuffer[matrixBufferOffset + 14] = value;
    matrixBuffer[matrixBufferOffset + 15] = value;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/computeComponentOfMultiplicationWithVector.ts
/**
* Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    return a00 * x + a10 * y + a20 * z + a30 * w;
}
/**
* Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    return a01 * x + a11 * y + a21 * z + a31 * w;
}
/**
* Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4i_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    return a02 * x + a12 * y + a22 * z + a32 * w;
}
/**
* Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
*
* @param matrixBuffer - Buffer that contains the left operand matrix.
* @param matrixBufferOffset - Offset to apply when we read the first buffer.
* @param x - Value of the x component of the vector to multiply.
* @param y - Value of the y component of the vector to multiply.
* @param z - Value of the z component of the vector to multiply.
* @param w - Value of the w component of the vector to multiply.
*
* @return A component of the resulting vector.
*/
function matrix4i_computeComponentOfMultiplicationWithVector_computeWComponentOfMultiplicationWithVector(matrixBuffer, matrixBufferOffset, x, y, z, w) {
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    return a03 * x + a13 * y + a23 * z + a33 * w;
}

// CONCATENATED MODULE: ./src/matrix4i/toTranslation.ts
/**
* Set the content of a 4 by 4 integer buffered matrix to the content of a 3 dimensional translation matrix.
*
* @param matrixBuffer - Buffer to write.
* @param matrixBufferOffset - Offset to apply when we write into the buffer.
* @param x - Translation to apply to the x axis.
* @param y - Translation to apply to the y axis.
* @param z - Translation to apply to the z axis.
*
* @return The buffer, updated with the content of a 3 dimensional translation matrix.
*/
function matrix4i_toTranslation_toTranslation(matrixBuffer, matrixBufferOffset, x, y, z) {
    matrixBuffer[matrixBufferOffset + 0] = 1;
    matrixBuffer[matrixBufferOffset + 1] = 0;
    matrixBuffer[matrixBufferOffset + 2] = 0;
    matrixBuffer[matrixBufferOffset + 3] = x;
    matrixBuffer[matrixBufferOffset + 4] = 0;
    matrixBuffer[matrixBufferOffset + 5] = 1;
    matrixBuffer[matrixBufferOffset + 6] = 0;
    matrixBuffer[matrixBufferOffset + 7] = y;
    matrixBuffer[matrixBufferOffset + 8] = 0;
    matrixBuffer[matrixBufferOffset + 9] = 0;
    matrixBuffer[matrixBufferOffset + 10] = 1;
    matrixBuffer[matrixBufferOffset + 11] = z;
    matrixBuffer[matrixBufferOffset + 12] = 0;
    matrixBuffer[matrixBufferOffset + 13] = 0;
    matrixBuffer[matrixBufferOffset + 14] = 0;
    matrixBuffer[matrixBufferOffset + 15] = 1;
    return matrixBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/transpose.ts
/**
* Transpose a 4 by 4 integer buffered matrix and put the result into another buffer.
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the source buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the destination buffer.
*
* @return The destination buffer, updated with the transposed matrix readed from the source buffer.
*/
function matrix4i_transpose_transpose(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = a00;
    resultBuffer[resultBufferOffset + 1] = a01;
    resultBuffer[resultBufferOffset + 2] = a02;
    resultBuffer[resultBufferOffset + 3] = a03;
    resultBuffer[resultBufferOffset + 4] = a10;
    resultBuffer[resultBufferOffset + 5] = a11;
    resultBuffer[resultBufferOffset + 6] = a12;
    resultBuffer[resultBufferOffset + 7] = a13;
    resultBuffer[resultBufferOffset + 8] = a20;
    resultBuffer[resultBufferOffset + 9] = a21;
    resultBuffer[resultBufferOffset + 10] = a22;
    resultBuffer[resultBufferOffset + 11] = a23;
    resultBuffer[resultBufferOffset + 12] = a30;
    resultBuffer[resultBufferOffset + 13] = a31;
    resultBuffer[resultBufferOffset + 14] = a32;
    resultBuffer[resultBufferOffset + 15] = a33;
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/extractScale.ts
/**
* Extract a scale from a 4 by 4 integer buffered matrix
*
* @param matrixBuffer - Buffer to read.
* @param matrixBufferOffset - Offset to apply when we read the buffer.
* @param resultBuffer - Buffer to write.
* @param resultBufferOffset - Offset to apply when we write into the result buffer.
*
* @return The result buffer updated with the content of the 4 dimensional scale vector extracted from the given matrix.
*/
function matrix4i_extractScale_extractScale(matrixBuffer, matrixBufferOffset, resultBuffer, resultBufferOffset) {
    const a00 = matrixBuffer[matrixBufferOffset + 0];
    const a10 = matrixBuffer[matrixBufferOffset + 1];
    const a20 = matrixBuffer[matrixBufferOffset + 2];
    const a30 = matrixBuffer[matrixBufferOffset + 3];
    const a01 = matrixBuffer[matrixBufferOffset + 4];
    const a11 = matrixBuffer[matrixBufferOffset + 5];
    const a21 = matrixBuffer[matrixBufferOffset + 6];
    const a31 = matrixBuffer[matrixBufferOffset + 7];
    const a02 = matrixBuffer[matrixBufferOffset + 8];
    const a12 = matrixBuffer[matrixBufferOffset + 9];
    const a22 = matrixBuffer[matrixBufferOffset + 10];
    const a32 = matrixBuffer[matrixBufferOffset + 11];
    const a03 = matrixBuffer[matrixBufferOffset + 12];
    const a13 = matrixBuffer[matrixBufferOffset + 13];
    const a23 = matrixBuffer[matrixBufferOffset + 14];
    const a33 = matrixBuffer[matrixBufferOffset + 15];
    resultBuffer[resultBufferOffset + 0] = Math.sqrt(a00 * a00 + a10 * a10 + a20 * a20 + a30 * a30) * ((a00 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 1] = Math.sqrt(a01 * a01 + a11 * a11 + a21 * a21 + a31 * a31) * ((a11 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 2] = Math.sqrt(a02 * a02 + a12 * a12 + a22 * a22 + a32 * a32) * ((a22 < 0) ? -1 : 1);
    resultBuffer[resultBufferOffset + 3] = Math.sqrt(a03 * a03 + a13 * a13 + a23 * a23 + a33 * a33) * ((a33 < 0) ? -1 : 1);
    return resultBuffer;
}

// CONCATENATED MODULE: ./src/matrix4i/index.ts




























// CONCATENATED MODULE: ./src/Matrix2d.ts

class Matrix2d_Matrix2d {
    /**
    * Create a new 2 by 2 double matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    *
    * @return A new 2 by 2 double matrix with the given initial content.
    */
    static create(a00, a10, a01, a11) {
        return new Matrix2d_Matrix2d().set(a00, a10, a01, a11);
    }
    /**
    * Wrap a Float64Array as a 2 by 2 double matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 2 by 2 double matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix2d_Matrix2d(buffer);
    }
    /**
    * Clone a Float64Array as a 2 by 2 double matrix instance and return the result.
    *
    * @param toClone - A 2 by 2 double matrix instance to clone.
    *
    * @return A new 2 by 2 double matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix2d_Matrix2d();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        return result;
    }
    /**
    * Wrap a Float64Array as a 2 by 2 matrix.
    *
    * @param [buffer = new Float64Array(4)] - A buffer to wrap.
    */
    constructor(buffer = new Float64Array(4)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 2;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 2;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 4;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[3] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[2 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[2 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a01, a11) {
        matrix2d_set_set(this._buffer, 0, a00, a10, a01, a11);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix2d_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Invert this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    invert(result = this) {
        invert_invert(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix2d_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a01, a11, result = this) {
        multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a01, a11, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a01, a11, result = this) {
        multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a01, a11, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 2 by 2 double buffered matrix with a 2 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y) {
        return computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y);
    }
    /**
    * Multiply 2 by 2 double buffered matrix with a 2 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y) {
        return computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix2d_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix2d_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, result = this) {
        scale_scale(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 2 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, result = this) {
        rotate_rotate(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, result = this) {
        translate_translate(this._buffer, 0, x, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix2d_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix2d_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y) {
        toScale_toScale(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Transform this matrix into a 2 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y) {
        toRotation_toRotation(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x) {
        toTranslation_toTranslation(this._buffer, 0, x);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix2d_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix2d_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix2f.ts

class Matrix2f_Matrix2f {
    /**
    * Create a new 2 by 2 float matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    *
    * @return A new 2 by 2 float matrix with the given initial content.
    */
    static create(a00, a10, a01, a11) {
        return new Matrix2f_Matrix2f().set(a00, a10, a01, a11);
    }
    /**
    * Wrap a Float32Array as a 2 by 2 float matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 2 by 2 float matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix2f_Matrix2f(buffer);
    }
    /**
    * Clone a Float32Array as a 2 by 2 float matrix instance and return the result.
    *
    * @param toClone - A 2 by 2 float matrix instance to clone.
    *
    * @return A new 2 by 2 float matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix2f_Matrix2f();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        return result;
    }
    /**
    * Wrap a Float32Array as a 2 by 2 matrix.
    *
    * @param [buffer = new Float32Array(4)] - A buffer to wrap.
    */
    constructor(buffer = new Float32Array(4)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 2;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 2;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 4;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[3] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[2 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[2 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a01, a11) {
        matrix2f_set_set(this._buffer, 0, a00, a10, a01, a11);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix2f_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Invert this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    invert(result = this) {
        invert(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix2f_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a01, a11, result = this) {
        multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a01, a11, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a01, a11, result = this) {
        multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a01, a11, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 2 by 2 float buffered matrix with a 2 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y) {
        return computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y);
    }
    /**
    * Multiply 2 by 2 float buffered matrix with a 2 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y) {
        return computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix2f_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix2f_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, result = this) {
        scale(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 2 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, result = this) {
        rotate(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, result = this) {
        translate(this._buffer, 0, x, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix2f_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix2f_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y) {
        toScale(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Transform this matrix into a 2 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y) {
        toRotation(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x) {
        toTranslation(this._buffer, 0, x);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix2f_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix2f_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix2i.ts

class Matrix2i_Matrix2i {
    /**
    * Create a new 2 by 2 integer matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    *
    * @return A new 2 by 2 integer matrix with the given initial content.
    */
    static create(a00, a10, a01, a11) {
        return new Matrix2i_Matrix2i().set(a00, a10, a01, a11);
    }
    /**
    * Wrap a Int32Array as a 2 by 2 integer matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 2 by 2 integer matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix2i_Matrix2i(buffer);
    }
    /**
    * Clone a Int32Array as a 2 by 2 integer matrix instance and return the result.
    *
    * @param toClone - A 2 by 2 integer matrix instance to clone.
    *
    * @return A new 2 by 2 integer matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix2i_Matrix2i();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        return result;
    }
    /**
    * Wrap a Int32Array as a 2 by 2 matrix.
    *
    * @param [buffer = new Int32Array(4)] - A buffer to wrap.
    */
    constructor(buffer = new Int32Array(4)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 2;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 2;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 4;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix2i_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[3] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[2 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[2 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a01, a11) {
        matrix2i_set_set(this._buffer, 0, a00, a10, a01, a11);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix2i_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix2i_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix2i_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix2i_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix2i_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a01, a11, result = this) {
        matrix2i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a01, a11, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a01, a11, result = this) {
        matrix2i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a01, a11, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix2i_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 2 by 2 integer buffered matrix with a 2 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y) {
        return matrix2i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y);
    }
    /**
    * Multiply 2 by 2 integer buffered matrix with a 2 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y) {
        return matrix2i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix2i_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix2i_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, result = this) {
        matrix2i_scale_scale(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 2 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, result = this) {
        matrix2i_rotate_rotate(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, result = this) {
        matrix2i_translate_translate(this._buffer, 0, x, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix2i_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix2i_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix2i_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y) {
        matrix2i_toScale_toScale(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Transform this matrix into a 2 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y) {
        matrix2i_toRotation_toRotation(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x) {
        matrix2i_toTranslation_toTranslation(this._buffer, 0, x);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix2i_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix2i_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix2i_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix2i_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix2i_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix3d.ts

class Matrix3d_Matrix3d {
    /**
    * Create a new 3 by 3 double matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    *
    * @return A new 3 by 3 double matrix with the given initial content.
    */
    static create(a00, a10, a20, a01, a11, a21, a02, a12, a22) {
        return new Matrix3d_Matrix3d().set(a00, a10, a20, a01, a11, a21, a02, a12, a22);
    }
    /**
    * Wrap a Float64Array as a 3 by 3 double matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 3 by 3 double matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix3d_Matrix3d(buffer);
    }
    /**
    * Clone a Float64Array as a 3 by 3 double matrix instance and return the result.
    *
    * @param toClone - A 3 by 3 double matrix instance to clone.
    *
    * @return A new 3 by 3 double matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix3d_Matrix3d();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a20 = toClone.a20;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        result.a21 = toClone.a21;
        result.a02 = toClone.a02;
        result.a12 = toClone.a12;
        result.a22 = toClone.a22;
        return result;
    }
    /**
    * Wrap a Float64Array as a 3 by 3 matrix.
    *
    * @param [buffer = new Float64Array(9)] - A buffer to wrap.
    */
    constructor(buffer = new Float64Array(9)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 3;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 3;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 9;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix3d_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 0.
    *
    * @return return the value of the cell at the column 2 and row 0.
    */
    get a20() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 2 and row 0.
    *
    * @param value - The new value of the cell at the column 2 and row 0.
    */
    set a20(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[4];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[4] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 1.
    *
    * @return return the value of the cell at the column 2 and row 1.
    */
    get a21() {
        return this._buffer[5];
    }
    /**
    * Update the value of the cell at the column 2 and row 1.
    *
    * @param value - The new value of the cell at the column 2 and row 1.
    */
    set a21(value) {
        this._buffer[5] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 2.
    *
    * @return return the value of the cell at the column 0 and row 2.
    */
    get a02() {
        return this._buffer[6];
    }
    /**
    * Update the value of the cell at the column 0 and row 2.
    *
    * @param value - The new value of the cell at the column 0 and row 2.
    */
    set a02(value) {
        this._buffer[6] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 2.
    *
    * @return return the value of the cell at the column 1 and row 2.
    */
    get a12() {
        return this._buffer[7];
    }
    /**
    * Update the value of the cell at the column 1 and row 2.
    *
    * @param value - The new value of the cell at the column 1 and row 2.
    */
    set a12(value) {
        this._buffer[7] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 2.
    *
    * @return return the value of the cell at the column 2 and row 2.
    */
    get a22() {
        return this._buffer[8];
    }
    /**
    * Update the value of the cell at the column 2 and row 2.
    *
    * @param value - The new value of the cell at the column 2 and row 2.
    */
    set a22(value) {
        this._buffer[8] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[3 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[3 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a20, a01, a11, a21, a02, a12, a22) {
        matrix3d_set_set(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix3d_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix3d_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix3d_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Invert this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    invert(result = this) {
        matrix3d_invert_invert(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix3d_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix3d_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a20, a01, a11, a21, a02, a12, a22, result = this) {
        matrix3d_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a20, a01, a11, a21, a02, a12, a22, result = this) {
        matrix3d_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix3d_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 3 by 3 double buffered matrix with a 3 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3d_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply 3 by 3 double buffered matrix with a 3 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3d_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply 3 by 3 double buffered matrix with a 3 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeZComponentOfMultiplicationWithVector(x, y, z) {
        return computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix3d_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix3d_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, z, result = this) {
        matrix3d_scale_scale(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, z, result = this) {
        matrix3d_rotate_rotate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, y, result = this) {
        matrix3d_translate_translate(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix3d_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix3d_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix3d_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y, z) {
        matrix3d_toScale_toScale(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y, z) {
        matrix3d_toRotation_toRotation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x, y) {
        matrix3d_toTranslation_toTranslation(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix3d_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix3d_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix3d_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
        yield this._buffer[4];
        yield this._buffer[5];
        yield this._buffer[6];
        yield this._buffer[7];
        yield this._buffer[8];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix3d_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix3d_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix3f.ts

class Matrix3f_Matrix3f {
    /**
    * Create a new 3 by 3 float matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    *
    * @return A new 3 by 3 float matrix with the given initial content.
    */
    static create(a00, a10, a20, a01, a11, a21, a02, a12, a22) {
        return new Matrix3f_Matrix3f().set(a00, a10, a20, a01, a11, a21, a02, a12, a22);
    }
    /**
    * Wrap a Float32Array as a 3 by 3 float matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 3 by 3 float matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix3f_Matrix3f(buffer);
    }
    /**
    * Clone a Float32Array as a 3 by 3 float matrix instance and return the result.
    *
    * @param toClone - A 3 by 3 float matrix instance to clone.
    *
    * @return A new 3 by 3 float matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix3f_Matrix3f();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a20 = toClone.a20;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        result.a21 = toClone.a21;
        result.a02 = toClone.a02;
        result.a12 = toClone.a12;
        result.a22 = toClone.a22;
        return result;
    }
    /**
    * Wrap a Float32Array as a 3 by 3 matrix.
    *
    * @param [buffer = new Float32Array(9)] - A buffer to wrap.
    */
    constructor(buffer = new Float32Array(9)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 3;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 3;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 9;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix3f_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 0.
    *
    * @return return the value of the cell at the column 2 and row 0.
    */
    get a20() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 2 and row 0.
    *
    * @param value - The new value of the cell at the column 2 and row 0.
    */
    set a20(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[4];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[4] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 1.
    *
    * @return return the value of the cell at the column 2 and row 1.
    */
    get a21() {
        return this._buffer[5];
    }
    /**
    * Update the value of the cell at the column 2 and row 1.
    *
    * @param value - The new value of the cell at the column 2 and row 1.
    */
    set a21(value) {
        this._buffer[5] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 2.
    *
    * @return return the value of the cell at the column 0 and row 2.
    */
    get a02() {
        return this._buffer[6];
    }
    /**
    * Update the value of the cell at the column 0 and row 2.
    *
    * @param value - The new value of the cell at the column 0 and row 2.
    */
    set a02(value) {
        this._buffer[6] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 2.
    *
    * @return return the value of the cell at the column 1 and row 2.
    */
    get a12() {
        return this._buffer[7];
    }
    /**
    * Update the value of the cell at the column 1 and row 2.
    *
    * @param value - The new value of the cell at the column 1 and row 2.
    */
    set a12(value) {
        this._buffer[7] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 2.
    *
    * @return return the value of the cell at the column 2 and row 2.
    */
    get a22() {
        return this._buffer[8];
    }
    /**
    * Update the value of the cell at the column 2 and row 2.
    *
    * @param value - The new value of the cell at the column 2 and row 2.
    */
    set a22(value) {
        this._buffer[8] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[3 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[3 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a20, a01, a11, a21, a02, a12, a22) {
        matrix3f_set_set(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix3f_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix3f_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix3f_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Invert this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    invert(result = this) {
        matrix3f_invert_invert(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix3f_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix3f_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a20, a01, a11, a21, a02, a12, a22, result = this) {
        matrix3f_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a20, a01, a11, a21, a02, a12, a22, result = this) {
        matrix3f_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix3f_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 3 by 3 float buffered matrix with a 3 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3f_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply 3 by 3 float buffered matrix with a 3 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3f_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply 3 by 3 float buffered matrix with a 3 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeZComponentOfMultiplicationWithVector(x, y, z) {
        return computeZComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix3f_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix3f_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, z, result = this) {
        matrix3f_scale_scale(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, z, result = this) {
        matrix3f_rotate_rotate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, y, result = this) {
        matrix3f_translate_translate(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix3f_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix3f_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix3f_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y, z) {
        matrix3f_toScale_toScale(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y, z) {
        matrix3f_toRotation_toRotation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x, y) {
        matrix3f_toTranslation_toTranslation(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix3f_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix3f_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix3f_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
        yield this._buffer[4];
        yield this._buffer[5];
        yield this._buffer[6];
        yield this._buffer[7];
        yield this._buffer[8];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix3f_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix3f_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix3i.ts

class Matrix3i_Matrix3i {
    /**
    * Create a new 3 by 3 integer matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    *
    * @return A new 3 by 3 integer matrix with the given initial content.
    */
    static create(a00, a10, a20, a01, a11, a21, a02, a12, a22) {
        return new Matrix3i_Matrix3i().set(a00, a10, a20, a01, a11, a21, a02, a12, a22);
    }
    /**
    * Wrap a Int32Array as a 3 by 3 integer matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 3 by 3 integer matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix3i_Matrix3i(buffer);
    }
    /**
    * Clone a Int32Array as a 3 by 3 integer matrix instance and return the result.
    *
    * @param toClone - A 3 by 3 integer matrix instance to clone.
    *
    * @return A new 3 by 3 integer matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix3i_Matrix3i();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a20 = toClone.a20;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        result.a21 = toClone.a21;
        result.a02 = toClone.a02;
        result.a12 = toClone.a12;
        result.a22 = toClone.a22;
        return result;
    }
    /**
    * Wrap a Int32Array as a 3 by 3 matrix.
    *
    * @param [buffer = new Int32Array(9)] - A buffer to wrap.
    */
    constructor(buffer = new Int32Array(9)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 3;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 3;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 9;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix3i_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 0.
    *
    * @return return the value of the cell at the column 2 and row 0.
    */
    get a20() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 2 and row 0.
    *
    * @param value - The new value of the cell at the column 2 and row 0.
    */
    set a20(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[4];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[4] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 1.
    *
    * @return return the value of the cell at the column 2 and row 1.
    */
    get a21() {
        return this._buffer[5];
    }
    /**
    * Update the value of the cell at the column 2 and row 1.
    *
    * @param value - The new value of the cell at the column 2 and row 1.
    */
    set a21(value) {
        this._buffer[5] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 2.
    *
    * @return return the value of the cell at the column 0 and row 2.
    */
    get a02() {
        return this._buffer[6];
    }
    /**
    * Update the value of the cell at the column 0 and row 2.
    *
    * @param value - The new value of the cell at the column 0 and row 2.
    */
    set a02(value) {
        this._buffer[6] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 2.
    *
    * @return return the value of the cell at the column 1 and row 2.
    */
    get a12() {
        return this._buffer[7];
    }
    /**
    * Update the value of the cell at the column 1 and row 2.
    *
    * @param value - The new value of the cell at the column 1 and row 2.
    */
    set a12(value) {
        this._buffer[7] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 2.
    *
    * @return return the value of the cell at the column 2 and row 2.
    */
    get a22() {
        return this._buffer[8];
    }
    /**
    * Update the value of the cell at the column 2 and row 2.
    *
    * @param value - The new value of the cell at the column 2 and row 2.
    */
    set a22(value) {
        this._buffer[8] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[3 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[3 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a20, a01, a11, a21, a02, a12, a22) {
        matrix3i_set_set(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix3i_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix3i_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix3i_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix3i_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix3i_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a20, a01, a11, a21, a02, a12, a22, result = this) {
        matrix3i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a20, a01, a11, a21, a02, a12, a22, result = this) {
        matrix3i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a20, a01, a11, a21, a02, a12, a22, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix3i_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 3 by 3 integer buffered matrix with a 3 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply 3 by 3 integer buffered matrix with a 3 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply 3 by 3 integer buffered matrix with a 3 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeZComponentOfMultiplicationWithVector(x, y, z) {
        return matrix3i_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix3i_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix3i_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, z, result = this) {
        matrix3i_scale_scale(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, z, result = this) {
        matrix3i_rotate_rotate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, y, result = this) {
        matrix3i_translate_translate(this._buffer, 0, x, y, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix3i_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix3i_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix3i_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y, z) {
        matrix3i_toScale_toScale(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y, z) {
        matrix3i_toRotation_toRotation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x, y) {
        matrix3i_toTranslation_toTranslation(this._buffer, 0, x, y);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix3i_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix3i_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix3i_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
        yield this._buffer[4];
        yield this._buffer[5];
        yield this._buffer[6];
        yield this._buffer[7];
        yield this._buffer[8];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix3i_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix3i_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix4d.ts

class Matrix4d_Matrix4d {
    /**
    * Create a new 4 by 4 double matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a30 - Value of the cell at column 3 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a31 - Value of the cell at column 3 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    * @param a32 - Value of the cell at column 3 and row 2 of the matrix.
    * @param a03 - Value of the cell at column 0 and row 3 of the matrix.
    * @param a13 - Value of the cell at column 1 and row 3 of the matrix.
    * @param a23 - Value of the cell at column 2 and row 3 of the matrix.
    * @param a33 - Value of the cell at column 3 and row 3 of the matrix.
    *
    * @return A new 4 by 4 double matrix with the given initial content.
    */
    static create(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
        return new Matrix4d_Matrix4d().set(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33);
    }
    /**
    * Wrap a Float64Array as a 4 by 4 double matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 4 by 4 double matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix4d_Matrix4d(buffer);
    }
    /**
    * Clone a Float64Array as a 4 by 4 double matrix instance and return the result.
    *
    * @param toClone - A 4 by 4 double matrix instance to clone.
    *
    * @return A new 4 by 4 double matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix4d_Matrix4d();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a20 = toClone.a20;
        result.a30 = toClone.a30;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        result.a21 = toClone.a21;
        result.a31 = toClone.a31;
        result.a02 = toClone.a02;
        result.a12 = toClone.a12;
        result.a22 = toClone.a22;
        result.a32 = toClone.a32;
        result.a03 = toClone.a03;
        result.a13 = toClone.a13;
        result.a23 = toClone.a23;
        result.a33 = toClone.a33;
        return result;
    }
    /**
    * Wrap a Float64Array as a 4 by 4 matrix.
    *
    * @param [buffer = new Float64Array(16)] - A buffer to wrap.
    */
    constructor(buffer = new Float64Array(16)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 4;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 4;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 16;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix4d_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 0.
    *
    * @return return the value of the cell at the column 2 and row 0.
    */
    get a20() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 2 and row 0.
    *
    * @param value - The new value of the cell at the column 2 and row 0.
    */
    set a20(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 0.
    *
    * @return return the value of the cell at the column 3 and row 0.
    */
    get a30() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 3 and row 0.
    *
    * @param value - The new value of the cell at the column 3 and row 0.
    */
    set a30(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[4];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[4] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[5];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[5] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 1.
    *
    * @return return the value of the cell at the column 2 and row 1.
    */
    get a21() {
        return this._buffer[6];
    }
    /**
    * Update the value of the cell at the column 2 and row 1.
    *
    * @param value - The new value of the cell at the column 2 and row 1.
    */
    set a21(value) {
        this._buffer[6] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 1.
    *
    * @return return the value of the cell at the column 3 and row 1.
    */
    get a31() {
        return this._buffer[7];
    }
    /**
    * Update the value of the cell at the column 3 and row 1.
    *
    * @param value - The new value of the cell at the column 3 and row 1.
    */
    set a31(value) {
        this._buffer[7] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 2.
    *
    * @return return the value of the cell at the column 0 and row 2.
    */
    get a02() {
        return this._buffer[8];
    }
    /**
    * Update the value of the cell at the column 0 and row 2.
    *
    * @param value - The new value of the cell at the column 0 and row 2.
    */
    set a02(value) {
        this._buffer[8] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 2.
    *
    * @return return the value of the cell at the column 1 and row 2.
    */
    get a12() {
        return this._buffer[9];
    }
    /**
    * Update the value of the cell at the column 1 and row 2.
    *
    * @param value - The new value of the cell at the column 1 and row 2.
    */
    set a12(value) {
        this._buffer[9] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 2.
    *
    * @return return the value of the cell at the column 2 and row 2.
    */
    get a22() {
        return this._buffer[10];
    }
    /**
    * Update the value of the cell at the column 2 and row 2.
    *
    * @param value - The new value of the cell at the column 2 and row 2.
    */
    set a22(value) {
        this._buffer[10] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 2.
    *
    * @return return the value of the cell at the column 3 and row 2.
    */
    get a32() {
        return this._buffer[11];
    }
    /**
    * Update the value of the cell at the column 3 and row 2.
    *
    * @param value - The new value of the cell at the column 3 and row 2.
    */
    set a32(value) {
        this._buffer[11] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 3.
    *
    * @return return the value of the cell at the column 0 and row 3.
    */
    get a03() {
        return this._buffer[12];
    }
    /**
    * Update the value of the cell at the column 0 and row 3.
    *
    * @param value - The new value of the cell at the column 0 and row 3.
    */
    set a03(value) {
        this._buffer[12] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 3.
    *
    * @return return the value of the cell at the column 1 and row 3.
    */
    get a13() {
        return this._buffer[13];
    }
    /**
    * Update the value of the cell at the column 1 and row 3.
    *
    * @param value - The new value of the cell at the column 1 and row 3.
    */
    set a13(value) {
        this._buffer[13] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 3.
    *
    * @return return the value of the cell at the column 2 and row 3.
    */
    get a23() {
        return this._buffer[14];
    }
    /**
    * Update the value of the cell at the column 2 and row 3.
    *
    * @param value - The new value of the cell at the column 2 and row 3.
    */
    set a23(value) {
        this._buffer[14] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 3.
    *
    * @return return the value of the cell at the column 3 and row 3.
    */
    get a33() {
        return this._buffer[15];
    }
    /**
    * Update the value of the cell at the column 3 and row 3.
    *
    * @param value - The new value of the cell at the column 3 and row 3.
    */
    set a33(value) {
        this._buffer[15] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[4 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[4 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a30 - Value of the cell at column 3 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a31 - Value of the cell at column 3 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    * @param a32 - Value of the cell at column 3 and row 2 of the matrix.
    * @param a03 - Value of the cell at column 0 and row 3 of the matrix.
    * @param a13 - Value of the cell at column 1 and row 3 of the matrix.
    * @param a23 - Value of the cell at column 2 and row 3 of the matrix.
    * @param a33 - Value of the cell at column 3 and row 3 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
        matrix4d_set_set(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix4d_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix4d_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix4d_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Invert this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    invert(result = this) {
        matrix4d_invert_invert(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix4d_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix4d_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a30 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a31 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    * @param a32 - Value of the cell of the column  and row  of the static matrix.
    * @param a03 - Value of the cell of the column  and row  of the static matrix.
    * @param a13 - Value of the cell of the column  and row  of the static matrix.
    * @param a23 - Value of the cell of the column  and row  of the static matrix.
    * @param a33 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result = this) {
        matrix4d_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a30 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a31 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    * @param a32 - Value of the cell of the column  and row  of the static matrix.
    * @param a03 - Value of the cell of the column  and row  of the static matrix.
    * @param a13 - Value of the cell of the column  and row  of the static matrix.
    * @param a23 - Value of the cell of the column  and row  of the static matrix.
    * @param a33 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result = this) {
        matrix4d_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix4d_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4d_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4d_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeZComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4d_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 double buffered matrix with a 4 double vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeWComponentOfMultiplicationWithVector(x, y, z, w) {
        return computeComponentOfMultiplicationWithVector_computeWComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix4d_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix4d_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param w - Scale factor of the w axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, z, w, result = this) {
        matrix4d_scale_scale(this._buffer, 0, x, y, z, w, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, z, result = this) {
        matrix4d_rotate_rotate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param z - Translation to apply to the z axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, y, z, result = this) {
        matrix4d_translate_translate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix4d_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix4d_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix4d_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param w - Scale factor of the w axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y, z, w) {
        matrix4d_toScale_toScale(this._buffer, 0, x, y, z, w);
        return this;
    }
    /**
    * Transform this matrix into a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y, z) {
        matrix4d_toRotation_toRotation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param z - Translation to apply to the z axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x, y, z) {
        matrix4d_toTranslation_toTranslation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix4d_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix4d_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix4d_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
        yield this._buffer[4];
        yield this._buffer[5];
        yield this._buffer[6];
        yield this._buffer[7];
        yield this._buffer[8];
        yield this._buffer[9];
        yield this._buffer[10];
        yield this._buffer[11];
        yield this._buffer[12];
        yield this._buffer[13];
        yield this._buffer[14];
        yield this._buffer[15];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix4d_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix4d_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix4f.ts

class Matrix4f_Matrix4f {
    /**
    * Create a new 4 by 4 float matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a30 - Value of the cell at column 3 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a31 - Value of the cell at column 3 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    * @param a32 - Value of the cell at column 3 and row 2 of the matrix.
    * @param a03 - Value of the cell at column 0 and row 3 of the matrix.
    * @param a13 - Value of the cell at column 1 and row 3 of the matrix.
    * @param a23 - Value of the cell at column 2 and row 3 of the matrix.
    * @param a33 - Value of the cell at column 3 and row 3 of the matrix.
    *
    * @return A new 4 by 4 float matrix with the given initial content.
    */
    static create(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
        return new Matrix4f_Matrix4f().set(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33);
    }
    /**
    * Wrap a Float32Array as a 4 by 4 float matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 4 by 4 float matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix4f_Matrix4f(buffer);
    }
    /**
    * Clone a Float32Array as a 4 by 4 float matrix instance and return the result.
    *
    * @param toClone - A 4 by 4 float matrix instance to clone.
    *
    * @return A new 4 by 4 float matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix4f_Matrix4f();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a20 = toClone.a20;
        result.a30 = toClone.a30;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        result.a21 = toClone.a21;
        result.a31 = toClone.a31;
        result.a02 = toClone.a02;
        result.a12 = toClone.a12;
        result.a22 = toClone.a22;
        result.a32 = toClone.a32;
        result.a03 = toClone.a03;
        result.a13 = toClone.a13;
        result.a23 = toClone.a23;
        result.a33 = toClone.a33;
        return result;
    }
    /**
    * Wrap a Float32Array as a 4 by 4 matrix.
    *
    * @param [buffer = new Float32Array(16)] - A buffer to wrap.
    */
    constructor(buffer = new Float32Array(16)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 4;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 4;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 16;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix4f_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 0.
    *
    * @return return the value of the cell at the column 2 and row 0.
    */
    get a20() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 2 and row 0.
    *
    * @param value - The new value of the cell at the column 2 and row 0.
    */
    set a20(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 0.
    *
    * @return return the value of the cell at the column 3 and row 0.
    */
    get a30() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 3 and row 0.
    *
    * @param value - The new value of the cell at the column 3 and row 0.
    */
    set a30(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[4];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[4] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[5];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[5] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 1.
    *
    * @return return the value of the cell at the column 2 and row 1.
    */
    get a21() {
        return this._buffer[6];
    }
    /**
    * Update the value of the cell at the column 2 and row 1.
    *
    * @param value - The new value of the cell at the column 2 and row 1.
    */
    set a21(value) {
        this._buffer[6] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 1.
    *
    * @return return the value of the cell at the column 3 and row 1.
    */
    get a31() {
        return this._buffer[7];
    }
    /**
    * Update the value of the cell at the column 3 and row 1.
    *
    * @param value - The new value of the cell at the column 3 and row 1.
    */
    set a31(value) {
        this._buffer[7] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 2.
    *
    * @return return the value of the cell at the column 0 and row 2.
    */
    get a02() {
        return this._buffer[8];
    }
    /**
    * Update the value of the cell at the column 0 and row 2.
    *
    * @param value - The new value of the cell at the column 0 and row 2.
    */
    set a02(value) {
        this._buffer[8] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 2.
    *
    * @return return the value of the cell at the column 1 and row 2.
    */
    get a12() {
        return this._buffer[9];
    }
    /**
    * Update the value of the cell at the column 1 and row 2.
    *
    * @param value - The new value of the cell at the column 1 and row 2.
    */
    set a12(value) {
        this._buffer[9] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 2.
    *
    * @return return the value of the cell at the column 2 and row 2.
    */
    get a22() {
        return this._buffer[10];
    }
    /**
    * Update the value of the cell at the column 2 and row 2.
    *
    * @param value - The new value of the cell at the column 2 and row 2.
    */
    set a22(value) {
        this._buffer[10] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 2.
    *
    * @return return the value of the cell at the column 3 and row 2.
    */
    get a32() {
        return this._buffer[11];
    }
    /**
    * Update the value of the cell at the column 3 and row 2.
    *
    * @param value - The new value of the cell at the column 3 and row 2.
    */
    set a32(value) {
        this._buffer[11] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 3.
    *
    * @return return the value of the cell at the column 0 and row 3.
    */
    get a03() {
        return this._buffer[12];
    }
    /**
    * Update the value of the cell at the column 0 and row 3.
    *
    * @param value - The new value of the cell at the column 0 and row 3.
    */
    set a03(value) {
        this._buffer[12] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 3.
    *
    * @return return the value of the cell at the column 1 and row 3.
    */
    get a13() {
        return this._buffer[13];
    }
    /**
    * Update the value of the cell at the column 1 and row 3.
    *
    * @param value - The new value of the cell at the column 1 and row 3.
    */
    set a13(value) {
        this._buffer[13] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 3.
    *
    * @return return the value of the cell at the column 2 and row 3.
    */
    get a23() {
        return this._buffer[14];
    }
    /**
    * Update the value of the cell at the column 2 and row 3.
    *
    * @param value - The new value of the cell at the column 2 and row 3.
    */
    set a23(value) {
        this._buffer[14] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 3.
    *
    * @return return the value of the cell at the column 3 and row 3.
    */
    get a33() {
        return this._buffer[15];
    }
    /**
    * Update the value of the cell at the column 3 and row 3.
    *
    * @param value - The new value of the cell at the column 3 and row 3.
    */
    set a33(value) {
        this._buffer[15] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[4 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[4 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a30 - Value of the cell at column 3 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a31 - Value of the cell at column 3 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    * @param a32 - Value of the cell at column 3 and row 2 of the matrix.
    * @param a03 - Value of the cell at column 0 and row 3 of the matrix.
    * @param a13 - Value of the cell at column 1 and row 3 of the matrix.
    * @param a23 - Value of the cell at column 2 and row 3 of the matrix.
    * @param a33 - Value of the cell at column 3 and row 3 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
        matrix4f_set_set(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix4f_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix4f_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix4f_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Invert this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    invert(result = this) {
        matrix4f_invert_invert(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix4f_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix4f_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a30 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a31 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    * @param a32 - Value of the cell of the column  and row  of the static matrix.
    * @param a03 - Value of the cell of the column  and row  of the static matrix.
    * @param a13 - Value of the cell of the column  and row  of the static matrix.
    * @param a23 - Value of the cell of the column  and row  of the static matrix.
    * @param a33 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result = this) {
        matrix4f_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a30 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a31 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    * @param a32 - Value of the cell of the column  and row  of the static matrix.
    * @param a03 - Value of the cell of the column  and row  of the static matrix.
    * @param a13 - Value of the cell of the column  and row  of the static matrix.
    * @param a23 - Value of the cell of the column  and row  of the static matrix.
    * @param a33 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result = this) {
        matrix4f_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix4f_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4f_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4f_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeZComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4f_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 float buffered matrix with a 4 float vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeWComponentOfMultiplicationWithVector(x, y, z, w) {
        return computeWComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix4f_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix4f_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param w - Scale factor of the w axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, z, w, result = this) {
        matrix4f_scale_scale(this._buffer, 0, x, y, z, w, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, z, result = this) {
        matrix4f_rotate_rotate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param z - Translation to apply to the z axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, y, z, result = this) {
        matrix4f_translate_translate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix4f_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix4f_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix4f_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param w - Scale factor of the w axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y, z, w) {
        matrix4f_toScale_toScale(this._buffer, 0, x, y, z, w);
        return this;
    }
    /**
    * Transform this matrix into a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y, z) {
        matrix4f_toRotation_toRotation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param z - Translation to apply to the z axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x, y, z) {
        matrix4f_toTranslation_toTranslation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix4f_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix4f_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix4f_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
        yield this._buffer[4];
        yield this._buffer[5];
        yield this._buffer[6];
        yield this._buffer[7];
        yield this._buffer[8];
        yield this._buffer[9];
        yield this._buffer[10];
        yield this._buffer[11];
        yield this._buffer[12];
        yield this._buffer[13];
        yield this._buffer[14];
        yield this._buffer[15];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix4f_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix4f_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/Matrix4i.ts

class Matrix4i_Matrix4i {
    /**
    * Create a new 4 by 4 integer matrix with initial content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a30 - Value of the cell at column 3 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a31 - Value of the cell at column 3 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    * @param a32 - Value of the cell at column 3 and row 2 of the matrix.
    * @param a03 - Value of the cell at column 0 and row 3 of the matrix.
    * @param a13 - Value of the cell at column 1 and row 3 of the matrix.
    * @param a23 - Value of the cell at column 2 and row 3 of the matrix.
    * @param a33 - Value of the cell at column 3 and row 3 of the matrix.
    *
    * @return A new 4 by 4 integer matrix with the given initial content.
    */
    static create(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
        return new Matrix4i_Matrix4i().set(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33);
    }
    /**
    * Wrap a Int32Array as a 4 by 4 integer matrix.
    *
    * @param buffer - A buffer to wrap.
    *
    * @return A new 4 by 4 integer matrix that wrap the given buffer.
    */
    static wrap(buffer) {
        return new Matrix4i_Matrix4i(buffer);
    }
    /**
    * Clone a Int32Array as a 4 by 4 integer matrix instance and return the result.
    *
    * @param toClone - A 4 by 4 integer matrix instance to clone.
    *
    * @return A new 4 by 4 integer matrix that wrap the given buffer.
    */
    static clone(toClone) {
        const result = new Matrix4i_Matrix4i();
        result.a00 = toClone.a00;
        result.a10 = toClone.a10;
        result.a20 = toClone.a20;
        result.a30 = toClone.a30;
        result.a01 = toClone.a01;
        result.a11 = toClone.a11;
        result.a21 = toClone.a21;
        result.a31 = toClone.a31;
        result.a02 = toClone.a02;
        result.a12 = toClone.a12;
        result.a22 = toClone.a22;
        result.a32 = toClone.a32;
        result.a03 = toClone.a03;
        result.a13 = toClone.a13;
        result.a23 = toClone.a23;
        result.a33 = toClone.a33;
        return result;
    }
    /**
    * Wrap a Int32Array as a 4 by 4 matrix.
    *
    * @param [buffer = new Int32Array(16)] - A buffer to wrap.
    */
    constructor(buffer = new Int32Array(16)) {
        this._buffer = buffer;
    }
    /**
    * @return The number of columns of this matrix.
    */
    get columns() {
        return 4;
    }
    /**
    * @return The number of rows of this matrix.
    */
    get rows() {
        return 4;
    }
    /**
    * @return The number of cells of this matrix.
    */
    get cells() {
        return 16;
    }
    /**
    * @return The underlying buffer of this matrix.
    */
    get buffer() {
        return this._buffer;
    }
    /**
    * @return The determinant of this matrix.
    */
    get determinant() {
        return matrix4i_determinant_determinant(this._buffer, 0);
    }
    /**
    * Return the value of the cell at the column 0 and row 0.
    *
    * @return return the value of the cell at the column 0 and row 0.
    */
    get a00() {
        return this._buffer[0];
    }
    /**
    * Update the value of the cell at the column 0 and row 0.
    *
    * @param value - The new value of the cell at the column 0 and row 0.
    */
    set a00(value) {
        this._buffer[0] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 0.
    *
    * @return return the value of the cell at the column 1 and row 0.
    */
    get a10() {
        return this._buffer[1];
    }
    /**
    * Update the value of the cell at the column 1 and row 0.
    *
    * @param value - The new value of the cell at the column 1 and row 0.
    */
    set a10(value) {
        this._buffer[1] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 0.
    *
    * @return return the value of the cell at the column 2 and row 0.
    */
    get a20() {
        return this._buffer[2];
    }
    /**
    * Update the value of the cell at the column 2 and row 0.
    *
    * @param value - The new value of the cell at the column 2 and row 0.
    */
    set a20(value) {
        this._buffer[2] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 0.
    *
    * @return return the value of the cell at the column 3 and row 0.
    */
    get a30() {
        return this._buffer[3];
    }
    /**
    * Update the value of the cell at the column 3 and row 0.
    *
    * @param value - The new value of the cell at the column 3 and row 0.
    */
    set a30(value) {
        this._buffer[3] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 1.
    *
    * @return return the value of the cell at the column 0 and row 1.
    */
    get a01() {
        return this._buffer[4];
    }
    /**
    * Update the value of the cell at the column 0 and row 1.
    *
    * @param value - The new value of the cell at the column 0 and row 1.
    */
    set a01(value) {
        this._buffer[4] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 1.
    *
    * @return return the value of the cell at the column 1 and row 1.
    */
    get a11() {
        return this._buffer[5];
    }
    /**
    * Update the value of the cell at the column 1 and row 1.
    *
    * @param value - The new value of the cell at the column 1 and row 1.
    */
    set a11(value) {
        this._buffer[5] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 1.
    *
    * @return return the value of the cell at the column 2 and row 1.
    */
    get a21() {
        return this._buffer[6];
    }
    /**
    * Update the value of the cell at the column 2 and row 1.
    *
    * @param value - The new value of the cell at the column 2 and row 1.
    */
    set a21(value) {
        this._buffer[6] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 1.
    *
    * @return return the value of the cell at the column 3 and row 1.
    */
    get a31() {
        return this._buffer[7];
    }
    /**
    * Update the value of the cell at the column 3 and row 1.
    *
    * @param value - The new value of the cell at the column 3 and row 1.
    */
    set a31(value) {
        this._buffer[7] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 2.
    *
    * @return return the value of the cell at the column 0 and row 2.
    */
    get a02() {
        return this._buffer[8];
    }
    /**
    * Update the value of the cell at the column 0 and row 2.
    *
    * @param value - The new value of the cell at the column 0 and row 2.
    */
    set a02(value) {
        this._buffer[8] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 2.
    *
    * @return return the value of the cell at the column 1 and row 2.
    */
    get a12() {
        return this._buffer[9];
    }
    /**
    * Update the value of the cell at the column 1 and row 2.
    *
    * @param value - The new value of the cell at the column 1 and row 2.
    */
    set a12(value) {
        this._buffer[9] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 2.
    *
    * @return return the value of the cell at the column 2 and row 2.
    */
    get a22() {
        return this._buffer[10];
    }
    /**
    * Update the value of the cell at the column 2 and row 2.
    *
    * @param value - The new value of the cell at the column 2 and row 2.
    */
    set a22(value) {
        this._buffer[10] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 2.
    *
    * @return return the value of the cell at the column 3 and row 2.
    */
    get a32() {
        return this._buffer[11];
    }
    /**
    * Update the value of the cell at the column 3 and row 2.
    *
    * @param value - The new value of the cell at the column 3 and row 2.
    */
    set a32(value) {
        this._buffer[11] = value;
    }
    /**
    * Return the value of the cell at the column 0 and row 3.
    *
    * @return return the value of the cell at the column 0 and row 3.
    */
    get a03() {
        return this._buffer[12];
    }
    /**
    * Update the value of the cell at the column 0 and row 3.
    *
    * @param value - The new value of the cell at the column 0 and row 3.
    */
    set a03(value) {
        this._buffer[12] = value;
    }
    /**
    * Return the value of the cell at the column 1 and row 3.
    *
    * @return return the value of the cell at the column 1 and row 3.
    */
    get a13() {
        return this._buffer[13];
    }
    /**
    * Update the value of the cell at the column 1 and row 3.
    *
    * @param value - The new value of the cell at the column 1 and row 3.
    */
    set a13(value) {
        this._buffer[13] = value;
    }
    /**
    * Return the value of the cell at the column 2 and row 3.
    *
    * @return return the value of the cell at the column 2 and row 3.
    */
    get a23() {
        return this._buffer[14];
    }
    /**
    * Update the value of the cell at the column 2 and row 3.
    *
    * @param value - The new value of the cell at the column 2 and row 3.
    */
    set a23(value) {
        this._buffer[14] = value;
    }
    /**
    * Return the value of the cell at the column 3 and row 3.
    *
    * @return return the value of the cell at the column 3 and row 3.
    */
    get a33() {
        return this._buffer[15];
    }
    /**
    * Update the value of the cell at the column 3 and row 3.
    *
    * @param value - The new value of the cell at the column 3 and row 3.
    */
    set a33(value) {
        this._buffer[15] = value;
    }
    /**
    * Set the content of a cell of this matrix.
    *
    * @param column - Column of the cell to set.
    * @param row - Row of the cell to set.
    * @param value - Value to set.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    setCell(column, row, value) {
        this._buffer[4 * row + column] = value;
        return this;
    }
    /**
    * Get the content of a cell of this matrix.
    *
    * @param column - Column of the cell to get.
    * @param row - Row of the cell to get.
    *
    * @return The value of the given cell.
    */
    getCell(column, row) {
        return this._buffer[4 * row + column];
    }
    /**
    * Set this matrix content.
    *
    * @param a00 - Value of the cell at column 0 and row 0 of the matrix.
    * @param a10 - Value of the cell at column 1 and row 0 of the matrix.
    * @param a20 - Value of the cell at column 2 and row 0 of the matrix.
    * @param a30 - Value of the cell at column 3 and row 0 of the matrix.
    * @param a01 - Value of the cell at column 0 and row 1 of the matrix.
    * @param a11 - Value of the cell at column 1 and row 1 of the matrix.
    * @param a21 - Value of the cell at column 2 and row 1 of the matrix.
    * @param a31 - Value of the cell at column 3 and row 1 of the matrix.
    * @param a02 - Value of the cell at column 0 and row 2 of the matrix.
    * @param a12 - Value of the cell at column 1 and row 2 of the matrix.
    * @param a22 - Value of the cell at column 2 and row 2 of the matrix.
    * @param a32 - Value of the cell at column 3 and row 2 of the matrix.
    * @param a03 - Value of the cell at column 0 and row 3 of the matrix.
    * @param a13 - Value of the cell at column 1 and row 3 of the matrix.
    * @param a23 - Value of the cell at column 2 and row 3 of the matrix.
    * @param a33 - Value of the cell at column 3 and row 3 of the matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    set(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {
        matrix4i_set_set(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33);
        return this;
    }
    /**
    * Copy another matrix content.
    *
    * @param toCopy - Matrix instance to copy.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    copy(toCopy) {
        matrix4i_copy_copy(toCopy.buffer, 0, this._buffer, 0);
        return this;
    }
    /**
    * Fill this matrix with a particular value.
    *
    * @param value - Value to use for filling this matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    fill(value) {
        matrix4i_fill_fill(this._buffer, 0, value);
        return this;
    }
    /**
    * Transpose this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    transpose(result = this) {
        matrix4i_transpose_transpose(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Negate this matrix.
    *
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    negate(result = this) {
        matrix4i_negate_negate(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with another one.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithMatrix(left, result = this) {
        matrix4i_multiplyWithMatrix_multiplyWithMatrix(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as right operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a30 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a31 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    * @param a32 - Value of the cell of the column  and row  of the static matrix.
    * @param a03 - Value of the cell of the column  and row  of the static matrix.
    * @param a13 - Value of the cell of the column  and row  of the static matrix.
    * @param a23 - Value of the cell of the column  and row  of the static matrix.
    * @param a33 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsRightOperand(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result = this) {
        matrix4i_multiplyWithStaticMatrixAsRightOperand_multiplyWithStaticMatrixAsRightOperand(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a static one, this matrix will be used as a left operand.
    *
    * @param a00 - Value of the cell of the column  and row  of the static matrix.
    * @param a10 - Value of the cell of the column  and row  of the static matrix.
    * @param a20 - Value of the cell of the column  and row  of the static matrix.
    * @param a30 - Value of the cell of the column  and row  of the static matrix.
    * @param a01 - Value of the cell of the column  and row  of the static matrix.
    * @param a11 - Value of the cell of the column  and row  of the static matrix.
    * @param a21 - Value of the cell of the column  and row  of the static matrix.
    * @param a31 - Value of the cell of the column  and row  of the static matrix.
    * @param a02 - Value of the cell of the column  and row  of the static matrix.
    * @param a12 - Value of the cell of the column  and row  of the static matrix.
    * @param a22 - Value of the cell of the column  and row  of the static matrix.
    * @param a32 - Value of the cell of the column  and row  of the static matrix.
    * @param a03 - Value of the cell of the column  and row  of the static matrix.
    * @param a13 - Value of the cell of the column  and row  of the static matrix.
    * @param a23 - Value of the cell of the column  and row  of the static matrix.
    * @param a33 - Value of the cell of the column  and row  of the static matrix.
    
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithStaticMatrixAsLeftOperand(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result = this) {
        matrix4i_multiplyWithStaticMatrixAsLeftOperand_multiplyWithStaticMatrixAsLeftOperand(this._buffer, 0, a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a vector.
    *
    * @param left - Left operand vector.
    * @param [result = left] - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithVector(left, result = left) {
        matrix4i_multiplyWithVector_multiplyWithVector(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeXComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4i_computeComponentOfMultiplicationWithVector_computeXComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeYComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4i_computeComponentOfMultiplicationWithVector_computeYComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeZComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4i_computeComponentOfMultiplicationWithVector_computeZComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply 4 by 4 integer buffered matrix with a 4 integer vector and return a component of the resulting vector.
    *
    * @param x - Value of the x component of the vector to multiply.
    * @param y - Value of the y component of the vector to multiply.
    * @param z - Value of the z component of the vector to multiply.
    * @param w - Value of the w component of the vector to multiply.
    *
    * @return A component of the resulting vector.
    */
    computeWComponentOfMultiplicationWithVector(x, y, z, w) {
        return matrix4i_computeComponentOfMultiplicationWithVector_computeWComponentOfMultiplicationWithVector(this._buffer, 0, x, y, z, w);
    }
    /**
    * Multiply this matrix with a scalar.
    *
    * @param scalar - Scalar to use for the multiplication.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    multiplyWithScalar(scalar, result = this) {
        matrix4i_multiplyWithScalar_multiplyWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Divide this matrix by a scalar.
    *
    * @param scalar - Scalar to use for the division.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    divideWithScalar(scalar, result = this) {
        matrix4i_divideWithScalar_divideWithScalar(this._buffer, 0, scalar, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param w - Scale factor of the w axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    scale(x, y, z, w, result = this) {
        matrix4i_scale_scale(this._buffer, 0, x, y, z, w, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    rotate(x, y, z, result = this) {
        matrix4i_rotate_rotate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Multiply this matrix with a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param z - Translation to apply to the z axis.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    translate(x, y, z, result = this) {
        matrix4i_translate_translate(this._buffer, 0, x, y, z, result.buffer, 0);
        return this;
    }
    /**
    * Add another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    add(left, result = this) {
        matrix4i_add_add(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Subtract another matrix to this matrix.
    *
    * @param left - Left operand matrix.
    * @param [result = this] - Matrix to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    subtract(left, result = this) {
        matrix4i_subtract_subtract(this._buffer, 0, left.buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into an identity matrix.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toIdentity() {
        matrix4i_toIdentity_toIdentity(this._buffer, 0);
        return this;
    }
    /**
    * Transform this matrix into a scale matrix of the same order.
    *
    * @param x - Scale factor of the x axis.
    * @param y - Scale factor of the y axis.
    * @param z - Scale factor of the z axis.
    * @param w - Scale factor of the w axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toScale(x, y, z, w) {
        matrix4i_toScale_toScale(this._buffer, 0, x, y, z, w);
        return this;
    }
    /**
    * Transform this matrix into a 3 dimensional rotation matrix.
    *
    * @param x - Rotation for the x axis in radians.
    * @param y - Rotation for the y axis in radians.
    * @param z - Rotation for the z axis in radians.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toRotation(x, y, z) {
        matrix4i_toRotation_toRotation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Transform this matrix into a translation matrix of the same order.
    *
    * @param x - Translation to apply to the x axis.
    * @param y - Translation to apply to the y axis.
    * @param z - Translation to apply to the z axis.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    toTranslation(x, y, z) {
        matrix4i_toTranslation_toTranslation(this._buffer, 0, x, y, z);
        return this;
    }
    /**
    * Extract a scale vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractScale(result) {
        matrix4i_extractScale_extractScale(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a translation vector from this matrix.
    *
    * @param result - Vector to use for writing the result of this operation.
    *
    * @return The updated instance of this matrix for chaining purpose.
    */
    extractTranslation(result) {
        matrix4i_extractTranslation_extractTranslation(this._buffer, 0, result.buffer, 0);
        return this;
    }
    /**
    * Extract a 2 dimensional rotation angle from this matrix.
    *
    * @return The result of the extraction.
    */
    extract2DRotation() {
        return matrix4i_extract2DRotation_extract2DRotation(this._buffer, 0);
    }
    /**
    * Iterate over each components of this matrix in row-major order.
    *
    * @return An iterator over each components of this matrix in row-major order.
    */
    *[Symbol.iterator]() {
        yield this._buffer[0];
        yield this._buffer[1];
        yield this._buffer[2];
        yield this._buffer[3];
        yield this._buffer[4];
        yield this._buffer[5];
        yield this._buffer[6];
        yield this._buffer[7];
        yield this._buffer[8];
        yield this._buffer[9];
        yield this._buffer[10];
        yield this._buffer[11];
        yield this._buffer[12];
        yield this._buffer[13];
        yield this._buffer[14];
        yield this._buffer[15];
    }
    /**
    * Return true if this matrix is equals to another one.
    *
    * @param other - Matrix instance to use for comparison.
    * @param [tolerance = Number.EPSILON] - Tolerance to use for the equality comparison.
    *
    * @return True if this matrix is equals to the other.
    */
    equals(other, tolerance = Number.EPSILON) {
        return matrix4i_equals_equals(this._buffer, 0, other.buffer, 0, tolerance);
    }
    /**
    * Return a string representation of this matrix.
    *
    * @return A string representation of this matrix.
    */
    toString() {
        return matrix4i_toString_toString(this._buffer, 0);
    }
}

// CONCATENATED MODULE: ./src/index.ts
/* concated harmony reexport Color */__webpack_require__.d(__webpack_exports__, "Color", function() { return color_namespaceObject; });
/* concated harmony reexport vector2d */__webpack_require__.d(__webpack_exports__, "vector2d", function() { return vector2d_namespaceObject; });
/* concated harmony reexport vector2f */__webpack_require__.d(__webpack_exports__, "vector2f", function() { return vector2f_namespaceObject; });
/* concated harmony reexport vector2i */__webpack_require__.d(__webpack_exports__, "vector2i", function() { return vector2i_namespaceObject; });
/* concated harmony reexport vector3d */__webpack_require__.d(__webpack_exports__, "vector3d", function() { return vector3d_namespaceObject; });
/* concated harmony reexport vector3f */__webpack_require__.d(__webpack_exports__, "vector3f", function() { return vector3f_namespaceObject; });
/* concated harmony reexport vector3i */__webpack_require__.d(__webpack_exports__, "vector3i", function() { return vector3i_namespaceObject; });
/* concated harmony reexport vector4d */__webpack_require__.d(__webpack_exports__, "vector4d", function() { return vector4d_namespaceObject; });
/* concated harmony reexport vector4f */__webpack_require__.d(__webpack_exports__, "vector4f", function() { return vector4f_namespaceObject; });
/* concated harmony reexport vector4i */__webpack_require__.d(__webpack_exports__, "vector4i", function() { return vector4i_namespaceObject; });
/* concated harmony reexport Vector2d */__webpack_require__.d(__webpack_exports__, "Vector2d", function() { return Vector2d_Vector2d; });
/* concated harmony reexport Vector2f */__webpack_require__.d(__webpack_exports__, "Vector2f", function() { return Vector2f_Vector2f; });
/* concated harmony reexport Vector2i */__webpack_require__.d(__webpack_exports__, "Vector2i", function() { return Vector2i_Vector2i; });
/* concated harmony reexport Vector3d */__webpack_require__.d(__webpack_exports__, "Vector3d", function() { return Vector3d_Vector3d; });
/* concated harmony reexport Vector3f */__webpack_require__.d(__webpack_exports__, "Vector3f", function() { return Vector3f_Vector3f; });
/* concated harmony reexport Vector3i */__webpack_require__.d(__webpack_exports__, "Vector3i", function() { return Vector3i_Vector3i; });
/* concated harmony reexport Vector4d */__webpack_require__.d(__webpack_exports__, "Vector4d", function() { return Vector4d_Vector4d; });
/* concated harmony reexport Vector4f */__webpack_require__.d(__webpack_exports__, "Vector4f", function() { return Vector4f_Vector4f; });
/* concated harmony reexport Vector4i */__webpack_require__.d(__webpack_exports__, "Vector4i", function() { return Vector4i_Vector4i; });
/* concated harmony reexport matrix2f */__webpack_require__.d(__webpack_exports__, "matrix2f", function() { return matrix2f_namespaceObject; });
/* concated harmony reexport matrix2d */__webpack_require__.d(__webpack_exports__, "matrix2d", function() { return matrix2d_namespaceObject; });
/* concated harmony reexport matrix2i */__webpack_require__.d(__webpack_exports__, "matrix2i", function() { return matrix2i_namespaceObject; });
/* concated harmony reexport matrix3f */__webpack_require__.d(__webpack_exports__, "matrix3f", function() { return matrix3f_namespaceObject; });
/* concated harmony reexport matrix3d */__webpack_require__.d(__webpack_exports__, "matrix3d", function() { return matrix3d_namespaceObject; });
/* concated harmony reexport matrix3i */__webpack_require__.d(__webpack_exports__, "matrix3i", function() { return matrix3i_namespaceObject; });
/* concated harmony reexport matrix4f */__webpack_require__.d(__webpack_exports__, "matrix4f", function() { return matrix4f_namespaceObject; });
/* concated harmony reexport matrix4d */__webpack_require__.d(__webpack_exports__, "matrix4d", function() { return matrix4d_namespaceObject; });
/* concated harmony reexport matrix4i */__webpack_require__.d(__webpack_exports__, "matrix4i", function() { return matrix4i_namespaceObject; });
/* concated harmony reexport Matrix2d */__webpack_require__.d(__webpack_exports__, "Matrix2d", function() { return Matrix2d_Matrix2d; });
/* concated harmony reexport Matrix2f */__webpack_require__.d(__webpack_exports__, "Matrix2f", function() { return Matrix2f_Matrix2f; });
/* concated harmony reexport Matrix2i */__webpack_require__.d(__webpack_exports__, "Matrix2i", function() { return Matrix2i_Matrix2i; });
/* concated harmony reexport Matrix3d */__webpack_require__.d(__webpack_exports__, "Matrix3d", function() { return Matrix3d_Matrix3d; });
/* concated harmony reexport Matrix3f */__webpack_require__.d(__webpack_exports__, "Matrix3f", function() { return Matrix3f_Matrix3f; });
/* concated harmony reexport Matrix3i */__webpack_require__.d(__webpack_exports__, "Matrix3i", function() { return Matrix3i_Matrix3i; });
/* concated harmony reexport Matrix4d */__webpack_require__.d(__webpack_exports__, "Matrix4d", function() { return Matrix4d_Matrix4d; });
/* concated harmony reexport Matrix4f */__webpack_require__.d(__webpack_exports__, "Matrix4f", function() { return Matrix4f_Matrix4f; });
/* concated harmony reexport Matrix4i */__webpack_require__.d(__webpack_exports__, "Matrix4i", function() { return Matrix4i_Matrix4i; });










































/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/svg.js/dist/svg.js":
/*!*****************************************!*\
  !*** ./node_modules/svg.js/dist/svg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
* svg.js - A lightweight library for manipulating and animating SVG.
* @version 2.7.1
* https://svgdotjs.github.io/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Fri Nov 30 2018 10:01:55 GMT+0100 (GMT+01:00)
*/;
(function(root, factory) {
  /* istanbul ignore next */
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){
      return factory(root, root.document)
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
}(typeof window !== "undefined" ? window : this, function(window, document) {

// Find global reference - uses 'this' by default when available,
// falls back to 'window' otherwise (for bundlers like Webpack)
var globalRef = (typeof this !== "undefined") ? this : window;

// The main wrapping element
var SVG = globalRef.SVG = function(element) {
  if (SVG.supported) {
    element = new SVG.Doc(element)

    if(!SVG.parser.draw)
      SVG.prepare()

    return element
  }
}

// Default namespaces
SVG.ns    = 'http://www.w3.org/2000/svg'
SVG.xmlns = 'http://www.w3.org/2000/xmlns/'
SVG.xlink = 'http://www.w3.org/1999/xlink'
SVG.svgjs = 'http://svgjs.com/svgjs'

// Svg support test
SVG.supported = (function() {
  return !! document.createElementNS &&
         !! document.createElementNS(SVG.ns,'svg').createSVGRect
})()

// Don't bother to continue if SVG is not supported
if (!SVG.supported) return false

// Element id sequence
SVG.did  = 1000

// Get next named element id
SVG.eid = function(name) {
  return 'Svgjs' + capitalize(name) + (SVG.did++)
}

// Method for element creation
SVG.create = function(name) {
  // create element
  var element = document.createElementNS(this.ns, name)

  // apply unique id
  element.setAttribute('id', this.eid(name))

  return element
}

// Method for extending objects
SVG.extend = function() {
  var modules, methods, key, i

  // Get list of modules
  modules = [].slice.call(arguments)

  // Get object with extensions
  methods = modules.pop()

  for (i = modules.length - 1; i >= 0; i--)
    if (modules[i])
      for (key in methods)
        modules[i].prototype[key] = methods[key]

  // Make sure SVG.Set inherits any newly added methods
  if (SVG.Set && SVG.Set.inherit)
    SVG.Set.inherit()
}

// Invent new element
SVG.invent = function(config) {
  // Create element initializer
  var initializer = typeof config.create == 'function' ?
    config.create :
    function() {
      this.constructor.call(this, SVG.create(config.create))
    }

  // Inherit prototype
  if (config.inherit)
    initializer.prototype = new config.inherit

  // Extend with methods
  if (config.extend)
    SVG.extend(initializer, config.extend)

  // Attach construct method to parent
  if (config.construct)
    SVG.extend(config.parent || SVG.Container, config.construct)

  return initializer
}

// Adopt existing svg elements
SVG.adopt = function(node) {
  // check for presence of node
  if (!node) return null

  // make sure a node isn't already adopted
  if (node.instance) return node.instance

  // initialize variables
  var element

  // adopt with element-specific settings
  if (node.nodeName == 'svg')
    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc
  else if (node.nodeName == 'linearGradient')
    element = new SVG.Gradient('linear')
  else if (node.nodeName == 'radialGradient')
    element = new SVG.Gradient('radial')
  else if (SVG[capitalize(node.nodeName)])
    element = new SVG[capitalize(node.nodeName)]
  else
    element = new SVG.Element(node)

  // ensure references
  element.type  = node.nodeName
  element.node  = node
  node.instance = element

  // SVG.Class specific preparations
  if (element instanceof SVG.Doc)
    element.namespace().defs()

  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})

  return element
}

// Initialize parsing element
SVG.prepare = function() {
  // Select document body and create invisible svg element
  var body = document.getElementsByTagName('body')[0]
    , draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0)

  // Create parser object
  SVG.parser = {
    body: body || document.documentElement
  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').attr('focusable', 'false').node
  , poly: draw.polyline().node
  , path: draw.path().node
  , native: SVG.create('svg')
  }
}

SVG.parser = {
  native: SVG.create('svg')
}

document.addEventListener('DOMContentLoaded', function() {
  if(!SVG.parser.draw)
    SVG.prepare()
}, false)

// Storage for regular expressions
SVG.regex = {
  // Parse unit value
  numberAndUnit:    /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i

  // Parse hex value
, hex:              /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i

  // Parse rgb value
, rgb:              /rgb\((\d+),(\d+),(\d+)\)/

  // Parse reference id
, reference:        /#([a-z0-9\-_]+)/i

  // splits a transformation chain
, transforms:       /\)\s*,?\s*/

  // Whitespace
, whitespace:       /\s/g

  // Test hex value
, isHex:            /^#[a-f0-9]{3,6}$/i

  // Test rgb value
, isRgb:            /^rgb\(/

  // Test css declaration
, isCss:            /[^:]+:[^;]+;?/

  // Test for blank string
, isBlank:          /^(\s+)?$/

  // Test for numeric string
, isNumber:         /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i

  // Test for percent value
, isPercent:        /^-?[\d\.]+%$/

  // Test for image url
, isImage:          /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i

  // split at whitespace and comma
, delimiter:        /[\s,]+/

  // The following regex are used to parse the d attribute of a path

  // Matches all hyphens which are not after an exponent
, hyphen:           /([^e])\-/gi

  // Replaces and tests for all path letters
, pathLetters:      /[MLHVCSQTAZ]/gi

  // yes we need this one, too
, isPathLetter:     /[MLHVCSQTAZ]/i

  // matches 0.154.23.45
, numbersWithDots:  /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi

  // matches .
, dots:             /\./g
}

SVG.utils = {
  // Map function
  map: function(array, block) {
    var i
      , il = array.length
      , result = []

    for (i = 0; i < il; i++)
      result.push(block(array[i]))

    return result
  }

  // Filter function
, filter: function(array, block) {
    var i
      , il = array.length
      , result = []

    for (i = 0; i < il; i++)
      if (block(array[i]))
        result.push(array[i])

    return result
  }

  // Degrees to radians
, radians: function(d) {
    return d % 360 * Math.PI / 180
  }

  // Radians to degrees
, degrees: function(r) {
    return r * 180 / Math.PI % 360
  }

, filterSVGElements: function(nodes) {
    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })
  }

}

SVG.defaults = {
  // Default attribute values
  attrs: {
    // fill and stroke
    'fill-opacity':     1
  , 'stroke-opacity':   1
  , 'stroke-width':     0
  , 'stroke-linejoin':  'miter'
  , 'stroke-linecap':   'butt'
  , fill:               '#000000'
  , stroke:             '#000000'
  , opacity:            1
    // position
  , x:                  0
  , y:                  0
  , cx:                 0
  , cy:                 0
    // size
  , width:              0
  , height:             0
    // radius
  , r:                  0
  , rx:                 0
  , ry:                 0
    // gradient
  , offset:             0
  , 'stop-opacity':     1
  , 'stop-color':       '#000000'
    // text
  , 'font-size':        16
  , 'font-family':      'Helvetica, Arial, sans-serif'
  , 'text-anchor':      'start'
  }

}
// Module for color convertions
SVG.Color = function(color) {
  var match

  // initialize defaults
  this.r = 0
  this.g = 0
  this.b = 0

  if(!color) return

  // parse color
  if (typeof color === 'string') {
    if (SVG.regex.isRgb.test(color)) {
      // get rgb values
      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))

      // parse numeric values
      this.r = parseInt(match[1])
      this.g = parseInt(match[2])
      this.b = parseInt(match[3])

    } else if (SVG.regex.isHex.test(color)) {
      // get hex values
      match = SVG.regex.hex.exec(fullHex(color))

      // parse numeric values
      this.r = parseInt(match[1], 16)
      this.g = parseInt(match[2], 16)
      this.b = parseInt(match[3], 16)

    }

  } else if (typeof color === 'object') {
    this.r = color.r
    this.g = color.g
    this.b = color.b

  }

}

SVG.extend(SVG.Color, {
  // Default to hex conversion
  toString: function() {
    return this.toHex()
  }
  // Build hex value
, toHex: function() {
    return '#'
      + compToHex(this.r)
      + compToHex(this.g)
      + compToHex(this.b)
  }
  // Build rgb value
, toRgb: function() {
    return 'rgb(' + [this.r, this.g, this.b].join() + ')'
  }
  // Calculate true brightness
, brightness: function() {
    return (this.r / 255 * 0.30)
         + (this.g / 255 * 0.59)
         + (this.b / 255 * 0.11)
  }
  // Make color morphable
, morph: function(color) {
    this.destination = new SVG.Color(color)

    return this
  }
  // Get morphed color at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // normalise pos
    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos

    // generate morphed color
    return new SVG.Color({
      r: ~~(this.r + (this.destination.r - this.r) * pos)
    , g: ~~(this.g + (this.destination.g - this.g) * pos)
    , b: ~~(this.b + (this.destination.b - this.b) * pos)
    })
  }

})

// Testers

// Test if given value is a color string
SVG.Color.test = function(color) {
  color += ''
  return SVG.regex.isHex.test(color)
      || SVG.regex.isRgb.test(color)
}

// Test if given value is a rgb object
SVG.Color.isRgb = function(color) {
  return color && typeof color.r == 'number'
               && typeof color.g == 'number'
               && typeof color.b == 'number'
}

// Test if given value is a color
SVG.Color.isColor = function(color) {
  return SVG.Color.isRgb(color) || SVG.Color.test(color)
}
// Module for array conversion
SVG.Array = function(array, fallback) {
  array = (array || []).valueOf()

  // if array is empty and fallback is provided, use fallback
  if (array.length == 0 && fallback)
    array = fallback.valueOf()

  // parse array
  this.value = this.parse(array)
}

SVG.extend(SVG.Array, {
  // Make array morphable
  morph: function(array) {
    this.destination = this.parse(array)

    // normalize length of arrays
    if (this.value.length != this.destination.length) {
      var lastValue       = this.value[this.value.length - 1]
        , lastDestination = this.destination[this.destination.length - 1]

      while(this.value.length > this.destination.length)
        this.destination.push(lastDestination)
      while(this.value.length < this.destination.length)
        this.value.push(lastValue)
    }

    return this
  }
  // Clean up any duplicate points
, settle: function() {
    // find all unique values
    for (var i = 0, il = this.value.length, seen = []; i < il; i++)
      if (seen.indexOf(this.value[i]) == -1)
        seen.push(this.value[i])

    // set new value
    return this.value = seen
  }
  // Get morphed array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // generate morphed array
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)

    return new SVG.Array(array)
  }
  // Convert array to string
, toString: function() {
    return this.value.join(' ')
  }
  // Real value
, valueOf: function() {
    return this.value
  }
  // Parse whitespace separated string
, parse: function(array) {
    array = array.valueOf()

    // if already is an array, no need to parse it
    if (Array.isArray(array)) return array

    return this.split(array)
  }
  // Strip unnecessary whitespace
, split: function(string) {
    return string.trim().split(SVG.regex.delimiter).map(parseFloat)
  }
  // Reverse array
, reverse: function() {
    this.value.reverse()

    return this
  }
, clone: function() {
    var clone = new this.constructor()
    clone.value = array_clone(this.value)
    return clone
  }
})
// Poly points array
SVG.PointArray = function(array, fallback) {
  SVG.Array.call(this, array, fallback || [[0,0]])
}

// Inherit from SVG.Array
SVG.PointArray.prototype = new SVG.Array
SVG.PointArray.prototype.constructor = SVG.PointArray

SVG.extend(SVG.PointArray, {
  // Convert array to string
  toString: function() {
    // convert to a poly point string
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push(this.value[i].join(','))

    return array.join(' ')
  }
  // Convert array to line object
, toLine: function() {
    return {
      x1: this.value[0][0]
    , y1: this.value[0][1]
    , x2: this.value[1][0]
    , y2: this.value[1][1]
    }
  }
  // Get morphed array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    // generate morphed point string
    for (var i = 0, il = this.value.length, array = []; i < il; i++)
      array.push([
        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos
      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos
      ])

    return new SVG.PointArray(array)
  }
  // Parse point string and flat array
, parse: function(array) {
    var points = []

    array = array.valueOf()

    // if it is an array
    if (Array.isArray(array)) {
      // and it is not flat, there is no need to parse it
      if(Array.isArray(array[0])) {
        // make sure to use a clone
        return array.map(function (el) { return el.slice() })
      } else if (array[0].x != null){
        // allow point objects to be passed
        return array.map(function (el) { return [el.x, el.y] })
      }
    } else { // Else, it is considered as a string
      // parse points
      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)
    }

    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.
    if (array.length % 2 !== 0) array.pop()

    // wrap points in two-tuples and parse points as floats
    for(var i = 0, len = array.length; i < len; i = i + 2)
      points.push([ array[i], array[i+1] ])

    return points
  }
  // Move point string
, move: function(x, y) {
    var box = this.bbox()

    // get relative offset
    x -= box.x
    y -= box.y

    // move every point
    if (!isNaN(x) && !isNaN(y))
      for (var i = this.value.length - 1; i >= 0; i--)
        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]

    return this
  }
  // Resize poly string
, size: function(width, height) {
    var i, box = this.bbox()

    // recalculate position of all points according to new size
    for (i = this.value.length - 1; i >= 0; i--) {
      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x
      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y
    }

    return this
  }
  // Get bounding box of points
, bbox: function() {
    SVG.parser.poly.setAttribute('points', this.toString())

    return SVG.parser.poly.getBBox()
  }
})

var pathHandlers = {
  M: function(c, p, p0) {
    p.x = p0.x = c[0]
    p.y = p0.y = c[1]

    return ['M', p.x, p.y]
  },
  L: function(c, p) {
    p.x = c[0]
    p.y = c[1]
    return ['L', c[0], c[1]]
  },
  H: function(c, p) {
    p.x = c[0]
    return ['H', c[0]]
  },
  V: function(c, p) {
    p.y = c[0]
    return ['V', c[0]]
  },
  C: function(c, p) {
    p.x = c[4]
    p.y = c[5]
    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]]
  },
  S: function(c, p) {
    p.x = c[2]
    p.y = c[3]
    return ['S', c[0], c[1], c[2], c[3]]
  },
  Q: function(c, p) {
    p.x = c[2]
    p.y = c[3]
    return ['Q', c[0], c[1], c[2], c[3]]
  },
  T: function(c, p) {
    p.x = c[0]
    p.y = c[1]
    return ['T', c[0], c[1]]
  },
  Z: function(c, p, p0) {
    p.x = p0.x
    p.y = p0.y
    return ['Z']
  },
  A: function(c, p) {
    p.x = c[5]
    p.y = c[6]
    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]]
  }
}

var mlhvqtcsa = 'mlhvqtcsaz'.split('')

for(var i = 0, il = mlhvqtcsa.length; i < il; ++i){
  pathHandlers[mlhvqtcsa[i]] = (function(i){
    return function(c, p, p0) {
      if(i == 'H') c[0] = c[0] + p.x
      else if(i == 'V') c[0] = c[0] + p.y
      else if(i == 'A'){
        c[5] = c[5] + p.x,
        c[6] = c[6] + p.y
      }
      else
        for(var j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j%2 ? p.y : p.x)
        }

      return pathHandlers[i](c, p, p0)
    }
  })(mlhvqtcsa[i].toUpperCase())
}

// Path points array
SVG.PathArray = function(array, fallback) {
  SVG.Array.call(this, array, fallback || [['M', 0, 0]])
}

// Inherit from SVG.Array
SVG.PathArray.prototype = new SVG.Array
SVG.PathArray.prototype.constructor = SVG.PathArray

SVG.extend(SVG.PathArray, {
  // Convert array to string
  toString: function() {
    return arrayToString(this.value)
  }
  // Move path string
, move: function(x, y) {
    // get bounding box of current situation
    var box = this.bbox()

    // get relative offset
    x -= box.x
    y -= box.y

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (var l, i = this.value.length - 1; i >= 0; i--) {
        l = this.value[i][0]

        if (l == 'M' || l == 'L' || l == 'T')  {
          this.value[i][1] += x
          this.value[i][2] += y

        } else if (l == 'H')  {
          this.value[i][1] += x

        } else if (l == 'V')  {
          this.value[i][1] += y

        } else if (l == 'C' || l == 'S' || l == 'Q')  {
          this.value[i][1] += x
          this.value[i][2] += y
          this.value[i][3] += x
          this.value[i][4] += y

          if (l == 'C')  {
            this.value[i][5] += x
            this.value[i][6] += y
          }

        } else if (l == 'A')  {
          this.value[i][6] += x
          this.value[i][7] += y
        }

      }
    }

    return this
  }
  // Resize path string
, size: function(width, height) {
    // get bounding box of current situation
    var i, l, box = this.bbox()

    // recalculate position of all points according to new size
    for (i = this.value.length - 1; i >= 0; i--) {
      l = this.value[i][0]

      if (l == 'M' || l == 'L' || l == 'T')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y

      } else if (l == 'H')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x

      } else if (l == 'V')  {
        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y

      } else if (l == 'C' || l == 'S' || l == 'Q')  {
        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x
        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y
        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x
        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y

        if (l == 'C')  {
          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x
          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y
        }

      } else if (l == 'A')  {
        // resize radii
        this.value[i][1] = (this.value[i][1] * width)  / box.width
        this.value[i][2] = (this.value[i][2] * height) / box.height

        // move position values
        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x
        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y
      }

    }

    return this
  }
  // Test if the passed path array use the same path data commands as this path array
, equalCommands: function(pathArray) {
    var i, il, equalCommands

    pathArray = new SVG.PathArray(pathArray)

    equalCommands = this.value.length === pathArray.value.length
    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {
      equalCommands = this.value[i][0] === pathArray.value[i][0]
    }

    return equalCommands
  }
  // Make path array morphable
, morph: function(pathArray) {
    pathArray = new SVG.PathArray(pathArray)

    if(this.equalCommands(pathArray)) {
      this.destination = pathArray
    } else {
      this.destination = null
    }

    return this
  }
  // Get morphed path array at given position
, at: function(pos) {
    // make sure a destination is defined
    if (!this.destination) return this

    var sourceArray = this.value
      , destinationArray = this.destination.value
      , array = [], pathArray = new SVG.PathArray()
      , i, il, j, jl

    // Animate has specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement
    for (i = 0, il = sourceArray.length; i < il; i++) {
      array[i] = [sourceArray[i][0]]
      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {
        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos
      }
      // For the two flags of the elliptical arc command, the SVG spec say:
      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
      // Elliptical arc command as an array followed by corresponding indexes:
      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
      //   0    1   2        3                 4             5      6  7
      if(array[i][0] === 'A') {
        array[i][4] = +(array[i][4] != 0)
        array[i][5] = +(array[i][5] != 0)
      }
    }

    // Directly modify the value of a path array, this is done this way for performance
    pathArray.value = array
    return pathArray
  }
  // Absolutize and parse path to array
, parse: function(array) {
    // if it's already a patharray, no need to parse it
    if (array instanceof SVG.PathArray) return array.valueOf()

    // prepare for parsing
    var i, x0, y0, s, seg, arr
      , x = 0
      , y = 0
      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7, 'Z':0 }

    if(typeof array == 'string'){

      array = array
        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers
        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen
        .trim()                                 // trim
        .split(SVG.regex.delimiter)   // split into array

    }else{
      array = array.reduce(function(prev, curr){
        return [].concat.call(prev, curr)
      }, [])
    }

    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]
    var arr = []
      , p = new SVG.Point()
      , p0 = new SVG.Point()
      , index = 0
      , len = array.length

    do{
      // Test if we have a path letter
      if(SVG.regex.isPathLetter.test(array[index])){
        s = array[index]
        ++index
      // If last letter was a move command and we got no new, it defaults to [L]ine
      }else if(s == 'M'){
        s = 'L'
      }else if(s == 'm'){
        s = 'l'
      }

      arr.push(pathHandlers[s].call(null,
          array.slice(index, (index = index + paramCnt[s.toUpperCase()])).map(parseFloat),
          p, p0
        )
      )

    }while(len > index)

    return arr

  }
  // Get bounding box of path
, bbox: function() {
    SVG.parser.path.setAttribute('d', this.toString())

    return SVG.parser.path.getBBox()
  }

})

// Module for unit convertions
SVG.Number = SVG.invent({
  // Initialize
  create: function(value, unit) {
    // initialize defaults
    this.value = 0
    this.unit  = unit || ''

    // parse value
    if (typeof value === 'number') {
      // ensure a valid numeric value
      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value

    } else if (typeof value === 'string') {
      unit = value.match(SVG.regex.numberAndUnit)

      if (unit) {
        // make value numeric
        this.value = parseFloat(unit[1])

        // normalize
        if (unit[5] == '%')
          this.value /= 100
        else if (unit[5] == 's')
          this.value *= 1000

        // store unit
        this.unit = unit[5]
      }

    } else {
      if (value instanceof SVG.Number) {
        this.value = value.valueOf()
        this.unit  = value.unit
      }
    }

  }
  // Add methods
, extend: {
    // Stringalize
    toString: function() {
      return (
        this.unit == '%' ?
          ~~(this.value * 1e8) / 1e6:
        this.unit == 's' ?
          this.value / 1e3 :
          this.value
      ) + this.unit
    }
  , toJSON: function() {
      return this.toString()
    }
  , // Convert to primitive
    valueOf: function() {
      return this.value
    }
    // Add number
  , plus: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this + number, this.unit || number.unit)
    }
    // Subtract number
  , minus: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this - number, this.unit || number.unit)
    }
    // Multiply number
  , times: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this * number, this.unit || number.unit)
    }
    // Divide number
  , divide: function(number) {
      number = new SVG.Number(number)
      return new SVG.Number(this / number, this.unit || number.unit)
    }
    // Convert to different unit
  , to: function(unit) {
      var number = new SVG.Number(this)

      if (typeof unit === 'string')
        number.unit = unit

      return number
    }
    // Make number morphable
  , morph: function(number) {
      this.destination = new SVG.Number(number)

      if(number.relative) {
        this.destination.value += this.value
      }

      return this
    }
    // Get morphed number at given position
  , at: function(pos) {
      // Make sure a destination is defined
      if (!this.destination) return this

      // Generate new morphed number
      return new SVG.Number(this.destination)
          .minus(this)
          .times(pos)
          .plus(this)
    }

  }
})


SVG.Element = SVG.invent({
  // Initialize node
  create: function(node) {
    // make stroke value accessible dynamically
    this._stroke = SVG.defaults.attrs.stroke
    this._event = null
    this._events = {}

    // initialize data object
    this.dom = {}

    // create circular reference
    if (this.node = node) {
      this.type = node.nodeName
      this.node.instance = this
      this._events = node._events || {}

      // store current attribute value
      this._stroke = node.getAttribute('stroke') || this._stroke
    }
  }

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      return this.attr('x', x)
    }
    // Move over y-axis
  , y: function(y) {
      return this.attr('y', y)
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)
    }
    // Move element to given x and y values
  , move: function(x, y) {
      return this.x(x).y(y)
    }
    // Move element by its center
  , center: function(x, y) {
      return this.cx(x).cy(y)
    }
    // Set width of element
  , width: function(width) {
      return this.attr('width', width)
    }
    // Set height of element
  , height: function(height) {
      return this.attr('height', height)
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this
        .width(new SVG.Number(p.width))
        .height(new SVG.Number(p.height))
    }
    // Clone element
  , clone: function(parent) {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom()

      // clone element and assign new id
      var clone = assignNewId(this.node.cloneNode(true))

      // insert the clone in the given parent or after myself
      if(parent) parent.add(clone)
      else this.after(clone)

      return clone
    }
    // Remove element
  , remove: function() {
      if (this.parent())
        this.parent().removeElement(this)

      return this
    }
    // Replace element
  , replace: function(element) {
      this.after(element).remove()

      return element
    }
    // Add element to given container and return self
  , addTo: function(parent) {
      return parent.put(this)
    }
    // Add element to given container and return container
  , putIn: function(parent) {
      return parent.add(this)
    }
    // Get / set id
  , id: function(id) {
      return this.attr('id', id)
    }
    // Checks whether the given point inside the bounding box of the element
  , inside: function(x, y) {
      var box = this.bbox()

      return x > box.x
          && y > box.y
          && x < box.x + box.width
          && y < box.y + box.height
    }
    // Show element
  , show: function() {
      return this.style('display', '')
    }
    // Hide element
  , hide: function() {
      return this.style('display', 'none')
    }
    // Is element visible?
  , visible: function() {
      return this.style('display') != 'none'
    }
    // Return id on string conversion
  , toString: function() {
      return this.attr('id')
    }
    // Return array of classes on the node
  , classes: function() {
      var attr = this.attr('class')

      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)
    }
    // Return true if class exists on the node, false otherwise
  , hasClass: function(name) {
      return this.classes().indexOf(name) != -1
    }
    // Add class to the node
  , addClass: function(name) {
      if (!this.hasClass(name)) {
        var array = this.classes()
        array.push(name)
        this.attr('class', array.join(' '))
      }

      return this
    }
    // Remove class from the node
  , removeClass: function(name) {
      if (this.hasClass(name)) {
        this.attr('class', this.classes().filter(function(c) {
          return c != name
        }).join(' '))
      }

      return this
    }
    // Toggle the presence of a class on the node
  , toggleClass: function(name) {
      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)
    }
    // Get referenced element form attribute value
  , reference: function(attr) {
      return SVG.get(this.attr(attr))
    }
    // Returns the parent element instance
  , parent: function(type) {
      var parent = this

      // check for parent
      if(!parent.node.parentNode) return null

      // get parent element
      parent = SVG.adopt(parent.node.parentNode)

      if(!type) return parent

      // loop trough ancestors if type is given
      while(parent && parent.node instanceof window.SVGElement){
        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent
        if(!parent.node.parentNode || parent.node.parentNode.nodeName == '#document' || parent.node.parentNode.nodeName == '#document-fragment') return null // #759, #720
        parent = SVG.adopt(parent.node.parentNode)
      }
    }
    // Get parent document
  , doc: function() {
      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)
    }
    // return array of all ancestors of given type up to the root svg
  , parents: function(type) {
      var parents = [], parent = this

      do{
        parent = parent.parent(type)
        if(!parent || !parent.node) break

        parents.push(parent)
      } while(parent.parent)

      return parents
    }
    // matches the element vs a css selector
  , matches: function(selector){
      return matches(this.node, selector)
    }
    // Returns the svg node to call native svg methods on it
  , native: function() {
      return this.node
    }
    // Import raw svg
  , svg: function(svg) {
      // create temporary holder
      var well = document.createElement('svg')

      // act as a setter if svg is given
      if (svg && this instanceof SVG.Parent) {
        // dump raw svg
        well.innerHTML = '<svg>' + svg.replace(/\n/, '').replace(/<([\w:-]+)([^<]+?)\/>/g, '<$1$2></$1>') + '</svg>'

        // transplant nodes
        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)
          this.node.appendChild(well.firstChild.firstChild)

      // otherwise act as a getter
      } else {
        // create a wrapping svg element in case of partial content
        well.appendChild(svg = document.createElement('svg'))

        // write svgjs data to the dom
        this.writeDataToDom()

        // insert a copy of this node
        svg.appendChild(this.node.cloneNode(true))

        // return target element
        return well.innerHTML.replace(/^<svg>/, '').replace(/<\/svg>$/, '')
      }

      return this
    }
  // write svgjs data to the dom
  , writeDataToDom: function() {

      // dump variables recursively
      if(this.each || this.lines){
        var fn = this.each ? this : this.lines();
        fn.each(function(){
          this.writeDataToDom()
        })
      }

      // remove previously set data
      this.node.removeAttribute('svgjs:data')

      if(Object.keys(this.dom).length)
        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428

      return this
    }
  // set given data to the elements data property
  , setData: function(o){
      this.dom = o
      return this
    }
  , is: function(obj){
      return is(this, obj)
    }
  }
})

SVG.easing = {
  '-': function(pos){return pos}
, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}
, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}
, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}
}

SVG.morph = function(pos){
  return function(from, to) {
    return new SVG.MorphObj(from, to).at(pos)
  }
}

SVG.Situation = SVG.invent({

  create: function(o){
    this.init = false
    this.reversed = false
    this.reversing = false

    this.duration = new SVG.Number(o.duration).valueOf()
    this.delay = new SVG.Number(o.delay).valueOf()

    this.start = +new Date() + this.delay
    this.finish = this.start + this.duration
    this.ease = o.ease

    // this.loop is incremented from 0 to this.loops
    // it is also incremented when in an infinite loop (when this.loops is true)
    this.loop = 0
    this.loops = false

    this.animations = {
      // functionToCall: [list of morphable objects]
      // e.g. move: [SVG.Number, SVG.Number]
    }

    this.attrs = {
      // holds all attributes which are not represented from a function svg.js provides
      // e.g. someAttr: SVG.Number
    }

    this.styles = {
      // holds all styles which should be animated
      // e.g. fill-color: SVG.Color
    }

    this.transforms = [
      // holds all transformations as transformation objects
      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]
    ]

    this.once = {
      // functions to fire at a specific position
      // e.g. "0.5": function foo(){}
    }

  }

})


SVG.FX = SVG.invent({

  create: function(element) {
    this._target = element
    this.situations = []
    this.active = false
    this.situation = null
    this.paused = false
    this.lastPos = 0
    this.pos = 0
    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)
    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1
    this.absPos = 0
    this._speed = 1
  }

, extend: {

    /**
     * sets or returns the target of this animation
     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation
     * @param ease function || string Function which should be used for easing or easing keyword
     * @param delay Number indicating the delay before the animation starts
     * @return target || this
     */
    animate: function(o, ease, delay){

      if(typeof o == 'object'){
        ease = o.ease
        delay = o.delay
        o = o.duration
      }

      var situation = new SVG.Situation({
        duration: o || 1000,
        delay: delay || 0,
        ease: SVG.easing[ease || '-'] || ease
      })

      this.queue(situation)

      return this
    }

    /**
     * sets a delay before the next element of the queue is called
     * @param delay Duration of delay in milliseconds
     * @return this.target()
     */
  , delay: function(delay){
      // The delay is performed by an empty situation with its duration
      // attribute set to the duration of the delay
      var situation = new SVG.Situation({
        duration: delay,
        delay: 0,
        ease: SVG.easing['-']
      })

      return this.queue(situation)
    }

    /**
     * sets or returns the target of this animation
     * @param null || target SVG.Element which should be set as new target
     * @return target || this
     */
  , target: function(target){
      if(target && target instanceof SVG.Element){
        this._target = target
        return this
      }

      return this._target
    }

    // returns the absolute position at a given time
  , timeToAbsPos: function(timestamp){
      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)
    }

    // returns the timestamp from a given absolute positon
  , absPosToTime: function(absPos){
      return this.situation.duration/this._speed * absPos + this.situation.start
    }

    // starts the animationloop
  , startAnimFrame: function(){
      this.stopAnimFrame()
      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))
    }

    // cancels the animationframe
  , stopAnimFrame: function(){
      window.cancelAnimationFrame(this.animationFrame)
    }

    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set
  , start: function(){
      // dont start if already started
      if(!this.active && this.situation){
        this.active = true
        this.startCurrent()
      }

      return this
    }

    // start the current situation
  , startCurrent: function(){
      this.situation.start = +new Date + this.situation.delay/this._speed
      this.situation.finish = this.situation.start + this.situation.duration/this._speed
      return this.initAnimations().step()
    }

    /**
     * adds a function / Situation to the animation queue
     * @param fn function / situation to add
     * @return this
     */
  , queue: function(fn){
      if(typeof fn == 'function' || fn instanceof SVG.Situation)
        this.situations.push(fn)

      if(!this.situation) this.situation = this.situations.shift()

      return this
    }

    /**
     * pulls next element from the queue and execute it
     * @return this
     */
  , dequeue: function(){
      // stop current animation
      this.stop()

      // get next animation from queue
      this.situation = this.situations.shift()

      if(this.situation){
        if(this.situation instanceof SVG.Situation) {
          this.start()
        } else {
          // If it is not a SVG.Situation, then it is a function, we execute it
          this.situation.call(this)
        }
      }

      return this
    }

    // updates all animations to the current state of the element
    // this is important when one property could be changed from another property
  , initAnimations: function() {
      var i, j, source
      var s = this.situation

      if(s.init) return this

      for(i in s.animations){
        source = this.target()[i]()

        if(!Array.isArray(source)) {
          source = [source]
        }

        if(!Array.isArray(s.animations[i])) {
          s.animations[i] = [s.animations[i]]
        }

        //if(s.animations[i].length > source.length) {
        //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))
        //}

        for(j = source.length; j--;) {
          // The condition is because some methods return a normal number instead
          // of a SVG.Number
          if(s.animations[i][j] instanceof SVG.Number)
            source[j] = new SVG.Number(source[j])

          s.animations[i][j] = source[j].morph(s.animations[i][j])
        }
      }

      for(i in s.attrs){
        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])
      }

      for(i in s.styles){
        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])
      }

      s.initialTransformation = this.target().matrixify()

      s.init = true
      return this
    }
  , clearQueue: function(){
      this.situations = []
      return this
    }
  , clearCurrent: function(){
      this.situation = null
      return this
    }
    /** stops the animation immediately
     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.
     * @param clearQueue A Boolean indicating whether to remove queued animation as well.
     * @return this
     */
  , stop: function(jumpToEnd, clearQueue){
      var active = this.active
      this.active = false

      if(clearQueue){
        this.clearQueue()
      }

      if(jumpToEnd && this.situation){
        // initialize the situation if it was not
        !active && this.startCurrent()
        this.atEnd()
      }

      this.stopAnimFrame()

      return this.clearCurrent()
    }

    /** resets the element to the state where the current element has started
     * @return this
     */
  , reset: function(){
      if(this.situation){
        var temp = this.situation
        this.stop()
        this.situation = temp
        this.atStart()
      }
      return this
    }

    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.
  , finish: function(){

      this.stop(true, false)

      while(this.dequeue().situation && this.stop(true, false));

      this.clearQueue().clearCurrent()

      return this
    }

    // set the internal animation pointer at the start position, before any loops, and updates the visualisation
  , atStart: function() {
      return this.at(0, true)
    }

    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation
  , atEnd: function() {
      if (this.situation.loops === true) {
        // If in a infinite loop, we end the current iteration
        this.situation.loops = this.situation.loop + 1
      }

      if(typeof this.situation.loops == 'number') {
        // If performing a finite number of loops, we go after all the loops
        return this.at(this.situation.loops, true)
      } else {
        // If no loops, we just go at the end
        return this.at(1, true)
      }
    }

    // set the internal animation pointer to the specified position and updates the visualisation
    // if isAbsPos is true, pos is treated as an absolute position
  , at: function(pos, isAbsPos){
      var durDivSpd = this.situation.duration/this._speed

      this.absPos = pos
      // If pos is not an absolute position, we convert it into one
      if (!isAbsPos) {
        if (this.situation.reversed) this.absPos = 1 - this.absPos
        this.absPos += this.situation.loop
      }

      this.situation.start = +new Date - this.absPos * durDivSpd
      this.situation.finish = this.situation.start + durDivSpd

      return this.step(true)
    }

    /**
     * sets or returns the speed of the animations
     * @param speed null || Number The new speed of the animations
     * @return Number || this
     */
  , speed: function(speed){
      if (speed === 0) return this.pause()

      if (speed) {
        this._speed = speed
        // We use an absolute position here so that speed can affect the delay before the animation
        return this.at(this.absPos, true)
      } else return this._speed
    }

    // Make loopable
  , loop: function(times, reverse) {
      var c = this.last()

      // store total loops
      c.loops = (times != null) ? times : true
      c.loop = 0

      if(reverse) c.reversing = true
      return this
    }

    // pauses the animation
  , pause: function(){
      this.paused = true
      this.stopAnimFrame()

      return this
    }

    // unpause the animation
  , play: function(){
      if(!this.paused) return this
      this.paused = false
      // We use an absolute position here so that the delay before the animation can be paused
      return this.at(this.absPos, true)
    }

    /**
     * toggle or set the direction of the animation
     * true sets direction to backwards while false sets it to forwards
     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)
     * @return this
     */
  , reverse: function(reversed){
      var c = this.last()

      if(typeof reversed == 'undefined') c.reversed = !c.reversed
      else c.reversed = reversed

      return this
    }


    /**
     * returns a float from 0-1 indicating the progress of the current animation
     * @param eased Boolean indicating whether the returned position should be eased or not
     * @return number
     */
  , progress: function(easeIt){
      return easeIt ? this.situation.ease(this.pos) : this.pos
    }

    /**
     * adds a callback function which is called when the current animation is finished
     * @param fn Function which should be executed as callback
     * @return number
     */
  , after: function(fn){
      var c = this.last()
        , wrapper = function wrapper(e){
            if(e.detail.situation == c){
              fn.call(this, c)
              this.off('finished.fx', wrapper) // prevent memory leak
            }
          }

      this.target().on('finished.fx', wrapper)

      return this._callStart()
    }

    // adds a callback which is called whenever one animation step is performed
  , during: function(fn){
      var c = this.last()
        , wrapper = function(e){
            if(e.detail.situation == c){
              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)
            }
          }

      // see above
      this.target().off('during.fx', wrapper).on('during.fx', wrapper)

      this.after(function(){
        this.off('during.fx', wrapper)
      })

      return this._callStart()
    }

    // calls after ALL animations in the queue are finished
  , afterAll: function(fn){
      var wrapper = function wrapper(e){
            fn.call(this)
            this.off('allfinished.fx', wrapper)
          }

      // see above
      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)

      return this._callStart()
    }

    // calls on every animation step for all animations
  , duringAll: function(fn){
      var wrapper = function(e){
            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)
          }

      this.target().off('during.fx', wrapper).on('during.fx', wrapper)

      this.afterAll(function(){
        this.off('during.fx', wrapper)
      })

      return this._callStart()
    }

  , last: function(){
      return this.situations.length ? this.situations[this.situations.length-1] : this.situation
    }

    // adds one property to the animations
  , add: function(method, args, type){
      this.last()[type || 'animations'][method] = args
      return this._callStart()
    }

    /** perform one step of the animation
     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time
     *  @return this
     */
  , step: function(ignoreTime){

      // convert current time to an absolute position
      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)

      // This part convert an absolute position to a position
      if(this.situation.loops !== false) {
        var absPos, absPosInt, lastLoop

        // If the absolute position is below 0, we just treat it as if it was 0
        absPos = Math.max(this.absPos, 0)
        absPosInt = Math.floor(absPos)

        if(this.situation.loops === true || absPosInt < this.situation.loops) {
          this.pos = absPos - absPosInt
          lastLoop = this.situation.loop
          this.situation.loop = absPosInt
        } else {
          this.absPos = this.situation.loops
          this.pos = 1
          // The -1 here is because we don't want to toggle reversed when all the loops have been completed
          lastLoop = this.situation.loop - 1
          this.situation.loop = this.situation.loops
        }

        if(this.situation.reversing) {
          // Toggle reversed if an odd number of loops as occured since the last call of step
          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)
        }

      } else {
        // If there are no loop, the absolute position must not be above 1
        this.absPos = Math.min(this.absPos, 1)
        this.pos = this.absPos
      }

      // while the absolute position can be below 0, the position must not be below 0
      if(this.pos < 0) this.pos = 0

      if(this.situation.reversed) this.pos = 1 - this.pos


      // apply easing
      var eased = this.situation.ease(this.pos)

      // call once-callbacks
      for(var i in this.situation.once){
        if(i > this.lastPos && i <= eased){
          this.situation.once[i].call(this.target(), this.pos, eased)
          delete this.situation.once[i]
        }
      }

      // fire during callback with position, eased position and current situation as parameter
      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})

      // the user may call stop or finish in the during callback
      // so make sure that we still have a valid situation
      if(!this.situation){
        return this
      }

      // apply the actual animation to every property
      this.eachAt()

      // do final code when situation is finished
      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){

        // stop animation callback
        this.stopAnimFrame()

        // fire finished callback with current situation as parameter
        this.target().fire('finished', {fx:this, situation: this.situation})

        if(!this.situations.length){
          this.target().fire('allfinished')

          // Recheck the length since the user may call animate in the afterAll callback
          if(!this.situations.length){
            this.target().off('.fx') // there shouldnt be any binding left, but to make sure...
            this.active = false
          }
        }

        // start next animation
        if(this.active) this.dequeue()
        else this.clearCurrent()

      }else if(!this.paused && this.active){
        // we continue animating when we are not at the end
        this.startAnimFrame()
      }

      // save last eased position for once callback triggering
      this.lastPos = eased
      return this

    }

    // calculates the step for every property and calls block with it
  , eachAt: function(){
      var i, len, at, self = this, target = this.target(), s = this.situation

      // apply animations which can be called trough a method
      for(i in s.animations){

        at = [].concat(s.animations[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target[i].apply(target, at)

      }

      // apply animation which has to be applied with attr()
      for(i in s.attrs){

        at = [i].concat(s.attrs[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target.attr.apply(target, at)

      }

      // apply animation which has to be applied with style()
      for(i in s.styles){

        at = [i].concat(s.styles[i]).map(function(el){
          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el
        })

        target.style.apply(target, at)

      }

      // animate initialTransformation which has to be chained
      if(s.transforms.length){

        // get initial initialTransformation
        at = s.initialTransformation
        for(i = 0, len = s.transforms.length; i < len; i++){

          // get next transformation in chain
          var a = s.transforms[i]

          // multiply matrix directly
          if(a instanceof SVG.Matrix){

            if(a.relative){
              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))
            }else{
              at = at.morph(a).at(s.ease(this.pos))
            }
            continue
          }

          // when transformation is absolute we have to reset the needed transformation first
          if(!a.relative)
            a.undo(at.extract())

          // and reapply it after
          at = at.multiply(a.at(s.ease(this.pos)))

        }

        // set new matrix on element
        target.matrix(at)
      }

      return this

    }


    // adds an once-callback which is called at a specific position and never again
  , once: function(pos, fn, isEased){
      var c = this.last()
      if(!isEased) pos = c.ease(pos)

      c.once[pos] = fn

      return this
    }

  , _callStart: function() {
      setTimeout(function(){this.start()}.bind(this), 0)
      return this
    }

  }

, parent: SVG.Element

  // Add method to parent elements
, construct: {
    // Get fx module or create a new one, then animate with given duration and ease
    animate: function(o, ease, delay) {
      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)
    }
  , delay: function(delay){
      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)
    }
  , stop: function(jumpToEnd, clearQueue) {
      if (this.fx)
        this.fx.stop(jumpToEnd, clearQueue)

      return this
    }
  , finish: function() {
      if (this.fx)
        this.fx.finish()

      return this
    }
    // Pause current animation
  , pause: function() {
      if (this.fx)
        this.fx.pause()

      return this
    }
    // Play paused current animation
  , play: function() {
      if (this.fx)
        this.fx.play()

      return this
    }
    // Set/Get the speed of the animations
  , speed: function(speed) {
      if (this.fx)
        if (speed == null)
          return this.fx.speed()
        else
          this.fx.speed(speed)

      return this
    }
  }

})

// MorphObj is used whenever no morphable object is given
SVG.MorphObj = SVG.invent({

  create: function(from, to){
    // prepare color for morphing
    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)
    // check if we have a list of values
    if(SVG.regex.delimiter.test(from)) {
      // prepare path for morphing
      if(SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to)
      // prepare value list for morphing
      else return new SVG.Array(from).morph(to)
    }
    // prepare number for morphing
    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)

    // prepare for plain morphing
    this.value = from
    this.destination = to
  }

, extend: {
    at: function(pos, real){
      return real < 1 ? this.value : this.destination
    },

    valueOf: function(){
      return this.value
    }
  }

})

SVG.extend(SVG.FX, {
  // Add animatable attributes
  attr: function(a, v, relative) {
    // apply attributes individually
    if (typeof a == 'object') {
      for (var key in a)
        this.attr(key, a[key])

    } else {
      this.add(a, v, 'attrs')
    }

    return this
  }
  // Add animatable styles
, style: function(s, v) {
    if (typeof s == 'object')
      for (var key in s)
        this.style(key, s[key])

    else
      this.add(s, v, 'styles')

    return this
  }
  // Animatable x-axis
, x: function(x, relative) {
    if(this.target() instanceof SVG.G){
      this.transform({x:x}, relative)
      return this
    }

    var num = new SVG.Number(x)
    num.relative = relative
    return this.add('x', num)
  }
  // Animatable y-axis
, y: function(y, relative) {
    if(this.target() instanceof SVG.G){
      this.transform({y:y}, relative)
      return this
    }

    var num = new SVG.Number(y)
    num.relative = relative
    return this.add('y', num)
  }
  // Animatable center x-axis
, cx: function(x) {
    return this.add('cx', new SVG.Number(x))
  }
  // Animatable center y-axis
, cy: function(y) {
    return this.add('cy', new SVG.Number(y))
  }
  // Add animatable move
, move: function(x, y) {
    return this.x(x).y(y)
  }
  // Add animatable center
, center: function(x, y) {
    return this.cx(x).cy(y)
  }
  // Add animatable size
, size: function(width, height) {
    if (this.target() instanceof SVG.Text) {
      // animate font size for Text elements
      this.attr('font-size', width)

    } else {
      // animate bbox based size for all other elements
      var box

      if(!width || !height){
        box = this.target().bbox()
      }

      if(!width){
        width = box.width / box.height  * height
      }

      if(!height){
        height = box.height / box.width  * width
      }

      this.add('width' , new SVG.Number(width))
          .add('height', new SVG.Number(height))

    }

    return this
  }
  // Add animatable width
, width: function(width) {
    return this.add('width', new SVG.Number(width))
  }
  // Add animatable height
, height: function(height) {
    return this.add('height', new SVG.Number(height))
  }
  // Add animatable plot
, plot: function(a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if(arguments.length == 4) {
      return this.plot([a, b, c, d])
    }

    return this.add('plot', new (this.target().morphArray)(a))
  }
  // Add leading method
, leading: function(value) {
    return this.target().leading ?
      this.add('leading', new SVG.Number(value)) :
      this
  }
  // Add animatable viewbox
, viewbox: function(x, y, width, height) {
    if (this.target() instanceof SVG.Container) {
      this.add('viewbox', new SVG.ViewBox(x, y, width, height))
    }

    return this
  }
, update: function(o) {
    if (this.target() instanceof SVG.Stop) {
      if (typeof o == 'number' || o instanceof SVG.Number) {
        return this.update({
          offset:  arguments[0]
        , color:   arguments[1]
        , opacity: arguments[2]
        })
      }

      if (o.opacity != null) this.attr('stop-opacity', o.opacity)
      if (o.color   != null) this.attr('stop-color', o.color)
      if (o.offset  != null) this.attr('offset', o.offset)
    }

    return this
  }
})

SVG.Box = SVG.invent({
  create: function(x, y, width, height) {
    if (typeof x == 'object' && !(x instanceof SVG.Element)) {
      // chromes getBoundingClientRect has no x and y property
      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)
    } else if (arguments.length == 4) {
      this.x = x
      this.y = y
      this.width = width
      this.height = height
    }

    // add center, right, bottom...
    fullBox(this)
  }
, extend: {
    // Merge rect box with another, return a new instance
    merge: function(box) {
      var b = new this.constructor()

      // merge boxes
      b.x      = Math.min(this.x, box.x)
      b.y      = Math.min(this.y, box.y)
      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x
      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y

      return fullBox(b)
    }

  , transform: function(m) {
      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p, bbox

      var pts = [
        new SVG.Point(this.x, this.y),
        new SVG.Point(this.x2, this.y),
        new SVG.Point(this.x, this.y2),
        new SVG.Point(this.x2, this.y2)
      ]

      pts.forEach(function(p) {
        p = p.transform(m)
        xMin = Math.min(xMin,p.x)
        xMax = Math.max(xMax,p.x)
        yMin = Math.min(yMin,p.y)
        yMax = Math.max(yMax,p.y)
      })

      bbox = new this.constructor()
      bbox.x = xMin
      bbox.width = xMax-xMin
      bbox.y = yMin
      bbox.height = yMax-yMin

      fullBox(bbox)

      return bbox
    }
  }
})

SVG.BBox = SVG.invent({
  // Initialize
  create: function(element) {
    SVG.Box.apply(this, [].slice.call(arguments))

    // get values if element is given
    if (element instanceof SVG.Element) {
      var box

      // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered
      try {

        if (!document.documentElement.contains){
          // This is IE - it does not support contains() for top-level SVGs
          var topParent = element.node
          while (topParent.parentNode){
            topParent = topParent.parentNode
          }
          if (topParent != document) throw new Exception('Element not in the dom')
        } else {
          // the element is NOT in the dom, throw error
          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')
        }

        // find native bbox
        box = element.node.getBBox()
      } catch(e) {
        if(element instanceof SVG.Shape){
          var clone = element.clone(SVG.parser.draw.instance).show()
          box = clone.node.getBBox()
          clone.remove()
        }else{
          box = {
            x:      element.node.clientLeft
          , y:      element.node.clientTop
          , width:  element.node.clientWidth
          , height: element.node.clientHeight
          }
        }
      }

      SVG.Box.call(this, box)
    }

  }

  // Define ancestor
, inherit: SVG.Box

  // Define Parent
, parent: SVG.Element

  // Constructor
, construct: {
    // Get bounding box
    bbox: function() {
      return new SVG.BBox(this)
    }
  }

})

SVG.BBox.prototype.constructor = SVG.BBox


SVG.extend(SVG.Element, {
  tbox: function(){
    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')
    return this.rbox(this.doc())
  }
})

SVG.RBox = SVG.invent({
  // Initialize
  create: function(element) {
    SVG.Box.apply(this, [].slice.call(arguments))

    if (element instanceof SVG.Element) {
      SVG.Box.call(this, element.node.getBoundingClientRect())
    }
  }

, inherit: SVG.Box

  // define Parent
, parent: SVG.Element

, extend: {
    addOffset: function() {
      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
      this.x += window.pageXOffset
      this.y += window.pageYOffset
      return this
    }
  }

  // Constructor
, construct: {
    // Get rect box
    rbox: function(el) {
      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())
      return new SVG.RBox(this).addOffset()
    }
  }

})

SVG.RBox.prototype.constructor = SVG.RBox

SVG.Matrix = SVG.invent({
  // Initialize
  create: function(source) {
    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])

    // ensure source as object
    source = source instanceof SVG.Element ?
      source.matrixify() :
    typeof source === 'string' ?
      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :
    arguments.length == 6 ?
      arrayToMatrix([].slice.call(arguments)) :
    Array.isArray(source) ?
      arrayToMatrix(source) :
    typeof source === 'object' ?
      source : base

    // merge source
    for (i = abcdef.length - 1; i >= 0; --i)
      this[abcdef[i]] = source[abcdef[i]] != null ?
        source[abcdef[i]] : base[abcdef[i]]
  }

  // Add methods
, extend: {
    // Extract individual transformations
    extract: function() {
      // find delta transform points
      var px    = deltaTransformPoint(this, 0, 1)
        , py    = deltaTransformPoint(this, 1, 0)
        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90

      return {
        // translation
        x:        this.e
      , y:        this.f
      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)
      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)
        // skew
      , skewX:    -skewX
      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)
        // scale
      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)
      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)
        // rotation
      , rotation: skewX
      , a: this.a
      , b: this.b
      , c: this.c
      , d: this.d
      , e: this.e
      , f: this.f
      , matrix: new SVG.Matrix(this)
      }
    }
    // Clone matrix
  , clone: function() {
      return new SVG.Matrix(this)
    }
    // Morph one matrix into another
  , morph: function(matrix) {
      // store new destination
      this.destination = new SVG.Matrix(matrix)

      return this
    }
    // Get morphed matrix at a given position
  , at: function(pos) {
      // make sure a destination is defined
      if (!this.destination) return this

      // calculate morphed matrix at a given position
      var matrix = new SVG.Matrix({
        a: this.a + (this.destination.a - this.a) * pos
      , b: this.b + (this.destination.b - this.b) * pos
      , c: this.c + (this.destination.c - this.c) * pos
      , d: this.d + (this.destination.d - this.d) * pos
      , e: this.e + (this.destination.e - this.e) * pos
      , f: this.f + (this.destination.f - this.f) * pos
      })

      return matrix
    }
    // Multiplies by given matrix
  , multiply: function(matrix) {
      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))
    }
    // Inverses matrix
  , inverse: function() {
      return new SVG.Matrix(this.native().inverse())
    }
    // Translate matrix
  , translate: function(x, y) {
      return new SVG.Matrix(this.native().translate(x || 0, y || 0))
    }
    // Scale matrix
  , scale: function(x, y, cx, cy) {
      // support uniformal scale
      if (arguments.length == 1) {
        y = x
      } else if (arguments.length == 3) {
        cy = cx
        cx = y
        y = x
      }

      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))
    }
    // Rotate matrix
  , rotate: function(r, cx, cy) {
      // convert degrees to radians
      r = SVG.utils.radians(r)

      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))
    }
    // Flip matrix on x or y, at a given offset
  , flip: function(a, o) {
      return a == 'x' ?
          this.scale(-1, 1, o, 0) :
        a == 'y' ?
          this.scale(1, -1, 0, o) :
          this.scale(-1, -1, a, o != null ? o : a)
    }
    // Skew
  , skew: function(x, y, cx, cy) {
      // support uniformal skew
      if (arguments.length == 1) {
        y = x
      } else if (arguments.length == 3) {
        cy = cx
        cx = y
        y = x
      }

      // convert degrees to radians
      x = SVG.utils.radians(x)
      y = SVG.utils.radians(y)

      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))
    }
    // SkewX
  , skewX: function(x, cx, cy) {
      return this.skew(x, 0, cx, cy)
    }
    // SkewY
  , skewY: function(y, cx, cy) {
      return this.skew(0, y, cx, cy)
    }
    // Transform around a center point
  , around: function(cx, cy, matrix) {
      return this
        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))
        .multiply(matrix)
        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))
    }
    // Convert to native SVGMatrix
  , native: function() {
      // create new matrix
      var matrix = SVG.parser.native.createSVGMatrix()

      // update with current values
      for (var i = abcdef.length - 1; i >= 0; i--)
        matrix[abcdef[i]] = this[abcdef[i]]

      return matrix
    }
    // Convert matrix to string
  , toString: function() {
      // Construct the matrix directly, avoid values that are too small
      return 'matrix(' + float32String(this.a) + ',' + float32String(this.b)
        + ',' + float32String(this.c) + ',' + float32String(this.d)
        + ',' + float32String(this.e) + ',' + float32String(this.f)
        + ')'
    }
  }

  // Define parent
, parent: SVG.Element

  // Add parent method
, construct: {
    // Get current matrix
    ctm: function() {
      return new SVG.Matrix(this.node.getCTM())
    },
    // Get current screen matrix
    screenCTM: function() {
      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
         This is needed because FF does not return the transformation matrix
         for the inner coordinate system when getScreenCTM() is called on nested svgs.
         However all other Browsers do that */
      if(this instanceof SVG.Nested) {
        var rect = this.rect(1,1)
        var m = rect.node.getScreenCTM()
        rect.remove()
        return new SVG.Matrix(m)
      }
      return new SVG.Matrix(this.node.getScreenCTM())
    }

  }

})

SVG.Point = SVG.invent({
  // Initialize
  create: function(x,y) {
    var i, source, base = {x:0, y:0}

    // ensure source as object
    source = Array.isArray(x) ?
      {x:x[0], y:x[1]} :
    typeof x === 'object' ?
      {x:x.x, y:x.y} :
    x != null ?
      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value

    // merge source
    this.x = source.x
    this.y = source.y
  }

  // Add methods
, extend: {
    // Clone point
    clone: function() {
      return new SVG.Point(this)
    }
    // Morph one point into another
  , morph: function(x, y) {
      // store new destination
      this.destination = new SVG.Point(x, y)

      return this
    }
    // Get morphed point at a given position
  , at: function(pos) {
      // make sure a destination is defined
      if (!this.destination) return this

      // calculate morphed matrix at a given position
      var point = new SVG.Point({
        x: this.x + (this.destination.x - this.x) * pos
      , y: this.y + (this.destination.y - this.y) * pos
      })

      return point
    }
    // Convert to native SVGPoint
  , native: function() {
      // create new point
      var point = SVG.parser.native.createSVGPoint()

      // update with current values
      point.x = this.x
      point.y = this.y

      return point
    }
    // transform point with matrix
  , transform: function(matrix) {
      return new SVG.Point(this.native().matrixTransform(matrix.native()))
    }

  }

})

SVG.extend(SVG.Element, {

  // Get point
  point: function(x, y) {
    return new SVG.Point(x,y).transform(this.screenCTM().inverse());
  }

})

SVG.extend(SVG.Element, {
  // Set svg element attribute
  attr: function(a, v, n) {
    // act as full getter
    if (a == null) {
      // get an object of attributes
      a = {}
      v = this.node.attributes
      for (n = v.length - 1; n >= 0; n--)
        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue

      return a

    } else if (typeof a == 'object') {
      // apply every attribute individually if an object is passed
      for (v in a) this.attr(v, a[v])

    } else if (v === null) {
        // remove value
        this.node.removeAttribute(a)

    } else if (v == null) {
      // act as a getter if the first and only argument is not an object
      v = this.node.getAttribute(a)
      return v == null ?
        SVG.defaults.attrs[a] :
      SVG.regex.isNumber.test(v) ?
        parseFloat(v) : v

    } else {
      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0
      if (a == 'stroke-width')
        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)
      else if (a == 'stroke')
        this._stroke = v

      // convert image fill and stroke to patterns
      if (a == 'fill' || a == 'stroke') {
        if (SVG.regex.isImage.test(v))
          v = this.doc().defs().image(v, 0, 0)

        if (v instanceof SVG.Image)
          v = this.doc().defs().pattern(0, 0, function() {
            this.add(v)
          })
      }

      // ensure correct numeric values (also accepts NaN and Infinity)
      if (typeof v === 'number')
        v = new SVG.Number(v)

      // ensure full hex color
      else if (SVG.Color.isColor(v))
        v = new SVG.Color(v)

      // parse array values
      else if (Array.isArray(v))
        v = new SVG.Array(v)

      // if the passed attribute is leading...
      if (a == 'leading') {
        // ... call the leading method instead
        if (this.leading)
          this.leading(v)
      } else {
        // set given attribute on node
        typeof n === 'string' ?
          this.node.setAttributeNS(n, a, v.toString()) :
          this.node.setAttribute(a, v.toString())
      }

      // rebuild if required
      if (this.rebuild && (a == 'font-size' || a == 'x'))
        this.rebuild(a, v)
    }

    return this
  }
})
SVG.extend(SVG.Element, {
  // Add transformations
  transform: function(o, relative) {
    // get target in case of the fx module, otherwise reference this
    var target = this
      , matrix, bbox

    // act as a getter
    if (typeof o !== 'object') {
      // get current matrix
      matrix = new SVG.Matrix(target).extract()

      return typeof o === 'string' ? matrix[o] : matrix
    }

    // get current matrix
    matrix = new SVG.Matrix(target)

    // ensure relative flag
    relative = !!relative || !!o.relative

    // act on matrix
    if (o.a != null) {
      matrix = relative ?
        // relative
        matrix.multiply(new SVG.Matrix(o)) :
        // absolute
        new SVG.Matrix(o)

    // act on rotation
    } else if (o.rotation != null) {
      // ensure centre point
      ensureCentre(o, target)

      // apply transformation
      matrix = relative ?
        // relative
        matrix.rotate(o.rotation, o.cx, o.cy) :
        // absolute
        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)

    // act on scale
    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure scale values on both axes
      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1
      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1

      if (!relative) {
        // absolute; multiply inversed values
        var e = matrix.extract()
        o.scaleX = o.scaleX * 1 / e.scaleX
        o.scaleY = o.scaleY * 1 / e.scaleY
      }

      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)

    // act on skew
    } else if (o.skew != null || o.skewX != null || o.skewY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure skew values on both axes
      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0
      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0

      if (!relative) {
        // absolute; reset skew values
        var e = matrix.extract()
        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())
      }

      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)

    // act on flip
    } else if (o.flip) {
      if(o.flip == 'x' || o.flip == 'y') {
        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset
      } else {
        if(o.offset == null) {
          bbox = target.bbox()
          o.flip = bbox.cx
          o.offset = bbox.cy
        } else {
          o.flip = o.offset
        }
      }

      matrix = new SVG.Matrix().flip(o.flip, o.offset)

    // act on translate
    } else if (o.x != null || o.y != null) {
      if (relative) {
        // relative
        matrix = matrix.translate(o.x, o.y)
      } else {
        // absolute
        if (o.x != null) matrix.e = o.x
        if (o.y != null) matrix.f = o.y
      }
    }

    return this.attr('transform', matrix)
  }
})

SVG.extend(SVG.FX, {
  transform: function(o, relative) {
    // get target in case of the fx module, otherwise reference this
    var target = this.target()
      , matrix, bbox

    // act as a getter
    if (typeof o !== 'object') {
      // get current matrix
      matrix = new SVG.Matrix(target).extract()

      return typeof o === 'string' ? matrix[o] : matrix
    }

    // ensure relative flag
    relative = !!relative || !!o.relative

    // act on matrix
    if (o.a != null) {
      matrix = new SVG.Matrix(o)

    // act on rotation
    } else if (o.rotation != null) {
      // ensure centre point
      ensureCentre(o, target)

      // apply transformation
      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)

    // act on scale
    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure scale values on both axes
      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1
      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1

      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)

    // act on skew
    } else if (o.skewX != null || o.skewY != null) {
      // ensure centre point
      ensureCentre(o, target)

      // ensure skew values on both axes
      o.skewX = o.skewX != null ? o.skewX : 0
      o.skewY = o.skewY != null ? o.skewY : 0

      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)

    // act on flip
    } else if (o.flip) {
      if(o.flip == 'x' || o.flip == 'y') {
        o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset
      } else {
        if(o.offset == null) {
          bbox = target.bbox()
          o.flip = bbox.cx
          o.offset = bbox.cy
        } else {
          o.flip = o.offset
        }
      }

      matrix = new SVG.Matrix().flip(o.flip, o.offset)

    // act on translate
    } else if (o.x != null || o.y != null) {
      matrix = new SVG.Translate(o.x, o.y)
    }

    if(!matrix) return this

    matrix.relative = relative

    this.last().transforms.push(matrix)

    return this._callStart()
  }
})

SVG.extend(SVG.Element, {
  // Reset all transformations
  untransform: function() {
    return this.attr('transform', null)
  },
  // merge the whole transformation chain into one matrix and returns it
  matrixify: function() {

    var matrix = (this.attr('transform') || '')
      // split transformations
      .split(SVG.regex.transforms).slice(0,-1).map(function(str){
        // generate key => value pairs
        var kv = str.trim().split('(')
        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]
      })
      // merge every transformation into one matrix
      .reduce(function(matrix, transform){

        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))
        return matrix[transform[0]].apply(matrix, transform[1])

      }, new SVG.Matrix())

    return matrix
  },
  // add an element to another parent without changing the visual representation on the screen
  toParent: function(parent) {
    if(this == parent) return this
    var ctm = this.screenCTM()
    var pCtm = parent.screenCTM().inverse()

    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))

    return this
  },
  // same as above with parent equals root-svg
  toDoc: function() {
    return this.toParent(this.doc())
  }

})

SVG.Transformation = SVG.invent({

  create: function(source, inversed){

    if(arguments.length > 1 && typeof inversed != 'boolean'){
      return this.constructor.call(this, [].slice.call(arguments))
    }

    if(Array.isArray(source)){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        this[this.arguments[i]] = source[i]
      }
    } else if(typeof source == 'object'){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        this[this.arguments[i]] = source[this.arguments[i]]
      }
    }

    this.inversed = false

    if(inversed === true){
      this.inversed = true
    }

  }

, extend: {

    arguments: []
  , method: ''

  , at: function(pos){

      var params = []

      for(var i = 0, len = this.arguments.length; i < len; ++i){
        params.push(this[this.arguments[i]])
      }

      var m = this._undo || new SVG.Matrix()

      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)

      return this.inversed ? m.inverse() : m

    }

  , undo: function(o){
      for(var i = 0, len = this.arguments.length; i < len; ++i){
        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]
      }

      // The method SVG.Matrix.extract which was used before calling this
      // method to obtain a value for the parameter o doesn't return a cx and
      // a cy so we use the ones that were provided to this object at its creation
      o.cx = this.cx
      o.cy = this.cy

      this._undo = new SVG[capitalize(this.method)](o, true).at(1)

      return this
    }

  }

})

SVG.Translate = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['transformedX', 'transformedY']
  , method: 'translate'
  }

})

SVG.Rotate = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['rotation', 'cx', 'cy']
  , method: 'rotate'
  , at: function(pos){
      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)
      return this.inversed ? m.inverse() : m
    }
  , undo: function(o){
      this._undo = o
      return this
    }
  }

})

SVG.Scale = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['scaleX', 'scaleY', 'cx', 'cy']
  , method: 'scale'
  }

})

SVG.Skew = SVG.invent({

  parent: SVG.Matrix
, inherit: SVG.Transformation

, create: function(source, inversed){
    this.constructor.apply(this, [].slice.call(arguments))
  }

, extend: {
    arguments: ['skewX', 'skewY', 'cx', 'cy']
  , method: 'skew'
  }

})

SVG.extend(SVG.Element, {
  // Dynamic style generator
  style: function(s, v) {
    if (arguments.length == 0) {
      // get full style
      return this.node.style.cssText || ''

    } else if (arguments.length < 2) {
      // apply every style individually if an object is passed
      if (typeof s == 'object') {
        for (v in s) this.style(v, s[v])

      } else if (SVG.regex.isCss.test(s)) {
        // parse css string
        s = s.split(/\s*;\s*/)
          // filter out suffix ; and stuff like ;;
          .filter(function(e) { return !!e })
          .map(function(e){ return e.split(/\s*:\s*/) })

        // apply every definition individually
        while (v = s.pop()) {
          this.style(v[0], v[1])
        }
      } else {
        // act as a getter if the first and only argument is not an object
        return this.node.style[camelCase(s)]
      }

    } else {
      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v
    }

    return this
  }
})
SVG.Parent = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Element

  // Add class methods
, extend: {
    // Returns all child elements
    children: function() {
      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {
        return SVG.adopt(node)
      })
    }
    // Add given element at a position
  , add: function(element, i) {
      if (i == null)
        this.node.appendChild(element.node)
      else if (element.node != this.node.childNodes[i])
        this.node.insertBefore(element.node, this.node.childNodes[i])

      return this
    }
    // Basically does the same as `add()` but returns the added element instead
  , put: function(element, i) {
      this.add(element, i)
      return element
    }
    // Checks if the given element is a child
  , has: function(element) {
      return this.index(element) >= 0
    }
    // Gets index of given element
  , index: function(element) {
      return [].slice.call(this.node.childNodes).indexOf(element.node)
    }
    // Get a element at the given index
  , get: function(i) {
      return SVG.adopt(this.node.childNodes[i])
    }
    // Get first child
  , first: function() {
      return this.get(0)
    }
    // Get the last child
  , last: function() {
      return this.get(this.node.childNodes.length - 1)
    }
    // Iterates over all children and invokes a given block
  , each: function(block, deep) {
      var i, il
        , children = this.children()

      for (i = 0, il = children.length; i < il; i++) {
        if (children[i] instanceof SVG.Element)
          block.apply(children[i], [i, children])

        if (deep && (children[i] instanceof SVG.Container))
          children[i].each(block, deep)
      }

      return this
    }
    // Remove a given child
  , removeElement: function(element) {
      this.node.removeChild(element.node)

      return this
    }
    // Remove all elements in this container
  , clear: function() {
      // remove children
      while(this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // remove defs reference
      delete this._defs

      return this
    }
  , // Get defs
    defs: function() {
      return this.doc().defs()
    }
  }

})

SVG.extend(SVG.Parent, {

  ungroup: function(parent, depth) {
    if(depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this

    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))
    depth = depth || Infinity

    this.each(function(){
      if(this instanceof SVG.Defs) return this
      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)
      return this.toParent(parent)
    })

    this.node.firstChild || this.remove()

    return this
  },

  flatten: function(parent, depth) {
    return this.ungroup(parent, depth)
  }

})
SVG.Container = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Parent

})

SVG.ViewBox = SVG.invent({

  create: function(source) {
    var i, base = [0, 0, 0, 0]

    var x, y, width, height, box, view, we, he
      , wm   = 1 // width multiplier
      , hm   = 1 // height multiplier
      , reg  = /[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?/gi

    if(source instanceof SVG.Element){

      we = source
      he = source
      view = (source.attr('viewBox') || '').match(reg)
      box = source.bbox

      // get dimensions of current node
      width  = new SVG.Number(source.width())
      height = new SVG.Number(source.height())

      // find nearest non-percentual dimensions
      while (width.unit == '%') {
        wm *= width.value
        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())
        we = we.parent()
      }
      while (height.unit == '%') {
        hm *= height.value
        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())
        he = he.parent()
      }

      // ensure defaults
      this.x      = 0
      this.y      = 0
      this.width  = width  * wm
      this.height = height * hm
      this.zoom   = 1

      if (view) {
        // get width and height from viewbox
        x      = parseFloat(view[0])
        y      = parseFloat(view[1])
        width  = parseFloat(view[2])
        height = parseFloat(view[3])

        // calculate zoom accoring to viewbox
        this.zoom = ((this.width / this.height) > (width / height)) ?
          this.height / height :
          this.width  / width

        // calculate real pixel dimensions on parent SVG.Doc element
        this.x      = x
        this.y      = y
        this.width  = width
        this.height = height

      }

    }else{

      // ensure source as object
      source = typeof source === 'string' ?
        source.match(reg).map(function(el){ return parseFloat(el) }) :
      Array.isArray(source) ?
        source :
      typeof source == 'object' ?
        [source.x, source.y, source.width, source.height] :
      arguments.length == 4 ?
        [].slice.call(arguments) :
        base

      this.x = source[0]
      this.y = source[1]
      this.width = source[2]
      this.height = source[3]
    }


  }

, extend: {

    toString: function() {
      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height
    }
  , morph: function(x, y, width, height){
      this.destination = new SVG.ViewBox(x, y, width, height)
      return this
    }

  , at: function(pos) {

      if(!this.destination) return this

      return new SVG.ViewBox([
          this.x + (this.destination.x - this.x) * pos
        , this.y + (this.destination.y - this.y) * pos
        , this.width + (this.destination.width - this.width) * pos
        , this.height + (this.destination.height - this.height) * pos
      ])

    }

  }

  // Define parent
, parent: SVG.Container

  // Add parent method
, construct: {

    // get/set viewbox
    viewbox: function(x, y, width, height) {
      if (arguments.length == 0)
        // act as a getter if there are no arguments
        return new SVG.ViewBox(this)

      // otherwise act as a setter
      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))
    }

  }

})
// Add events to elements

;[ 'click',
  'dblclick',
  'mousedown',
  'mouseup',
  'mouseover',
  'mouseout',
  'mousemove',
  'mouseenter',
  'mouseleave',
  'touchstart',
  'touchmove',
  'touchleave',
  'touchend',
  'touchcancel' ].forEach(function (event) {
    // add event to SVG.Element
    SVG.Element.prototype[event] = function (f) {
      // bind event to element rather than element node
      if (f == null) {
        SVG.off(this, event)
      } else {
        SVG.on(this, event, f)
      }
      return this
    }
  })

SVG.listenerId = 0

// Add event binder in the SVG namespace
SVG.on = function (node, events, listener, binding, options) {
  var l = listener.bind(binding || node)
  var n = node instanceof SVG.Element ? node.node : node

  // ensure instance object for nodes which are not adopted
  n.instance = n.instance || {_events: {}}

  var bag = n.instance._events

  // add id to listener
  if (!listener._svgjsListenerId) { listener._svgjsListenerId = ++SVG.listenerId }

  events.split(SVG.regex.delimiter).forEach(function (event) {
    var ev = event.split('.')[0]
    var ns = event.split('.')[1] || '*'

    // ensure valid object
    bag[ev] = bag[ev] || {}
    bag[ev][ns] = bag[ev][ns] || {}

    // reference listener
    bag[ev][ns][listener._svgjsListenerId] = l

    // add listener
    n.addEventListener(ev, l, options || false)
  })
}

// Add event unbinder in the SVG namespace
SVG.off = function (node, events, listener, options) {
  var n = node instanceof SVG.Element ? node.node : node
  if (!n.instance) return

  // listener can be a function or a number
  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId
    if (!listener) return
  }

  var bag = n.instance._events

  ;(events || '').split(SVG.regex.delimiter).forEach(function (event) {
    var ev = event && event.split('.')[0]
    var ns = event && event.split('.')[1]
    var namespace, l

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false)

        delete bag[ev][ns || '*'][listener]
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) { SVG.off(n, [ev, ns].join('.'), l) }

        delete bag[ev][ns]
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) { SVG.off(n, [event, ns].join('.')) }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) { SVG.off(n, [ev, namespace].join('.')) }

        delete bag[ev]
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) { SVG.off(n, event) }

      n.instance._events = {}
    }
  })
}

SVG.extend(SVG.Element, {
  // Bind given event to listener
  on: function (event, listener, binding, options) {
    SVG.on(this, event, listener, binding, options)
    return this
  },
  // Unbind event from listener
  off: function (event, listener) {
    SVG.off(this.node, event, listener)
    return this
  },
  fire: function (event, data) {
    // Dispatch event
    if (event instanceof window.Event) {
      this.node.dispatchEvent(event)
    } else {
      this.node.dispatchEvent(event = new SVG.CustomEvent(event, {detail: data, cancelable: true}))
    }
    this._event = event
    return this
  },
  event: function() {
    return this._event
  }
})


SVG.Defs = SVG.invent({
  // Initialize node
  create: 'defs'

  // Inherit from
, inherit: SVG.Container

})
SVG.G = SVG.invent({
  // Initialize node
  create: 'g'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)
    }
    // Move over y-axis
  , y: function(y) {
      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)
    }
  , gbox: function() {

      var bbox  = this.bbox()
        , trans = this.transform()

      bbox.x  += trans.x
      bbox.x2 += trans.x
      bbox.cx += trans.x

      bbox.y  += trans.y
      bbox.y2 += trans.y
      bbox.cy += trans.y

      return bbox
    }
  }

  // Add parent method
, construct: {
    // Create a group element
    group: function() {
      return this.put(new SVG.G)
    }
  }
})

SVG.Doc = SVG.invent({
  // Initialize node
  create: function(element) {
    if (element) {
      // ensure the presence of a dom element
      element = typeof element == 'string' ?
        document.getElementById(element) :
        element

      // If the target is an svg element, use that element as the main wrapper.
      // This allows svg.js to work with svg documents as well.
      if (element.nodeName == 'svg') {
        this.constructor.call(this, element)
      } else {
        this.constructor.call(this, SVG.create('svg'))
        element.appendChild(this.node)
        this.size('100%', '100%')
      }

      // set svg element attributes and ensure defs node
      this.namespace().defs()
    }
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Add namespaces
    namespace: function() {
      return this
        .attr({ xmlns: SVG.ns, version: '1.1' })
        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)
        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)
    }
    // Creates and returns defs element
  , defs: function() {
      if (!this._defs) {
        var defs

        // Find or create a defs element in this instance
        if (defs = this.node.getElementsByTagName('defs')[0])
          this._defs = SVG.adopt(defs)
        else
          this._defs = new SVG.Defs

        // Make sure the defs node is at the end of the stack
        this.node.appendChild(this._defs.node)
      }

      return this._defs
    }
    // custom parent method
  , parent: function() {
      if(!this.node.parentNode || this.node.parentNode.nodeName == '#document' || this.node.parentNode.nodeName == '#document-fragment') return null
      return this.node.parentNode
    }
    // Fix for possible sub-pixel offset. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812
  , spof: function() {
      var pos = this.node.getScreenCTM()

      if (pos)
        this
          .style('left', (-pos.e % 1) + 'px')
          .style('top',  (-pos.f % 1) + 'px')

      return this
    }

      // Removes the doc from the DOM
  , remove: function() {
      if(this.parent()) {
        this.parent().removeChild(this.node)
      }

      return this
    }
  , clear: function() {
      // remove children
      while(this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // remove defs reference
      delete this._defs

      // add back parser
      if(!SVG.parser.draw.parentNode)
        this.node.appendChild(SVG.parser.draw)

      return this
    }
  , clone: function (parent) {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom()

      // get reference to node
      var node = this.node

      // clone element and assign new id
      var clone = assignNewId(node.cloneNode(true))

      // insert the clone in the given parent or after myself
      if(parent) {
        (parent.node || parent).appendChild(clone.node)
      } else {
        node.parentNode.insertBefore(clone.node, node.nextSibling)
      }

      return clone
    }
  }

})

// ### This module adds backward / forward functionality to elements.

//
SVG.extend(SVG.Element, {
  // Get all siblings, including myself
  siblings: function() {
    return this.parent().children()
  }
  // Get the curent position siblings
, position: function() {
    return this.parent().index(this)
  }
  // Get the next element (will return null if there is none)
, next: function() {
    return this.siblings()[this.position() + 1]
  }
  // Get the next element (will return null if there is none)
, previous: function() {
    return this.siblings()[this.position() - 1]
  }
  // Send given element one step forward
, forward: function() {
    var i = this.position() + 1
      , p = this.parent()

    // move node one step forward
    p.removeElement(this).add(this, i)

    // make sure defs node is always at the top
    if (p instanceof SVG.Doc)
      p.node.appendChild(p.defs().node)

    return this
  }
  // Send given element one step backward
, backward: function() {
    var i = this.position()

    if (i > 0)
      this.parent().removeElement(this).add(this, i - 1)

    return this
  }
  // Send given element all the way to the front
, front: function() {
    var p = this.parent()

    // Move node forward
    p.node.appendChild(this.node)

    // Make sure defs node is always at the top
    if (p instanceof SVG.Doc)
      p.node.appendChild(p.defs().node)

    return this
  }
  // Send given element all the way to the back
, back: function() {
    if (this.position() > 0)
      this.parent().removeElement(this).add(this, 0)

    return this
  }
  // Inserts a given element before the targeted element
, before: function(element) {
    element.remove()

    var i = this.position()

    this.parent().add(element, i)

    return this
  }
  // Insters a given element after the targeted element
, after: function(element) {
    element.remove()

    var i = this.position()

    this.parent().add(element, i + 1)

    return this
  }

})
SVG.Mask = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('mask'))

    // keep references to masked elements
    this.targets = []
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Unmask all masked elements and remove itself
    remove: function() {
      // unmask all targets
      for (var i = this.targets.length - 1; i >= 0; i--)
        if (this.targets[i])
          this.targets[i].unmask()
      this.targets = []

      // remove mask from parent
      SVG.Element.prototype.remove.call(this)

      return this
    }
  }

  // Add parent method
, construct: {
    // Create masking element
    mask: function() {
      return this.defs().put(new SVG.Mask)
    }
  }
})


SVG.extend(SVG.Element, {
  // Distribute mask to svg element
  maskWith: function(element) {
    // use given mask or create a new one
    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)

    // store reverence on self in mask
    this.masker.targets.push(this)

    // apply mask
    return this.attr('mask', 'url("#' + this.masker.attr('id') + '")')
  }
  // Unmask element
, unmask: function() {
    delete this.masker
    return this.attr('mask', null)
  }

})

SVG.ClipPath = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('clipPath'))

    // keep references to clipped elements
    this.targets = []
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Unclip all clipped elements and remove itself
    remove: function() {
      // unclip all targets
      for (var i = this.targets.length - 1; i >= 0; i--)
        if (this.targets[i])
          this.targets[i].unclip()
      this.targets = []

      // remove clipPath from parent
      this.parent().removeElement(this)

      return this
    }
  }

  // Add parent method
, construct: {
    // Create clipping element
    clip: function() {
      return this.defs().put(new SVG.ClipPath)
    }
  }
})

//
SVG.extend(SVG.Element, {
  // Distribute clipPath to svg element
  clipWith: function(element) {
    // use given clip or create a new one
    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)

    // store reverence on self in mask
    this.clipper.targets.push(this)

    // apply mask
    return this.attr('clip-path', 'url("#' + this.clipper.attr('id') + '")')
  }
  // Unclip element
, unclip: function() {
    delete this.clipper
    return this.attr('clip-path', null)
  }

})
SVG.Gradient = SVG.invent({
  // Initialize node
  create: function(type) {
    this.constructor.call(this, SVG.create(type + 'Gradient'))

    // store type
    this.type = type
  }

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Add a color stop
    at: function(offset, color, opacity) {
      return this.put(new SVG.Stop).update(offset, color, opacity)
    }
    // Update gradient
  , update: function(block) {
      // remove all stops
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Return the fill id
  , fill: function() {
      return 'url(#' + this.id() + ')'
    }
    // Alias string convertion to fill
  , toString: function() {
      return this.fill()
    }
    // custom attr to handle transform
  , attr: function(a, b, c) {
      if(a == 'transform') a = 'gradientTransform'
      return SVG.Container.prototype.attr.call(this, a, b, c)
    }
  }

  // Add parent method
, construct: {
    // Create gradient element in defs
    gradient: function(type, block) {
      return this.defs().gradient(type, block)
    }
  }
})

// Add animatable methods to both gradient and fx module
SVG.extend(SVG.Gradient, SVG.FX, {
  // From position
  from: function(x, y) {
    return (this._target || this).type == 'radial' ?
      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :
      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })
  }
  // To position
, to: function(x, y) {
    return (this._target || this).type == 'radial' ?
      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :
      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })
  }
})

// Base gradient generation
SVG.extend(SVG.Defs, {
  // define gradient
  gradient: function(type, block) {
    return this.put(new SVG.Gradient(type)).update(block)
  }

})

SVG.Stop = SVG.invent({
  // Initialize node
  create: 'stop'

  // Inherit from
, inherit: SVG.Element

  // Add class methods
, extend: {
    // add color stops
    update: function(o) {
      if (typeof o == 'number' || o instanceof SVG.Number) {
        o = {
          offset:  arguments[0]
        , color:   arguments[1]
        , opacity: arguments[2]
        }
      }

      // set attributes
      if (o.opacity != null) this.attr('stop-opacity', o.opacity)
      if (o.color   != null) this.attr('stop-color', o.color)
      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))

      return this
    }
  }

})

SVG.Pattern = SVG.invent({
  // Initialize node
  create: 'pattern'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Return the fill id
    fill: function() {
      return 'url(#' + this.id() + ')'
    }
    // Update pattern by rebuilding
  , update: function(block) {
      // remove content
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Alias string convertion to fill
  , toString: function() {
      return this.fill()
    }
    // custom attr to handle transform
  , attr: function(a, b, c) {
      if(a == 'transform') a = 'patternTransform'
      return SVG.Container.prototype.attr.call(this, a, b, c)
    }

  }

  // Add parent method
, construct: {
    // Create pattern element in defs
    pattern: function(width, height, block) {
      return this.defs().pattern(width, height, block)
    }
  }
})

SVG.extend(SVG.Defs, {
  // Define gradient
  pattern: function(width, height, block) {
    return this.put(new SVG.Pattern).update(block).attr({
      x:            0
    , y:            0
    , width:        width
    , height:       height
    , patternUnits: 'userSpaceOnUse'
    })
  }

})
SVG.Shape = SVG.invent({
  // Initialize node
  create: function(element) {
    this.constructor.call(this, element)
  }

  // Inherit from
, inherit: SVG.Element

})

SVG.Bare = SVG.invent({
  // Initialize
  create: function(element, inherit) {
    // construct element
    this.constructor.call(this, SVG.create(element))

    // inherit custom methods
    if (inherit)
      for (var method in inherit.prototype)
        if (typeof inherit.prototype[method] === 'function')
          this[method] = inherit.prototype[method]
  }

  // Inherit from
, inherit: SVG.Element

  // Add methods
, extend: {
    // Insert some plain text
    words: function(text) {
      // remove contents
      while (this.node.hasChildNodes())
        this.node.removeChild(this.node.lastChild)

      // create text node
      this.node.appendChild(document.createTextNode(text))

      return this
    }
  }
})


SVG.extend(SVG.Parent, {
  // Create an element that is not described by SVG.js
  element: function(element, inherit) {
    return this.put(new SVG.Bare(element, inherit))
  }
})

SVG.Symbol = SVG.invent({
  // Initialize node
  create: 'symbol'

  // Inherit from
, inherit: SVG.Container

, construct: {
    // create symbol
    symbol: function() {
      return this.put(new SVG.Symbol)
    }
  }
})

SVG.Use = SVG.invent({
  // Initialize node
  create: 'use'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Use element as a reference
    element: function(element, file) {
      // Set lined element
      return this.attr('href', (file || '') + '#' + element, SVG.xlink)
    }
  }

  // Add parent method
, construct: {
    // Create a use element
    use: function(element, file) {
      return this.put(new SVG.Use).element(element, file)
    }
  }
})
SVG.Rect = SVG.invent({
  // Initialize node
  create: 'rect'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a rect element
    rect: function(width, height) {
      return this.put(new SVG.Rect()).size(width, height)
    }
  }
})
SVG.Circle = SVG.invent({
  // Initialize node
  create: 'circle'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create circle element, based on ellipse
    circle: function(size) {
      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)
    }
  }
})

SVG.extend(SVG.Circle, SVG.FX, {
  // Radius x value
  rx: function(rx) {
    return this.attr('r', rx)
  }
  // Alias radius x value
, ry: function(ry) {
    return this.rx(ry)
  }
})

SVG.Ellipse = SVG.invent({
  // Initialize node
  create: 'ellipse'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create an ellipse
    ellipse: function(width, height) {
      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)
    }
  }
})

SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {
  // Radius x value
  rx: function(rx) {
    return this.attr('rx', rx)
  }
  // Radius y value
, ry: function(ry) {
    return this.attr('ry', ry)
  }
})

// Add common method
SVG.extend(SVG.Circle, SVG.Ellipse, {
    // Move over x-axis
    x: function(x) {
      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())
    }
    // Move over y-axis
  , y: function(y) {
      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())
    }
    // Move by center over x-axis
  , cx: function(x) {
      return x == null ? this.attr('cx') : this.attr('cx', x)
    }
    // Move by center over y-axis
  , cy: function(y) {
      return y == null ? this.attr('cy') : this.attr('cy', y)
    }
    // Set width of element
  , width: function(width) {
      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))
    }
    // Set height of element
  , height: function(height) {
      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))
    }
    // Custom size function
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this
        .rx(new SVG.Number(p.width).divide(2))
        .ry(new SVG.Number(p.height).divide(2))
    }
})
SVG.Line = SVG.invent({
  // Initialize node
  create: 'line'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Get array
    array: function() {
      return new SVG.PointArray([
        [ this.attr('x1'), this.attr('y1') ]
      , [ this.attr('x2'), this.attr('y2') ]
      ])
    }
    // Overwrite native plot() method
  , plot: function(x1, y1, x2, y2) {
      if (x1 == null)
        return this.array()
      else if (typeof y1 !== 'undefined')
        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }
      else
        x1 = new SVG.PointArray(x1).toLine()

      return this.attr(x1)
    }
    // Move by left top corner
  , move: function(x, y) {
      return this.attr(this.array().move(x, y).toLine())
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this.attr(this.array().size(p.width, p.height).toLine())
    }
  }

  // Add parent method
, construct: {
    // Create a line element
    line: function(x1, y1, x2, y2) {
      // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray
      return SVG.Line.prototype.plot.apply(
        this.put(new SVG.Line)
      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]
      )
    }
  }
})

SVG.Polyline = SVG.invent({
  // Initialize node
  create: 'polyline'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a wrapped polyline element
    polyline: function(p) {
      // make sure plot is called as a setter
      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)
    }
  }
})

SVG.Polygon = SVG.invent({
  // Initialize node
  create: 'polygon'

  // Inherit from
, inherit: SVG.Shape

  // Add parent method
, construct: {
    // Create a wrapped polygon element
    polygon: function(p) {
      // make sure plot is called as a setter
      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)
    }
  }
})

// Add polygon-specific functions
SVG.extend(SVG.Polyline, SVG.Polygon, {
  // Get array
  array: function() {
    return this._array || (this._array = new SVG.PointArray(this.attr('points')))
  }
  // Plot new path
, plot: function(p) {
    return (p == null) ?
      this.array() :
      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))
  }
  // Clear array cache
, clear: function() {
    delete this._array
    return this
  }
  // Move by left top corner
, move: function(x, y) {
    return this.attr('points', this.array().move(x, y))
  }
  // Set element size to given width and height
, size: function(width, height) {
    var p = proportionalSize(this, width, height)

    return this.attr('points', this.array().size(p.width, p.height))
  }

})

// unify all point to point elements
SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {
  // Define morphable array
  morphArray:  SVG.PointArray
  // Move by left top corner over x-axis
, x: function(x) {
    return x == null ? this.bbox().x : this.move(x, this.bbox().y)
  }
  // Move by left top corner over y-axis
, y: function(y) {
    return y == null ? this.bbox().y : this.move(this.bbox().x, y)
  }
  // Set width of element
, width: function(width) {
    var b = this.bbox()

    return width == null ? b.width : this.size(width, b.height)
  }
  // Set height of element
, height: function(height) {
    var b = this.bbox()

    return height == null ? b.height : this.size(b.width, height)
  }
})
SVG.Path = SVG.invent({
  // Initialize node
  create: 'path'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Define morphable array
    morphArray:  SVG.PathArray
    // Get array
  , array: function() {
      return this._array || (this._array = new SVG.PathArray(this.attr('d')))
    }
    // Plot new path
  , plot: function(d) {
      return (d == null) ?
        this.array() :
        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))
    }
    // Clear array cache
  , clear: function() {
      delete this._array
      return this
    }
    // Move by left top corner
  , move: function(x, y) {
      return this.attr('d', this.array().move(x, y))
    }
    // Move by left top corner over x-axis
  , x: function(x) {
      return x == null ? this.bbox().x : this.move(x, this.bbox().y)
    }
    // Move by left top corner over y-axis
  , y: function(y) {
      return y == null ? this.bbox().y : this.move(this.bbox().x, y)
    }
    // Set element size to given width and height
  , size: function(width, height) {
      var p = proportionalSize(this, width, height)

      return this.attr('d', this.array().size(p.width, p.height))
    }
    // Set width of element
  , width: function(width) {
      return width == null ? this.bbox().width : this.size(width, this.bbox().height)
    }
    // Set height of element
  , height: function(height) {
      return height == null ? this.bbox().height : this.size(this.bbox().width, height)
    }

  }

  // Add parent method
, construct: {
    // Create a wrapped path element
    path: function(d) {
      // make sure plot is called as a setter
      return this.put(new SVG.Path).plot(d || new SVG.PathArray)
    }
  }
})

SVG.Image = SVG.invent({
  // Initialize node
  create: 'image'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // (re)load image
    load: function(url) {
      if (!url) return this

      var self = this
        , img  = new window.Image()

      // preload image
      SVG.on(img, 'load', function() {
        SVG.off(img)

        var p = self.parent(SVG.Pattern)

        if(p === null) return

        // ensure image size
        if (self.width() == 0 && self.height() == 0)
          self.size(img.width, img.height)

        // ensure pattern size if not set
        if (p && p.width() == 0 && p.height() == 0)
          p.size(self.width(), self.height())

        // callback
        if (typeof self._loaded === 'function')
          self._loaded.call(self, {
            width:  img.width
          , height: img.height
          , ratio:  img.width / img.height
          , url:    url
          })
      })

      SVG.on(img, 'error', function(e){
        SVG.off(img)

        if (typeof self._error === 'function'){
            self._error.call(self, e)
        }
      })

      return this.attr('href', (img.src = this.src = url), SVG.xlink)
    }
    // Add loaded callback
  , loaded: function(loaded) {
      this._loaded = loaded
      return this
    }

  , error: function(error) {
      this._error = error
      return this
    }
  }

  // Add parent method
, construct: {
    // create image element, load image and set its size
    image: function(source, width, height) {
      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)
    }
  }

})
SVG.Text = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('text'))

    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding
    this._rebuild = true                      // enable automatic updating of dy values
    this._build   = false                     // disable build mode for adding multiple lines

    // set default font
    this.attr('font-family', SVG.defaults.attrs['font-family'])
  }

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Move over x-axis
    x: function(x) {
      // act as getter
      if (x == null)
        return this.attr('x')

      return this.attr('x', x)
    }
    // Move over y-axis
  , y: function(y) {
      var oy = this.attr('y')
        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0

      // act as getter
      if (y == null)
        return typeof oy === 'number' ? oy - o : oy

      return this.attr('y', typeof y.valueOf() === 'number' ? y + o : y)
    }
    // Move center over x-axis
  , cx: function(x) {
      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)
    }
    // Move center over y-axis
  , cy: function(y) {
      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)
    }
    // Set the text content
  , text: function(text) {
      // act as getter
      if (typeof text === 'undefined'){
        var text = ''
        var children = this.node.childNodes
        for(var i = 0, len = children.length; i < len; ++i){

          // add newline if its not the first child and newLined is set to true
          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){
            text += '\n'
          }

          // add content of this node
          text += children[i].textContent
        }

        return text
      }

      // remove existing content
      this.clear().build(true)

      if (typeof text === 'function') {
        // call block
        text.call(this, this)

      } else {
        // store text and make sure text is not blank
        text = text.split('\n')

        // build new lines
        for (var i = 0, il = text.length; i < il; i++)
          this.tspan(text[i]).newLine()
      }

      // disable build mode and rebuild lines
      return this.build(false).rebuild()
    }
    // Set font size
  , size: function(size) {
      return this.attr('font-size', size).rebuild()
    }
    // Set / get leading
  , leading: function(value) {
      // act as getter
      if (value == null)
        return this.dom.leading

      // act as setter
      this.dom.leading = new SVG.Number(value)

      return this.rebuild()
    }
    // Get all the first level lines
  , lines: function() {
      var node = (this.textPath && this.textPath() || this).node

      // filter tspans and map them to SVG.js instances
      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){
        return SVG.adopt(el)
      })

      // return an instance of SVG.set
      return new SVG.Set(lines)
    }
    // Rebuild appearance type
  , rebuild: function(rebuild) {
      // store new rebuild flag if given
      if (typeof rebuild == 'boolean')
        this._rebuild = rebuild

      // define position of all lines
      if (this._rebuild) {
        var self = this
          , blankLineOffset = 0
          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))

        this.lines().each(function() {
          if (this.dom.newLined) {
            if (!self.textPath())
              this.attr('x', self.attr('x'))
            if(this.text() == '\n') {
              blankLineOffset += dy
            }else{
              this.attr('dy', dy + blankLineOffset)
              blankLineOffset = 0
            }
          }
        })

        this.fire('rebuild')
      }

      return this
    }
    // Enable / disable build mode
  , build: function(build) {
      this._build = !!build
      return this
    }
    // overwrite method from parent to set data properly
  , setData: function(o){
      this.dom = o
      this.dom.leading = new SVG.Number(o.leading || 1.3)
      return this
    }
  }

  // Add parent method
, construct: {
    // Create text element
    text: function(text) {
      return this.put(new SVG.Text).text(text)
    }
    // Create plain text element
  , plain: function(text) {
      return this.put(new SVG.Text).plain(text)
    }
  }

})

SVG.Tspan = SVG.invent({
  // Initialize node
  create: 'tspan'

  // Inherit from
, inherit: SVG.Shape

  // Add class methods
, extend: {
    // Set text content
    text: function(text) {
      if(text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '')

      typeof text === 'function' ? text.call(this, this) : this.plain(text)

      return this
    }
    // Shortcut dx
  , dx: function(dx) {
      return this.attr('dx', dx)
    }
    // Shortcut dy
  , dy: function(dy) {
      return this.attr('dy', dy)
    }
    // Create new line
  , newLine: function() {
      // fetch text parent
      var t = this.parent(SVG.Text)

      // mark new line
      this.dom.newLined = true

      // apply new hy¡n
      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())
    }
  }

})

SVG.extend(SVG.Text, SVG.Tspan, {
  // Create plain text node
  plain: function(text) {
    // clear if build mode is disabled
    if (this._build === false)
      this.clear()

    // create text node
    this.node.appendChild(document.createTextNode(text))

    return this
  }
  // Create a tspan
, tspan: function(text) {
    var node  = (this.textPath && this.textPath() || this).node
      , tspan = new SVG.Tspan

    // clear if build mode is disabled
    if (this._build === false)
      this.clear()

    // add new tspan
    node.appendChild(tspan.node)

    return tspan.text(text)
  }
  // Clear all lines
, clear: function() {
    var node = (this.textPath && this.textPath() || this).node

    // remove existing child nodes
    while (node.hasChildNodes())
      node.removeChild(node.lastChild)

    return this
  }
  // Get length of text element
, length: function() {
    return this.node.getComputedTextLength()
  }
})

SVG.TextPath = SVG.invent({
  // Initialize node
  create: 'textPath'

  // Inherit from
, inherit: SVG.Parent

  // Define parent class
, parent: SVG.Text

  // Add parent method
, construct: {
    morphArray: SVG.PathArray
    // Create path for text to run on
  , path: function(d) {
      // create textPath element
      var path  = new SVG.TextPath
        , track = this.doc().defs().path(d)

      // move lines to textpath
      while (this.node.hasChildNodes())
        path.node.appendChild(this.node.firstChild)

      // add textPath element as child node
      this.node.appendChild(path.node)

      // link textPath to path and add content
      path.attr('href', '#' + track, SVG.xlink)

      return this
    }
    // return the array of the path track element
  , array: function() {
      var track = this.track()

      return track ? track.array() : null
    }
    // Plot path if any
  , plot: function(d) {
      var track = this.track()
        , pathArray = null

      if (track) {
        pathArray = track.plot(d)
      }

      return (d == null) ? pathArray : this
    }
    // Get the path track element
  , track: function() {
      var path = this.textPath()

      if (path)
        return path.reference('href')
    }
    // Get the textPath child
  , textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')
        return SVG.adopt(this.node.firstChild)
    }
  }
})

SVG.Nested = SVG.invent({
  // Initialize node
  create: function() {
    this.constructor.call(this, SVG.create('svg'))

    this.style('overflow', 'visible')
  }

  // Inherit from
, inherit: SVG.Container

  // Add parent method
, construct: {
    // Create nested svg document
    nested: function() {
      return this.put(new SVG.Nested)
    }
  }
})
SVG.A = SVG.invent({
  // Initialize node
  create: 'a'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Link url
    to: function(url) {
      return this.attr('href', url, SVG.xlink)
    }
    // Link show attribute
  , show: function(target) {
      return this.attr('show', target, SVG.xlink)
    }
    // Link target attribute
  , target: function(target) {
      return this.attr('target', target)
    }
  }

  // Add parent method
, construct: {
    // Create a hyperlink element
    link: function(url) {
      return this.put(new SVG.A).to(url)
    }
  }
})

SVG.extend(SVG.Element, {
  // Create a hyperlink element
  linkTo: function(url) {
    var link = new SVG.A

    if (typeof url == 'function')
      url.call(link, link)
    else
      link.to(url)

    return this.parent().put(link).put(this)
  }

})
SVG.Marker = SVG.invent({
  // Initialize node
  create: 'marker'

  // Inherit from
, inherit: SVG.Container

  // Add class methods
, extend: {
    // Set width of element
    width: function(width) {
      return this.attr('markerWidth', width)
    }
    // Set height of element
  , height: function(height) {
      return this.attr('markerHeight', height)
    }
    // Set marker refX and refY
  , ref: function(x, y) {
      return this.attr('refX', x).attr('refY', y)
    }
    // Update marker
  , update: function(block) {
      // remove all content
      this.clear()

      // invoke passed block
      if (typeof block == 'function')
        block.call(this, this)

      return this
    }
    // Return the fill id
  , toString: function() {
      return 'url(#' + this.id() + ')'
    }
  }

  // Add parent method
, construct: {
    marker: function(width, height, block) {
      // Create marker element in defs
      return this.defs().marker(width, height, block)
    }
  }

})

SVG.extend(SVG.Defs, {
  // Create marker
  marker: function(width, height, block) {
    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
    return this.put(new SVG.Marker)
      .size(width, height)
      .ref(width / 2, height / 2)
      .viewbox(0, 0, width, height)
      .attr('orient', 'auto')
      .update(block)
  }

})

SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {
  // Create and attach markers
  marker: function(marker, width, height, block) {
    var attr = ['marker']

    // Build attribute name
    if (marker != 'all') attr.push(marker)
    attr = attr.join('-')

    // Set marker attribute
    marker = arguments[1] instanceof SVG.Marker ?
      arguments[1] :
      this.doc().marker(width, height, block)

    return this.attr(attr, marker)
  }

})
// Define list of available attributes for stroke and fill
var sugar = {
  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']
, fill:   ['color', 'opacity', 'rule']
, prefix: function(t, a) {
    return a == 'color' ? t : t + '-' + a
  }
}

// Add sugar for fill and stroke
;['fill', 'stroke'].forEach(function(m) {
  var i, extension = {}

  extension[m] = function(o) {
    if (typeof o == 'undefined')
      return this
    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))
      this.attr(m, o)

    else
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--)
        if (o[sugar[m][i]] != null)
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])

    return this
  }

  SVG.extend(SVG.Element, SVG.FX, extension)

})

SVG.extend(SVG.Element, SVG.FX, {
  // Map rotation to transform
  rotate: function(d, cx, cy) {
    return this.transform({ rotation: d, cx: cx, cy: cy })
  }
  // Map skew to transform
, skew: function(x, y, cx, cy) {
    return arguments.length == 1  || arguments.length == 3 ?
      this.transform({ skew: x, cx: y, cy: cx }) :
      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })
  }
  // Map scale to transform
, scale: function(x, y, cx, cy) {
    return arguments.length == 1  || arguments.length == 3 ?
      this.transform({ scale: x, cx: y, cy: cx }) :
      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })
  }
  // Map translate to transform
, translate: function(x, y) {
    return this.transform({ x: x, y: y })
  }
  // Map flip to transform
, flip: function(a, o) {
    o = typeof a == 'number' ? a : o
    return this.transform({ flip: a || 'both', offset: o })
  }
  // Map matrix to transform
, matrix: function(m) {
    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))
  }
  // Opacity
, opacity: function(value) {
    return this.attr('opacity', value)
  }
  // Relative move over x axis
, dx: function(x) {
    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)
  }
  // Relative move over y axis
, dy: function(y) {
    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)
  }
  // Relative move over x and y axes
, dmove: function(x, y) {
    return this.dx(x).dy(y)
  }
})

SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {
  // Add x and y radius
  radius: function(x, y) {
    var type = (this._target || this).type;
    return type == 'radial' || type == 'circle' ?
      this.attr('r', new SVG.Number(x)) :
      this.rx(x).ry(y == null ? x : y)
  }
})

SVG.extend(SVG.Path, {
  // Get path length
  length: function() {
    return this.node.getTotalLength()
  }
  // Get point at length
, pointAt: function(length) {
    return this.node.getPointAtLength(length)
  }
})

SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {
  // Set font
  font: function(a, v) {
    if (typeof a == 'object') {
      for (v in a) this.font(v, a[v])
    }

    return a == 'leading' ?
        this.leading(v) :
      a == 'anchor' ?
        this.attr('text-anchor', v) :
      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?
        this.attr('font-'+ a, v) :
        this.attr(a, v)
  }
})

SVG.Set = SVG.invent({
  // Initialize
  create: function(members) {
    if (members instanceof SVG.Set) {
      this.members = members.members.slice()
    } else {
      Array.isArray(members) ? this.members = members : this.clear()
    }
  }

  // Add class methods
, extend: {
    // Add element to set
    add: function() {
      var i, il, elements = [].slice.call(arguments)

      for (i = 0, il = elements.length; i < il; i++)
        this.members.push(elements[i])

      return this
    }
    // Remove element from set
  , remove: function(element) {
      var i = this.index(element)

      // remove given child
      if (i > -1)
        this.members.splice(i, 1)

      return this
    }
    // Iterate over all members
  , each: function(block) {
      for (var i = 0, il = this.members.length; i < il; i++)
        block.apply(this.members[i], [i, this.members])

      return this
    }
    // Restore to defaults
  , clear: function() {
      // initialize store
      this.members = []

      return this
    }
    // Get the length of a set
  , length: function() {
      return this.members.length
    }
    // Checks if a given element is present in set
  , has: function(element) {
      return this.index(element) >= 0
    }
    // retuns index of given element in set
  , index: function(element) {
      return this.members.indexOf(element)
    }
    // Get member at given index
  , get: function(i) {
      return this.members[i]
    }
    // Get first member
  , first: function() {
      return this.get(0)
    }
    // Get last member
  , last: function() {
      return this.get(this.members.length - 1)
    }
    // Default value
  , valueOf: function() {
      return this.members
    }
    // Get the bounding box of all members included or empty box if set has no items
  , bbox: function(){
      // return an empty box of there are no members
      if (this.members.length == 0)
        return new SVG.RBox()

      // get the first rbox and update the target bbox
      var rbox = this.members[0].rbox(this.members[0].doc())

      this.each(function() {
        // user rbox for correct position and visual representation
        rbox = rbox.merge(this.rbox(this.doc()))
      })

      return rbox
    }
  }

  // Add parent method
, construct: {
    // Create a new set
    set: function(members) {
      return new SVG.Set(members)
    }
  }
})

SVG.FX.Set = SVG.invent({
  // Initialize node
  create: function(set) {
    // store reference to set
    this.set = set
  }

})

// Alias methods
SVG.Set.inherit = function() {
  var m
    , methods = []

  // gather shape methods
  for(var m in SVG.Shape.prototype)
    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')
      methods.push(m)

  // apply shape aliasses
  methods.forEach(function(method) {
    SVG.Set.prototype[method] = function() {
      for (var i = 0, il = this.members.length; i < il; i++)
        if (this.members[i] && typeof this.members[i][method] == 'function')
          this.members[i][method].apply(this.members[i], arguments)

      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this
    }
  })

  // clear methods for the next round
  methods = []

  // gather fx methods
  for(var m in SVG.FX.prototype)
    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')
      methods.push(m)

  // apply fx aliasses
  methods.forEach(function(method) {
    SVG.FX.Set.prototype[method] = function() {
      for (var i = 0, il = this.set.members.length; i < il; i++)
        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)

      return this
    }
  })
}


SVG.extend(SVG.Element, {
  // Store data values on svg nodes
  data: function(a, v, r) {
    if (typeof a == 'object') {
      for (v in a)
        this.data(v, a[v])

    } else if (arguments.length < 2) {
      try {
        return JSON.parse(this.attr('data-' + a))
      } catch(e) {
        return this.attr('data-' + a)
      }

    } else {
      this.attr(
        'data-' + a
      , v === null ?
          null :
        r === true || typeof v === 'string' || typeof v === 'number' ?
          v :
          JSON.stringify(v)
      )
    }

    return this
  }
})
SVG.extend(SVG.Element, {
  // Remember arbitrary data
  remember: function(k, v) {
    // remember every item in an object individually
    if (typeof arguments[0] == 'object')
      for (var v in k)
        this.remember(v, k[v])

    // retrieve memory
    else if (arguments.length == 1)
      return this.memory()[k]

    // store memory
    else
      this.memory()[k] = v

    return this
  }

  // Erase a given memory
, forget: function() {
    if (arguments.length == 0)
      this._memory = {}
    else
      for (var i = arguments.length - 1; i >= 0; i--)
        delete this.memory()[arguments[i]]

    return this
  }

  // Initialize or return local memory object
, memory: function() {
    return this._memory || (this._memory = {})
  }

})
// Method for getting an element by id
SVG.get = function(id) {
  var node = document.getElementById(idFromReference(id) || id)
  return SVG.adopt(node)
}

// Select elements by query string
SVG.select = function(query, parent) {
  return new SVG.Set(
    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {
      return SVG.adopt(node)
    })
  )
}

SVG.extend(SVG.Parent, {
  // Scoped select method
  select: function(query) {
    return SVG.select(query, this.node)
  }

})
function pathRegReplace(a, b, c, d) {
  return c + d.replace(SVG.regex.dots, ' .')
}

// creates deep clone of array
function array_clone(arr){
  var clone = arr.slice(0)
  for(var i = clone.length; i--;){
    if(Array.isArray(clone[i])){
      clone[i] = array_clone(clone[i])
    }
  }
  return clone
}

// tests if a given element is instance of an object
function is(el, obj){
  return el instanceof obj
}

// tests if a given selector matches an element
function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

// Convert dash-separated-string to camelCase
function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function(m, g) {
    return g.toUpperCase()
  })
}

// Capitalize first letter of a string
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

// Ensure to six-based hex
function fullHex(hex) {
  return hex.length == 4 ?
    [ '#',
      hex.substring(1, 2), hex.substring(1, 2)
    , hex.substring(2, 3), hex.substring(2, 3)
    , hex.substring(3, 4), hex.substring(3, 4)
    ].join('') : hex
}

// Component to hex value
function compToHex(comp) {
  var hex = comp.toString(16)
  return hex.length == 1 ? '0' + hex : hex
}

// Calculate proportional width and height values when necessary
function proportionalSize(element, width, height) {
  if (width == null || height == null) {
    var box = element.bbox()

    if (width == null)
      width = box.width / box.height * height
    else if (height == null)
      height = box.height / box.width * width
  }

  return {
    width:  width
  , height: height
  }
}

// Delta transform point
function deltaTransformPoint(matrix, x, y) {
  return {
    x: x * matrix.a + y * matrix.c + 0
  , y: x * matrix.b + y * matrix.d + 0
  }
}

// Map matrix array to object
function arrayToMatrix(a) {
  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }
}

// Parse matrix if required
function parseMatrix(matrix) {
  if (!(matrix instanceof SVG.Matrix))
    matrix = new SVG.Matrix(matrix)

  return matrix
}

// Add centre point to transform object
function ensureCentre(o, target) {
  o.cx = o.cx == null ? target.bbox().cx : o.cx
  o.cy = o.cy == null ? target.bbox().cy : o.cy
}

// PathArray Helpers
function arrayToString(a) {
  for (var i = 0, il = a.length, s = ''; i < il; i++) {
    s += a[i][0]

    if (a[i][1] != null) {
      s += a[i][1]

      if (a[i][2] != null) {
        s += ' '
        s += a[i][2]

        if (a[i][3] != null) {
          s += ' '
          s += a[i][3]
          s += ' '
          s += a[i][4]

          if (a[i][5] != null) {
            s += ' '
            s += a[i][5]
            s += ' '
            s += a[i][6]

            if (a[i][7] != null) {
              s += ' '
              s += a[i][7]
            }
          }
        }
      }
    }
  }

  return s + ' '
}

// Deep new id assignment
function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (var i = node.childNodes.length - 1; i >= 0; i--)
    if (node.childNodes[i] instanceof window.SVGElement)
      assignNewId(node.childNodes[i])

  return SVG.adopt(node).id(SVG.eid(node.nodeName))
}

// Add more bounding box properties
function fullBox(b) {
  if (b.x == null) {
    b.x      = 0
    b.y      = 0
    b.width  = 0
    b.height = 0
  }

  b.w  = b.width
  b.h  = b.height
  b.x2 = b.x + b.width
  b.y2 = b.y + b.height
  b.cx = b.x + b.width / 2
  b.cy = b.y + b.height / 2

  return b
}

// Get id from reference string
function idFromReference(url) {
  var m = (url || '').toString().match(SVG.regex.reference)

  if (m) return m[1]
}

// If values like 1e-88 are passed, this is not a valid 32 bit float,
// but in those cases, we are so close to 0 that 0 works well!
function float32String(v) {
  return Math.abs(v) > 1e-37 ? v : 0
}

// Create matrix array for looping
var abcdef = 'abcdef'.split('')

// Add CustomEvent to IE9 and IE10
if (typeof window.CustomEvent !== 'function') {
  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
  var CustomEventPoly = function(event, options) {
    options = options || { bubbles: false, cancelable: false, detail: undefined }
    var e = document.createEvent('CustomEvent')
    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)
    return e
  }

  CustomEventPoly.prototype = window.Event.prototype

  SVG.CustomEvent = CustomEventPoly
} else {
  SVG.CustomEvent = window.CustomEvent
}

// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish
(function(w) {
  var lastTime = 0
  var vendors = ['moz', 'webkit']

  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']
    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||
                              w[vendors[x] + 'CancelRequestAnimationFrame']
  }

  w.requestAnimationFrame = w.requestAnimationFrame ||
    function(callback) {
      var currTime = new Date().getTime()
      var timeToCall = Math.max(0, 16 - (currTime - lastTime))

      var id = w.setTimeout(function() {
        callback(currTime + timeToCall)
      }, timeToCall)

      lastTime = currTime + timeToCall
      return id
    }

  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;

}(window))

return SVG

}));

/***/ }),

/***/ "./node_modules/twig/twig.js":
/*!***********************************!*\
  !*** ./node_modules/twig/twig.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function sprintf() {
  //  discuss at: http://locutus.io/php/sprintf/
  // original by: Ash Searle (http://hexmen.com/blog/)
  // improved by: Michael White (http://getsprink.com)
  // improved by: Jack
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Dj
  // improved by: Allidylls
  //    input by: Paulo Freitas
  //    input by: Brett Zamir (http://brett-zamir.me)
  //   example 1: sprintf("%01.2f", 123.1)
  //   returns 1: '123.10'
  //   example 2: sprintf("[%10s]", 'monkey')
  //   returns 2: '[    monkey]'
  //   example 3: sprintf("[%'#10s]", 'monkey')
  //   returns 3: '[####monkey]'
  //   example 4: sprintf("%d", 123456789012345)
  //   returns 4: '123456789012345'
  //   example 5: sprintf('%-03s', 'E')
  //   returns 5: 'E00'

  var regex = /%%|%(\d+\$)?([\-+'#0 ]*)(\*\d+\$|\*|\d+)?(?:\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
  var a = arguments;
  var i = 0;
  var format = a[i++];

  var _pad = function _pad(str, len, chr, leftJustify) {
    if (!chr) {
      chr = ' ';
    }
    var padding = str.length >= len ? '' : new Array(1 + len - str.length >>> 0).join(chr);
    return leftJustify ? str + padding : padding + str;
  };

  var justify = function justify(value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
    var diff = minWidth - value.length;
    if (diff > 0) {
      if (leftJustify || !zeroPad) {
        value = _pad(value, minWidth, customPadChar, leftJustify);
      } else {
        value = [value.slice(0, prefix.length), _pad('', diff, '0', true), value.slice(prefix.length)].join('');
      }
    }
    return value;
  };

  var _formatBaseX = function _formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
    // Note: casts negative numbers to positive ones
    var number = value >>> 0;
    prefix = prefix && number && {
      '2': '0b',
      '8': '0',
      '16': '0x'
    }[base] || '';
    value = prefix + _pad(number.toString(base), precision || 0, '0', false);
    return justify(value, prefix, leftJustify, minWidth, zeroPad);
  };

  // _formatString()
  var _formatString = function _formatString(value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
    if (precision !== null && precision !== undefined) {
      value = value.slice(0, precision);
    }
    return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
  };

  // doFormat()
  var doFormat = function doFormat(substring, valueIndex, flags, minWidth, precision, type) {
    var number, prefix, method, textTransform, value;

    if (substring === '%%') {
      return '%';
    }

    // parse flags
    var leftJustify = false;
    var positivePrefix = '';
    var zeroPad = false;
    var prefixBaseX = false;
    var customPadChar = ' ';
    var flagsl = flags.length;
    var j;
    for (j = 0; j < flagsl; j++) {
      switch (flags.charAt(j)) {
        case ' ':
          positivePrefix = ' ';
          break;
        case '+':
          positivePrefix = '+';
          break;
        case '-':
          leftJustify = true;
          break;
        case "'":
          customPadChar = flags.charAt(j + 1);
          break;
        case '0':
          zeroPad = true;
          customPadChar = '0';
          break;
        case '#':
          prefixBaseX = true;
          break;
      }
    }

    // parameters may be null, undefined, empty-string or real valued
    // we want to ignore null, undefined and empty-string values
    if (!minWidth) {
      minWidth = 0;
    } else if (minWidth === '*') {
      minWidth = +a[i++];
    } else if (minWidth.charAt(0) === '*') {
      minWidth = +a[minWidth.slice(1, -1)];
    } else {
      minWidth = +minWidth;
    }

    // Note: undocumented perl feature:
    if (minWidth < 0) {
      minWidth = -minWidth;
      leftJustify = true;
    }

    if (!isFinite(minWidth)) {
      throw new Error('sprintf: (minimum-)width must be finite');
    }

    if (!precision) {
      precision = 'fFeE'.indexOf(type) > -1 ? 6 : type === 'd' ? 0 : undefined;
    } else if (precision === '*') {
      precision = +a[i++];
    } else if (precision.charAt(0) === '*') {
      precision = +a[precision.slice(1, -1)];
    } else {
      precision = +precision;
    }

    // grab value using valueIndex if required?
    value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];

    switch (type) {
      case 's':
        return _formatString(value + '', leftJustify, minWidth, precision, zeroPad, customPadChar);
      case 'c':
        return _formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
      case 'b':
        return _formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
      case 'o':
        return _formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
      case 'x':
        return _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
      case 'X':
        return _formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
      case 'u':
        return _formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
      case 'i':
      case 'd':
        number = +value || 0;
        // Plain Math.round doesn't just truncate
        number = Math.round(number - number % 1);
        prefix = number < 0 ? '-' : positivePrefix;
        value = prefix + _pad(String(Math.abs(number)), precision, '0', false);
        return justify(value, prefix, leftJustify, minWidth, zeroPad);
      case 'e':
      case 'E':
      case 'f': // @todo: Should handle locales (as per setlocale)
      case 'F':
      case 'g':
      case 'G':
        number = +value;
        prefix = number < 0 ? '-' : positivePrefix;
        method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
        textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
        value = prefix + Math.abs(number)[method](precision);
        return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
      default:
        return substring;
    }
  };

  return format.replace(regex, doFormat);
};
//# sourceMappingURL=sprintf.js.map

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Twig.js
 *
 * @copyright 2011-2016 John Roepke and the Twig.js Contributors
 * @license   Available under the BSD 2-Clause License
 * @link      https://github.com/twigjs/twig.js
 */

module.exports = __webpack_require__(3)();


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

// ## twig.factory.js
//
// This file handles creating the Twig library
module.exports = function factory() {
    const Twig = {
        VERSION: '1.14.0'
    };

    __webpack_require__(4)(Twig);
    __webpack_require__(5)(Twig);
    __webpack_require__(6)(Twig);
    __webpack_require__(8)(Twig);
    __webpack_require__(9)(Twig);
    __webpack_require__(10)(Twig);
    __webpack_require__(19)(Twig);
    __webpack_require__(20)(Twig);
    __webpack_require__(22)(Twig);
    __webpack_require__(23)(Twig);
    __webpack_require__(24)(Twig);
    __webpack_require__(25)(Twig);
    __webpack_require__(26)(Twig);
    __webpack_require__(27)(Twig);
    __webpack_require__(28)(Twig);

    Twig.exports.factory = factory;

    return Twig.exports;
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

// ## twig.core.js
//
// This file handles template level tokenizing, compiling and parsing.
module.exports = function (Twig) {
    'use strict';

    Twig.trace = false;
    Twig.debug = false;

    // Default caching to true for the improved performance it offers
    Twig.cache = true;

    Twig.noop = function () {};

    Twig.merge = function (target, source, onlyChanged) {
        Object.keys(source).forEach(key => {
            if (onlyChanged && !(key in target)) {
                return;
            }

            target[key] = source[key];
        });

        return target;
    };

    /**
     * Exception thrown by twig.js.
     */
    Twig.Error = function (message, file) {
        this.message = message;
        this.name = 'TwigException';
        this.type = 'TwigException';
        this.file = file;
    };

    /**
     * Get the string representation of a Twig error.
     */
    Twig.Error.prototype.toString = function () {
        const output = this.name + ': ' + this.message;

        return output;
    };

    /**
     * Wrapper for logging to the console.
     */
    Twig.log = {
        trace(...args) {
            if (Twig.trace && console) {
                console.log(Array.prototype.slice.call(args));
            }
        },
        debug(...args) {
            if (Twig.debug && console) {
                console.log(Array.prototype.slice.call(args));
            }
        }
    };

    if (typeof console === 'undefined') {
        Twig.log.error = function () {};
    } else if (typeof console.error !== 'undefined') {
        Twig.log.error = function (...args) {
            console.error(...args);
        };
    } else if (typeof console.log !== 'undefined') {
        Twig.log.error = function (...args) {
            console.log(...args);
        };
    }

    /**
     * Container for methods related to handling high level template tokens
     *      (for example: {{ expression }}, {% logic %}, {# comment #}, raw data)
     */
    Twig.token = {};

    /**
     * Token types.
     */
    Twig.token.type = {
        output: 'output',
        logic: 'logic',
        comment: 'comment',
        raw: 'raw',
        outputWhitespacePre: 'output_whitespace_pre',
        outputWhitespacePost: 'output_whitespace_post',
        outputWhitespaceBoth: 'output_whitespace_both',
        logicWhitespacePre: 'logic_whitespace_pre',
        logicWhitespacePost: 'logic_whitespace_post',
        logicWhitespaceBoth: 'logic_whitespace_both'
    };

    /**
     * Token syntax definitions.
     */
    Twig.token.definitions = [
        {
            type: Twig.token.type.raw,
            open: '{% raw %}',
            close: '{% endraw %}'
        },
        {
            type: Twig.token.type.raw,
            open: '{% verbatim %}',
            close: '{% endverbatim %}'
        },
        // *Whitespace type tokens*
        //
        // These typically take the form `{{- expression -}}` or `{{- expression }}` or `{{ expression -}}`.
        {
            type: Twig.token.type.outputWhitespacePre,
            open: '{{-',
            close: '}}'
        },
        {
            type: Twig.token.type.outputWhitespacePost,
            open: '{{',
            close: '-}}'
        },
        {
            type: Twig.token.type.outputWhitespaceBoth,
            open: '{{-',
            close: '-}}'
        },
        {
            type: Twig.token.type.logicWhitespacePre,
            open: '{%-',
            close: '%}'
        },
        {
            type: Twig.token.type.logicWhitespacePost,
            open: '{%',
            close: '-%}'
        },
        {
            type: Twig.token.type.logicWhitespaceBoth,
            open: '{%-',
            close: '-%}'
        },
        // *Output type tokens*
        //
        // These typically take the form `{{ expression }}`.
        {
            type: Twig.token.type.output,
            open: '{{',
            close: '}}'
        },
        // *Logic type tokens*
        //
        // These typically take a form like `{% if expression %}` or `{% endif %}`
        {
            type: Twig.token.type.logic,
            open: '{%',
            close: '%}'
        },
        // *Comment type tokens*
        //
        // These take the form `{# anything #}`
        {
            type: Twig.token.type.comment,
            open: '{#',
            close: '#}'
        }
    ];

    /**
     * What characters start "strings" in token definitions. We need this to ignore token close
     * strings inside an expression.
     */
    Twig.token.strings = ['"', '\''];

    Twig.token.findStart = function (template) {
        const output = {
            position: null,
            def: null
        };
        let closePosition = null;
        const len = Twig.token.definitions.length;
        let i;
        let tokenTemplate;
        let firstKeyPosition;
        let closeKeyPosition;

        for (i = 0; i < len; i++) {
            tokenTemplate = Twig.token.definitions[i];
            firstKeyPosition = template.indexOf(tokenTemplate.open);
            closeKeyPosition = template.indexOf(tokenTemplate.close);

            Twig.log.trace('Twig.token.findStart: ', 'Searching for ', tokenTemplate.open, ' found at ', firstKeyPosition);

            // Special handling for mismatched tokens
            if (firstKeyPosition >= 0) {
                // This token matches the template
                if (tokenTemplate.open.length !== tokenTemplate.close.length) {
                    // This token has mismatched closing and opening tags
                    if (closeKeyPosition < 0) {
                        // This token's closing tag does not match the template
                        continue;
                    }
                }
            }
            // Does this token occur before any other types?

            if (firstKeyPosition >= 0 && (output.position === null || firstKeyPosition < output.position)) {
                output.position = firstKeyPosition;
                output.def = tokenTemplate;
                closePosition = closeKeyPosition;
            } else if (firstKeyPosition >= 0 && output.position !== null && firstKeyPosition === output.position) {
                /* This token exactly matches another token,
                greedily match to check if this token has a greater specificity */
                if (tokenTemplate.open.length > output.def.open.length) {
                    // This token's opening tag is more specific than the previous match
                    output.position = firstKeyPosition;
                    output.def = tokenTemplate;
                    closePosition = closeKeyPosition;
                } else if (tokenTemplate.open.length === output.def.open.length) {
                    if (tokenTemplate.close.length > output.def.close.length) {
                        // This token's opening tag is as specific as the previous match,
                        // but the closing tag has greater specificity
                        if (closeKeyPosition >= 0 && closeKeyPosition < closePosition) {
                            // This token's closing tag exists in the template,
                            // and it occurs sooner than the previous match
                            output.position = firstKeyPosition;
                            output.def = tokenTemplate;
                            closePosition = closeKeyPosition;
                        }
                    } else if (closeKeyPosition >= 0 && closeKeyPosition < closePosition) {
                        // This token's closing tag is not more specific than the previous match,
                        // but it occurs sooner than the previous match
                        output.position = firstKeyPosition;
                        output.def = tokenTemplate;
                        closePosition = closeKeyPosition;
                    }
                }
            }
        }

        return output;
    };

    Twig.token.findEnd = function (template, tokenDef, start) {
        let end = null;
        let found = false;
        let offset = 0;

        // String position variables
        let strPos = null;
        let strFound = null;
        let pos = null;
        let endOffset = null;
        let thisStrPos = null;
        let endStrPos = null;

        // For loop variables
        let i;
        let l;

        while (!found) {
            strPos = null;
            strFound = null;
            pos = template.indexOf(tokenDef.close, offset);

            if (pos >= 0) {
                end = pos;
                found = true;
            } else {
                // Throw an exception
                throw new Twig.Error('Unable to find closing bracket \'' + tokenDef.close +
                                '\' opened near template position ' + start);
            }

            // Ignore quotes within comments; just look for the next comment close sequence,
            // regardless of what comes before it. https://github.com/justjohn/twig.js/issues/95
            if (tokenDef.type === Twig.token.type.comment) {
                break;
            }
            // Ignore quotes within raw tag
            // Fixes #283

            if (tokenDef.type === Twig.token.type.raw) {
                break;
            }

            l = Twig.token.strings.length;
            for (i = 0; i < l; i += 1) {
                thisStrPos = template.indexOf(Twig.token.strings[i], offset);

                if (thisStrPos > 0 && thisStrPos < pos &&
                        (strPos === null || thisStrPos < strPos)) {
                    strPos = thisStrPos;
                    strFound = Twig.token.strings[i];
                }
            }

            // We found a string before the end of the token, now find the string's end and set the search offset to it
            if (strPos !== null) {
                endOffset = strPos + 1;
                end = null;
                found = false;
                for (;;) {
                    endStrPos = template.indexOf(strFound, endOffset);
                    if (endStrPos < 0) {
                        throw Twig.Error('Unclosed string in template');
                    }
                    // Ignore escaped quotes

                    if (template.substr(endStrPos - 1, 1) === '\\') {
                        endOffset = endStrPos + 1;
                    } else {
                        offset = endStrPos + 1;
                        break;
                    }
                }
            }
        }

        return end;
    };

    /**
     * Convert a template into high-level tokens.
     */
    Twig.tokenize = function (template) {
        const tokens = [];
        // An offset for reporting errors locations in the template.
        let errorOffset = 0;

        // The start and type of the first token found in the template.
        let foundToken = null;
        // The end position of the matched token.
        let end = null;

        while (template.length > 0) {
            // Find the first occurance of any token type in the template
            foundToken = Twig.token.findStart(template);

            Twig.log.trace('Twig.tokenize: ', 'Found token: ', foundToken);

            if (foundToken.position === null) {
                // No more tokens -> add the rest of the template as a raw-type token
                tokens.push({
                    type: Twig.token.type.raw,
                    value: template
                });
                template = '';
            } else {
                // Add a raw type token for anything before the start of the token
                if (foundToken.position > 0) {
                    tokens.push({
                        type: Twig.token.type.raw,
                        value: template.substring(0, foundToken.position)
                    });
                }

                template = template.substr(foundToken.position + foundToken.def.open.length);
                errorOffset += foundToken.position + foundToken.def.open.length;

                // Find the end of the token
                end = Twig.token.findEnd(template, foundToken.def, errorOffset);

                Twig.log.trace('Twig.tokenize: ', 'Token ends at ', end);

                tokens.push({
                    type: foundToken.def.type,
                    value: template.substring(0, end).trim()
                });

                if (template.substr(end + foundToken.def.close.length, 1) === '\n') {
                    switch (foundToken.def.type) {
                        case 'logic_whitespace_pre':
                        case 'logic_whitespace_post':
                        case 'logic_whitespace_both':
                        case 'logic':
                            // Newlines directly after logic tokens are ignored
                            end += 1;
                            break;
                        default:
                            break;
                    }
                }

                template = template.substr(end + foundToken.def.close.length);

                // Increment the position in the template
                errorOffset += end + foundToken.def.close.length;
            }
        }

        return tokens;
    };

    Twig.compile = function (tokens) {
        const self = this;
        try {
            // Output and intermediate stacks
            const output = [];
            const stack = [];
            // The tokens between open and close tags
            let intermediateOutput = [];

            let token = null;
            let logicToken = null;
            let unclosedToken = null;
            // Temporary previous token.
            let prevToken = null;
            // Temporary previous output.
            let prevOutput = null;
            // Temporary previous intermediate output.
            let prevIntermediateOutput = null;
            // The previous token's template
            let prevTemplate = null;
            // Token lookahead
            let nextToken = null;
            // The output token
            let tokOutput = null;

            // Logic Token values
            let type = null;
            let open = null;
            let next = null;

            const compileOutput = function (token) {
                Twig.expression.compile.call(self, token);
                if (stack.length > 0) {
                    intermediateOutput.push(token);
                } else {
                    output.push(token);
                }
            };

            const compileLogic = function (token) {
                // Compile the logic token
                logicToken = Twig.logic.compile.call(self, token);

                type = logicToken.type;
                open = Twig.logic.handler[type].open;
                next = Twig.logic.handler[type].next;

                Twig.log.trace('Twig.compile: ', 'Compiled logic token to ', logicToken,
                    ' next is: ', next, ' open is : ', open);

                // Not a standalone token, check logic stack to see if this is expected
                if (open !== undefined && !open) {
                    prevToken = stack.pop();
                    prevTemplate = Twig.logic.handler[prevToken.type];

                    if (prevTemplate.next.indexOf(type) < 0) {
                        throw new Error(type + ' not expected after a ' + prevToken.type);
                    }

                    prevToken.output = prevToken.output || [];

                    prevToken.output = prevToken.output.concat(intermediateOutput);
                    intermediateOutput = [];

                    tokOutput = {
                        type: Twig.token.type.logic,
                        token: prevToken
                    };
                    if (stack.length > 0) {
                        intermediateOutput.push(tokOutput);
                    } else {
                        output.push(tokOutput);
                    }
                }

                // This token requires additional tokens to complete the logic structure.
                if (next !== undefined && next.length > 0) {
                    Twig.log.trace('Twig.compile: ', 'Pushing ', logicToken, ' to logic stack.');

                    if (stack.length > 0) {
                        // Put any currently held output into the output list of the logic operator
                        // currently at the head of the stack before we push a new one on.
                        prevToken = stack.pop();
                        prevToken.output = prevToken.output || [];
                        prevToken.output = prevToken.output.concat(intermediateOutput);
                        stack.push(prevToken);
                        intermediateOutput = [];
                    }

                    // Push the new logic token onto the logic stack
                    stack.push(logicToken);
                } else if (open !== undefined && open) {
                    tokOutput = {
                        type: Twig.token.type.logic,
                        token: logicToken
                    };
                    // Standalone token (like {% set ... %}
                    if (stack.length > 0) {
                        intermediateOutput.push(tokOutput);
                    } else {
                        output.push(tokOutput);
                    }
                }
            };

            while (tokens.length > 0) {
                token = tokens.shift();
                prevOutput = output[output.length - 1];
                prevIntermediateOutput = intermediateOutput[intermediateOutput.length - 1];
                nextToken = tokens[0];
                Twig.log.trace('Compiling token ', token);
                switch (token.type) {
                    case Twig.token.type.raw:
                        if (stack.length > 0) {
                            intermediateOutput.push(token);
                        } else {
                            output.push(token);
                        }

                        break;

                    case Twig.token.type.logic:
                        compileLogic.call(self, token);
                        break;

                    // Do nothing, comments should be ignored
                    case Twig.token.type.comment:
                        break;

                    case Twig.token.type.output:
                        compileOutput.call(self, token);
                        break;

                    // Kill whitespace ahead and behind this token
                    case Twig.token.type.logicWhitespacePre:
                    case Twig.token.type.logicWhitespacePost:
                    case Twig.token.type.logicWhitespaceBoth:
                    case Twig.token.type.outputWhitespacePre:
                    case Twig.token.type.outputWhitespacePost:
                    case Twig.token.type.outputWhitespaceBoth:
                        if (token.type !== Twig.token.type.outputWhitespacePost && token.type !== Twig.token.type.logicWhitespacePost) {
                            if (prevOutput) {
                                // If the previous output is raw, pop it off
                                if (prevOutput.type === Twig.token.type.raw) {
                                    output.pop();

                                    // If the previous output is not just whitespace, trim it
                                    if (prevOutput.value.match(/^\s*$/) === null) {
                                        prevOutput.value = prevOutput.value.trim();
                                        // Repush the previous output
                                        output.push(prevOutput);
                                    }
                                }
                            }

                            if (prevIntermediateOutput) {
                                // If the previous intermediate output is raw, pop it off
                                if (prevIntermediateOutput.type === Twig.token.type.raw) {
                                    intermediateOutput.pop();

                                    // If the previous output is not just whitespace, trim it
                                    if (prevIntermediateOutput.value.match(/^\s*$/) === null) {
                                        prevIntermediateOutput.value = prevIntermediateOutput.value.trim();
                                        // Repush the previous intermediate output
                                        intermediateOutput.push(prevIntermediateOutput);
                                    }
                                }
                            }
                        }

                        // Compile this token
                        switch (token.type) {
                            case Twig.token.type.outputWhitespacePre:
                            case Twig.token.type.outputWhitespacePost:
                            case Twig.token.type.outputWhitespaceBoth:
                                compileOutput.call(self, token);
                                break;
                            case Twig.token.type.logicWhitespacePre:
                            case Twig.token.type.logicWhitespacePost:
                            case Twig.token.type.logicWhitespaceBoth:
                                compileLogic.call(self, token);
                                break;
                            default:
                                break;
                        }

                        if (token.type !== Twig.token.type.outputWhitespacePre && token.type !== Twig.token.type.logicWhitespacePre) {
                            if (nextToken) {
                                // If the next token is raw, shift it out
                                if (nextToken.type === Twig.token.type.raw) {
                                    tokens.shift();

                                    // If the next token is not just whitespace, trim it
                                    if (nextToken.value.match(/^\s*$/) === null) {
                                        nextToken.value = nextToken.value.trim();
                                        // Unshift the next token
                                        tokens.unshift(nextToken);
                                    }
                                }
                            }
                        }

                        break;
                    default:
                        break;
                }

                Twig.log.trace('Twig.compile: ', ' Output: ', output,
                    ' Logic Stack: ', stack,
                    ' Pending Output: ', intermediateOutput
                );
            }

            // Verify that there are no logic tokens left in the stack.
            if (stack.length > 0) {
                unclosedToken = stack.pop();
                throw new Error('Unable to find an end tag for ' + unclosedToken.type +
                                ', expecting one of ' + unclosedToken.next);
            }

            return output;
        } catch (error) {
            if (self.options.rethrow) {
                if (error.type === 'TwigException' && !error.file) {
                    error.file = self.id;
                }

                throw error;
            } else {
                Twig.log.error('Error compiling twig template ' + self.id + ': ');
                if (error.stack) {
                    Twig.log.error(error.stack);
                } else {
                    Twig.log.error(error.toString());
                }
            }
        }
    };

    function handleException(state, ex) {
        if (state.template.options.rethrow) {
            if (typeof ex === 'string') {
                ex = new Twig.Error(ex);
            }

            if (ex.type === 'TwigException' && !ex.file) {
                ex.file = state.template.id;
            }

            throw ex;
        } else {
            Twig.log.error('Error parsing twig template ' + state.template.id + ': ');
            if (ex.stack) {
                Twig.log.error(ex.stack);
            } else {
                Twig.log.error(ex.toString());
            }

            if (Twig.debug) {
                return ex.toString();
            }
        }
    }

    /**
     * Tokenize and compile a string template.
     *
     * @param {string} data The template.
     *
     * @return {Array} The compiled tokens.
     */
    Twig.prepare = function (data) {
        // Tokenize
        Twig.log.debug('Twig.prepare: ', 'Tokenizing ', data);
        const rawTokens = Twig.tokenize.call(this, data);

        // Compile
        Twig.log.debug('Twig.prepare: ', 'Compiling ', rawTokens);
        const tokens = Twig.compile.call(this, rawTokens);

        Twig.log.debug('Twig.prepare: ', 'Compiled ', tokens);

        return tokens;
    };

    /**
     * Join the output token's stack and escape it if needed
     *
     * @param {Array} Output token's stack
     *
     * @return {string|String} Autoescaped output
     */
    Twig.output = function (output) {
        const {autoescape} = this.options;

        if (!autoescape) {
            return output.join('');
        }

        const strategy = (typeof autoescape === 'string') ? autoescape : 'html';

        const escapedOutput = output.map(str => {
            if (
                str &&
                (str.twigMarkup !== true && str.twigMarkup !== strategy) &&
                !(strategy === 'html' && str.twigMarkup === 'html_attr')
            ) {
                str = Twig.filters.escape(str, [strategy]);
            }

            return str;
        });

        if (escapedOutput.length === 0) {
            return '';
        }

        return new Twig.Markup(escapedOutput.join(''), true);
    };

    // Namespace for template storage and retrieval
    Twig.Templates = {
        /**
         * Registered template loaders - use Twig.Templates.registerLoader to add supported loaders
         * @type {Object}
         */
        loaders: {},

        /**
         * Registered template parsers - use Twig.Templates.registerParser to add supported parsers
         * @type {Object}
         */
        parsers: {},

        /**
         * Cached / loaded templates
         * @type {Object}
         */
        registry: {}
    };

    /**
     * Is this id valid for a twig template?
     *
     * @param {string} id The ID to check.
     *
     * @throws {Twig.Error} If the ID is invalid or used.
     * @return {boolean} True if the ID is valid.
     */
    Twig.validateId = function (id) {
        if (id === 'prototype') {
            throw new Twig.Error(id + ' is not a valid twig identifier');
        } else if (Twig.cache && Object.hasOwnProperty.call(Twig.Templates.registry, id)) {
            throw new Twig.Error('There is already a template with the ID ' + id);
        }

        return true;
    };

    /**
     * Register a template loader
     *
     * @example
     * Twig.extend(function (Twig) {
     *    Twig.Templates.registerLoader('custom_loader', function (location, params, callback, errorCallback) {
     *        // ... load the template ...
     *        params.data = loadedTemplateData;
     *        // create and return the template
     *        var template = new Twig.Template(params);
     *        if (typeof callback === 'function') {
     *            callback(template);
     *        }
     *        return template;
     *    });
     * });
     *
     * @param {String} methodName The method this loader is intended for (ajax, fs)
     * @param {Function} func The function to execute when loading the template
     * @param {Object|undefined} scope Optional scope parameter to bind func to
     *
     * @throws Twig.Error
     *
     * @return {void}
     */
    Twig.Templates.registerLoader = function (methodName, func, scope) {
        if (typeof func !== 'function') {
            throw new Twig.Error('Unable to add loader for ' + methodName + ': Invalid function reference given.');
        }

        if (scope) {
            func = func.bind(scope);
        }

        this.loaders[methodName] = func;
    };

    /**
     * Remove a registered loader
     *
     * @param {String} methodName The method name for the loader you wish to remove
     *
     * @return {void}
     */
    Twig.Templates.unRegisterLoader = function (methodName) {
        if (this.isRegisteredLoader(methodName)) {
            delete this.loaders[methodName];
        }
    };

    /**
     * See if a loader is registered by its method name
     *
     * @param {String} methodName The name of the loader you are looking for
     *
     * @return {boolean}
     */
    Twig.Templates.isRegisteredLoader = function (methodName) {
        return Object.hasOwnProperty.call(this.loaders, methodName);
    };

    /**
     * Register a template parser
     *
     * @example
     * Twig.extend(function (Twig) {
     *    Twig.Templates.registerParser('custom_parser', function (params) {
     *        // this template source can be accessed in params.data
     *        var template = params.data
     *
     *        // ... custom process that modifies the template
     *
     *        // return the parsed template
     *        return template;
     *    });
     * });
     *
     * @param {String} methodName The method this parser is intended for (twig, source)
     * @param {Function} func The function to execute when parsing the template
     * @param {Object|undefined} scope Optional scope parameter to bind func to
     *
     * @throws Twig.Error
     *
     * @return {void}
     */
    Twig.Templates.registerParser = function (methodName, func, scope) {
        if (typeof func !== 'function') {
            throw new Twig.Error('Unable to add parser for ' + methodName + ': Invalid function regerence given.');
        }

        if (scope) {
            func = func.bind(scope);
        }

        this.parsers[methodName] = func;
    };

    /**
     * Remove a registered parser
     *
     * @param {String} methodName The method name for the parser you wish to remove
     *
     * @return {void}
     */
    Twig.Templates.unRegisterParser = function (methodName) {
        if (this.isRegisteredParser(methodName)) {
            delete this.parsers[methodName];
        }
    };

    /**
     * See if a parser is registered by its method name
     *
     * @param {String} methodName The name of the parser you are looking for
     *
     * @return {boolean}
     */
    Twig.Templates.isRegisteredParser = function (methodName) {
        return Object.hasOwnProperty.call(this.parsers, methodName);
    };

    /**
     * Save a template object to the store.
     *
     * @param {Twig.Template} template   The twig.js template to store.
     */
    Twig.Templates.save = function (template) {
        if (template.id === undefined) {
            throw new Twig.Error('Unable to save template with no id');
        }

        Twig.Templates.registry[template.id] = template;
    };

    /**
     * Load a previously saved template from the store.
     *
     * @param {string} id   The ID of the template to load.
     *
     * @return {Twig.Template} A twig.js template stored with the provided ID.
     */
    Twig.Templates.load = function (id) {
        if (!Object.hasOwnProperty.call(Twig.Templates.registry, id)) {
            return null;
        }

        return Twig.Templates.registry[id];
    };

    /**
     * Load a template from a remote location using AJAX and saves in with the given ID.
     *
     * Available parameters:
     *
     *      async:       Should the HTTP request be performed asynchronously.
     *                      Defaults to true.
     *      method:      What method should be used to load the template
     *                      (fs or ajax)
     *      parser:      What method should be used to parse the template
     *                      (twig or source)
     *      precompiled: Has the template already been compiled.
     *
     * @param {string} location  The remote URL to load as a template.
     * @param {Object} params The template parameters.
     * @param {function} callback  A callback triggered when the template finishes loading.
     * @param {function} errorCallback  A callback triggered if an error occurs loading the template.
     *
     *
     */
    Twig.Templates.loadRemote = function (location, params, callback, errorCallback) {
        // Default to the URL so the template is cached.
        const id = typeof params.id === 'undefined' ? location : params.id;
        const cached = Twig.Templates.registry[id];

        // Check for existing template
        if (Twig.cache && typeof cached !== 'undefined') {
            // A template is already saved with the given id.
            if (typeof callback === 'function') {
                callback(cached);
            }
            // TODO: if async, return deferred promise

            return cached;
        }

        // If the parser name hasn't been set, default it to twig
        params.parser = params.parser || 'twig';
        params.id = id;

        // Default to async
        if (typeof params.async === 'undefined') {
            params.async = true;
        }

        // Assume 'fs' if the loader is not defined
        const loader = this.loaders[params.method] || this.loaders.fs;
        return loader.call(this, location, params, callback, errorCallback);
    };

    // Determine object type
    function is(type, obj) {
        const clas = Object.prototype.toString.call(obj).slice(8, -1);
        return obj !== undefined && obj !== null && clas === type;
    }

    /**
     * A wrapper for template blocks.
     *
     * @param  {Twig.Template} The template that the block was originally defined in.
     * @param  {Object} The compiled block token.
     */
    Twig.Block = function (template, token) {
        this.template = template;
        this.token = token;
    };

    /**
     * Render the block using a specific parse state and context.
     *
     * @param  {Twig.ParseState} parseState
     * @param  {Object} context
     *
     * @return {Promise}
     */
    Twig.Block.prototype.render = function (parseState, context) {
        const originalTemplate = parseState.template;
        let promise;

        parseState.template = this.template;

        if (this.token.expression) {
            promise = Twig.expression.parseAsync.call(parseState, this.token.output, context);
        } else {
            promise = parseState.parseAsync(this.token.output, context);
        }

        return promise
            .then(value => {
                return Twig.expression.parseAsync.call(
                    parseState,
                    {
                        type: Twig.expression.type.string,
                        value
                    },
                    context
                );
            })
            .then(output => {
                parseState.template = originalTemplate;

                return output;
            });
    };

    /**
     * Holds the state needed to parse a template.
     *
     * @param {Twig.Template} template The template that the tokens being parsed are associated with.
     * @param {Object} blockOverrides Any blocks that should override those defined in the associated template.
     */
    Twig.ParseState = function (template, blockOverrides) {
        this.renderedBlocks = {};
        this.overrideBlocks = blockOverrides === undefined ? {} : blockOverrides;
        this.context = {};
        this.macros = {};
        this.nestingStack = [];
        this.template = template;
    };

    /**
     * Get a block by its name, resolving in the following order:
     *     - override blocks specified when initialized (except when excluded)
     *     - blocks resolved from the associated template
     *     - blocks resolved from the parent template when extending
     *
     * @param {String} name The name of the block to return.
     * @param {Boolean} checkOnlyInheritedBlocks Whether to skip checking the overrides and associated template, will not skip by default.
     *
     * @return {Twig.Block|undefined}
     */
    Twig.ParseState.prototype.getBlock = function (name, checkOnlyInheritedBlocks) {
        let block;

        if (checkOnlyInheritedBlocks !== true) {
            // Blocks specified when initialized
            block = this.overrideBlocks[name];
        }

        if (block === undefined) {
            // Block defined by the associated template
            block = this.template.getBlock(name, checkOnlyInheritedBlocks);
        }

        if (block === undefined && this.template.parentTemplate !== null) {
            // Block defined in the parent template when extending
            block = this.template.parentTemplate.getBlock(name);
        }

        return block;
    };

    /**
     * Get all the available blocks, resolving in the following order:
     *     - override blocks specified when initialized
     *     - blocks resolved from the associated template
     *     - blocks resolved from the parent template when extending (except when excluded)
     *
     * @param {Boolean} includeParentBlocks Whether to get blocks from the parent template when extending, will always do so by default.
     *
     * @return {Object}
     */
    Twig.ParseState.prototype.getBlocks = function (includeParentBlocks) {
        let blocks = {};

        if (includeParentBlocks !== false &&
            this.template.parentTemplate !== null &&
            // Prevent infinite loop
            this.template.parentTemplate !== this.template
        ) {
            // Blocks from the parent template when extending
            blocks = this.template.parentTemplate.getBlocks();
        }

        blocks = {
            ...blocks,
            // Override with any blocks defined within the associated template
            ...this.template.getBlocks(),
            // Override with any blocks specified when initialized
            ...this.overrideBlocks
        };

        return blocks;
    };

    /**
     * Get the closest token of a specific type to the current nest level.
     *
     * @param  {String} type  The logic token type
     *
     * @return {Object}
     */
    Twig.ParseState.prototype.getNestingStackToken = function (type) {
        let matchingToken;

        this.nestingStack.forEach(token => {
            if (matchingToken === undefined && token.type === type) {
                matchingToken = token;
            }
        });

        return matchingToken;
    };

    /**
     * Parse a set of tokens using the current state.
     *
     * @param {Array} tokens The compiled tokens.
     * @param {Object} context The context to set the state to while parsing.
     * @param {Boolean} allowAsync Whether to parse asynchronously.
     * @param {Object} blocks Blocks that should override any defined while parsing.
     *
     * @return {String} The rendered tokens.
     *
     */
    Twig.ParseState.prototype.parse = function (tokens, context, allowAsync) {
        const state = this;
        let output = [];

        // Store any error that might be thrown by the promise chain.
        let err = null;

        // This will be set to isAsync if template renders synchronously
        let isAsync = true;
        let promise = null;
        // Track logic chains
        let chain = true;

        if (context) {
            state.context = context;
        }

        /*
         * Extracted into it's own function such that the function
         * does not get recreated over and over again in the `forEach`
         * loop below. This method can be compiled and optimized
         * a single time instead of being recreated on each iteration.
         */
        function outputPush(o) {
            output.push(o);
        }

        function parseTokenLogic(logic) {
            if (typeof logic.chain !== 'undefined') {
                chain = logic.chain;
            }

            if (typeof logic.context !== 'undefined') {
                state.context = logic.context;
            }

            if (typeof logic.output !== 'undefined') {
                output.push(logic.output);
            }
        }

        promise = Twig.async.forEach(tokens, token => {
            Twig.log.debug('Twig.ParseState.parse: ', 'Parsing token: ', token);

            switch (token.type) {
                case Twig.token.type.raw:
                    output.push(Twig.filters.raw(token.value));
                    break;

                case Twig.token.type.logic:
                    return Twig.logic.parseAsync.call(state, token.token /* logicToken */, state.context, chain)
                        .then(parseTokenLogic);
                case Twig.token.type.comment:
                    // Do nothing, comments should be ignored
                    break;

                // Fall through whitespace to output
                case Twig.token.type.outputWhitespacePre:
                case Twig.token.type.outputWhitespacePost:
                case Twig.token.type.outputWhitespaceBoth:
                case Twig.token.type.output:
                    Twig.log.debug('Twig.ParseState.parse: ', 'Output token: ', token.stack);
                    // Parse the given expression in the given context
                    return Twig.expression.parseAsync.call(state, token.stack, state.context)
                        .then(outputPush);
                default:
                    break;
            }
        }).then(() => {
            output = Twig.output.call(state.template, output);
            isAsync = false;
            return output;
        }).catch(error => {
            if (allowAsync) {
                handleException(state, error);
            }

            err = error;
        });

        // If `allowAsync` we will always return a promise since we do not
        // know in advance if we are going to run asynchronously or not.
        if (allowAsync) {
            return promise;
        }

        // Handle errors here if we fail synchronously.
        if (err !== null) {
            return handleException(state, err);
        }

        // If `allowAsync` is not true we should not allow the user
        // to use asynchronous functions or filters.
        if (isAsync) {
            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');
        }

        return output;
    };

    /**
     * Create a new twig.js template.
     *
     * Parameters: {
     *      data:   The template, either pre-compiled tokens or a string template
     *      id:     The name of this template
     * }
     *
     * @param {Object} params The template parameters.
     */
    Twig.Template = function (params) {
        const {data, id, base, path, url, name, method, options} = params;

        // # What is stored in a Twig.Template
        //
        // The Twig Template hold several chucks of data.
        //
        //     {
        //          id:     The token ID (if any)
        //          tokens: The list of tokens that makes up this template.
        //          base:   The base template (if any)
        //            options:  {
        //                Compiler/parser options
        //
        //                strict_variables: true/false
        //                    Should missing variable/keys emit an error message. If false, they default to null.
        //            }
        //     }
        //

        this.base = base;
        this.blocks = {
            defined: {},
            imported: {}
        };
        this.id = id;
        this.method = method;
        this.name = name;
        this.options = options;
        this.parentTemplate = null;
        this.path = path;
        this.url = url;

        if (is('String', data)) {
            this.tokens = Twig.prepare.call(this, data);
        } else {
            this.tokens = data;
        }

        if (id !== undefined) {
            Twig.Templates.save(this);
        }
    };

    /**
     * Get a block by its name, resolving in the following order:
     *     - blocks defined in the template itself
     *     - blocks imported from another template
     *
     * @param {String} name The name of the block to return.
     * @param {Boolean} checkOnlyInheritedBlocks Whether to skip checking the blocks defined in the template itself, will not skip by default.
     *
     * @return {Twig.Block|undefined}
     */
    Twig.Template.prototype.getBlock = function (name, checkOnlyInheritedBlocks) {
        let block;

        if (checkOnlyInheritedBlocks !== true) {
            block = this.blocks.defined[name];
        }

        if (block === undefined) {
            block = this.blocks.imported[name];
        }

        return block;
    };

    /**
     * Get all the available blocks, resolving in the following order:
     *     - blocks defined in the template itself
     *     - blocks imported from other templates
     *
     * @return {Object}
     */
    Twig.Template.prototype.getBlocks = function () {
        let blocks = {};

        blocks = {
            ...blocks,
            // Get any blocks imported from other templates
            ...this.blocks.imported,
            // Override with any blocks defined within the template itself
            ...this.blocks.defined
        };

        return blocks;
    };

    Twig.Template.prototype.render = function (context, params, allowAsync) {
        const template = this;

        params = params || {};

        return Twig.async.potentiallyAsync(template, allowAsync, () => {
            const state = new Twig.ParseState(template, params.blocks);

            return state.parseAsync(template.tokens, context)
                .then(output => {
                    let parentTemplate;
                    let url;

                    if (template.parentTemplate !== null) {
                        // This template extends another template

                        if (template.options.allowInlineIncludes) {
                            // The template is provided inline
                            parentTemplate = Twig.Templates.load(template.parentTemplate);

                            if (parentTemplate) {
                                parentTemplate.options = template.options;
                            }
                        }

                        // Check for the template file via include
                        if (!parentTemplate) {
                            url = Twig.path.parsePath(template, template.parentTemplate);

                            parentTemplate = Twig.Templates.loadRemote(url, {
                                method: template.getLoaderMethod(),
                                base: template.base,
                                async: false,
                                id: url,
                                options: template.options
                            });
                        }

                        template.parentTemplate = parentTemplate;

                        return template.parentTemplate.renderAsync(
                            state.context,
                            {
                                blocks: state.getBlocks(false),
                                isInclude: true
                            }
                        );
                    }

                    if (params.isInclude === true) {
                        return output;
                    }

                    return output.valueOf();
                });
        });
    };

    Twig.Template.prototype.importFile = function (file) {
        let url = null;
        let subTemplate;
        if (!this.url && this.options.allowInlineIncludes) {
            file = this.path ? Twig.path.parsePath(this, file) : file;
            subTemplate = Twig.Templates.load(file);

            if (!subTemplate) {
                subTemplate = Twig.Templates.loadRemote(url, {
                    id: file,
                    method: this.getLoaderMethod(),
                    async: false,
                    path: file,
                    options: this.options
                });

                if (!subTemplate) {
                    throw new Twig.Error('Unable to find the template ' + file);
                }
            }

            subTemplate.options = this.options;

            return subTemplate;
        }

        url = Twig.path.parsePath(this, file);

        // Load blocks from an external file
        subTemplate = Twig.Templates.loadRemote(url, {
            method: this.getLoaderMethod(),
            base: this.base,
            async: false,
            options: this.options,
            id: url
        });

        return subTemplate;
    };

    Twig.Template.prototype.getLoaderMethod = function () {
        if (this.path) {
            return 'fs';
        }

        if (this.url) {
            return 'ajax';
        }

        return this.method || 'fs';
    };

    Twig.Template.prototype.compile = function (options) {
        // Compile the template into raw JS
        return Twig.compiler.compile(this, options);
    };

    /**
     * Create safe output
     *
     * @param {string} Content safe to output
     *
     * @return {String} Content wrapped into a String
     */

    Twig.Markup = function (content, strategy) {
        if (typeof content !== 'string' || content.length === 0) {
            return content;
        }

        /* eslint-disable no-new-wrappers, unicorn/new-for-builtins */
        const output = new String(content);
        /* eslint-enable */
        output.twigMarkup = (typeof strategy === 'undefined') ? true : strategy;

        return output;
    };

    return Twig;
};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

// ## twig.compiler.js
//
// This file handles compiling templates into JS
module.exports = function (Twig) {
    /**
     * Namespace for compilation.
     */
    Twig.compiler = {
        module: {}
    };

    // Compile a Twig Template to output.
    Twig.compiler.compile = function (template, options) {
        // Get tokens
        const tokens = JSON.stringify(template.tokens);
        const {id} = template;
        let output = null;

        if (options.module) {
            if (Twig.compiler.module[options.module] === undefined) {
                throw new Twig.Error('Unable to find module type ' + options.module);
            }

            output = Twig.compiler.module[options.module](id, tokens, options.twig);
        } else {
            output = Twig.compiler.wrap(id, tokens);
        }

        return output;
    };

    Twig.compiler.module = {
        amd(id, tokens, pathToTwig) {
            return 'define(["' + pathToTwig + '"], function (Twig) {\n\tvar twig, templates;\ntwig = Twig.twig;\ntemplates = ' + Twig.compiler.wrap(id, tokens) + '\n\treturn templates;\n});';
        },
        node(id, tokens) {
            return 'var twig = require("twig").twig;\nexports.template = ' + Twig.compiler.wrap(id, tokens);
        },
        cjs2(id, tokens, pathToTwig) {
            return 'module.declare([{ twig: "' + pathToTwig + '" }], function (require, exports, module) {\n\tvar twig = require("twig").twig;\n\texports.template = ' + Twig.compiler.wrap(id, tokens) + '\n});';
        }
    };

    Twig.compiler.wrap = function (id, tokens) {
        return 'twig({id:"' + id.replace('"', '\\"') + '", data:' + tokens + ', precompiled: true});\n';
    };

    return Twig;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// ## twig.expression.js
//
// This file handles tokenizing, compiling and parsing expressions.
module.exports = function (Twig) {
    'use strict';

    function parseParams(state, params, context) {
        if (params) {
            return Twig.expression.parseAsync.call(state, params, context);
        }

        return Twig.Promise.resolve(false);
    }

    /**
     * Namespace for expression handling.
     */
    Twig.expression = { };

    __webpack_require__(7)(Twig);

    /**
     * Reserved word that can't be used as variable names.
     */
    Twig.expression.reservedWords = [
        'true', 'false', 'null', 'TRUE', 'FALSE', 'NULL', '_context', 'and', 'b-and', 'or', 'b-or', 'b-xor', 'in', 'not in', 'if', 'matches', 'starts', 'ends', 'with'
    ];

    /**
     * The type of tokens used in expressions.
     */
    Twig.expression.type = {
        comma: 'Twig.expression.type.comma',
        operator: {
            unary: 'Twig.expression.type.operator.unary',
            binary: 'Twig.expression.type.operator.binary'
        },
        string: 'Twig.expression.type.string',
        bool: 'Twig.expression.type.bool',
        slice: 'Twig.expression.type.slice',
        array: {
            start: 'Twig.expression.type.array.start',
            end: 'Twig.expression.type.array.end'
        },
        object: {
            start: 'Twig.expression.type.object.start',
            end: 'Twig.expression.type.object.end'
        },
        parameter: {
            start: 'Twig.expression.type.parameter.start',
            end: 'Twig.expression.type.parameter.end'
        },
        subexpression: {
            start: 'Twig.expression.type.subexpression.start',
            end: 'Twig.expression.type.subexpression.end'
        },
        key: {
            period: 'Twig.expression.type.key.period',
            brackets: 'Twig.expression.type.key.brackets'
        },
        filter: 'Twig.expression.type.filter',
        _function: 'Twig.expression.type._function',
        variable: 'Twig.expression.type.variable',
        number: 'Twig.expression.type.number',
        _null: 'Twig.expression.type.null',
        context: 'Twig.expression.type.context',
        test: 'Twig.expression.type.test'
    };

    Twig.expression.set = {
        // What can follow an expression (in general)
        operations: [
            Twig.expression.type.filter,
            Twig.expression.type.operator.unary,
            Twig.expression.type.operator.binary,
            Twig.expression.type.array.end,
            Twig.expression.type.object.end,
            Twig.expression.type.parameter.end,
            Twig.expression.type.subexpression.end,
            Twig.expression.type.comma,
            Twig.expression.type.test
        ],
        expressions: [
            Twig.expression.type._function,
            Twig.expression.type.bool,
            Twig.expression.type.string,
            Twig.expression.type.variable,
            Twig.expression.type.number,
            Twig.expression.type._null,
            Twig.expression.type.context,
            Twig.expression.type.parameter.start,
            Twig.expression.type.array.start,
            Twig.expression.type.object.start,
            Twig.expression.type.subexpression.start,
            Twig.expression.type.operator.unary
        ]
    };

    // Most expressions allow a '.' or '[' after them, so we provide a convenience set
    Twig.expression.set.operationsExtended = Twig.expression.set.operations.concat([
        Twig.expression.type.key.period,
        Twig.expression.type.key.brackets,
        Twig.expression.type.slice
    ]);

    // Some commonly used compile and parse functions.
    Twig.expression.fn = {
        compile: {
            push(token, stack, output) {
                output.push(token);
            },
            pushBoth(token, stack, output) {
                output.push(token);
                stack.push(token);
            }
        },
        parse: {
            push(token, stack) {
                stack.push(token);
            },
            pushValue(token, stack) {
                stack.push(token.value);
            }
        }
    };

    // The regular expressions and compile/parse logic used to match tokens in expressions.
    //
    // Properties:
    //
    //      type:  The type of expression this matches
    //
    //      regex: One or more regular expressions that matche the format of the token.
    //
    //      next:  Valid tokens that can occur next in the expression.
    //
    // Functions:
    //
    //      compile: A function that compiles the raw regular expression match into a token.
    //
    //      parse:   A function that parses the compiled token into output.
    //
    Twig.expression.definitions = [
        {
            type: Twig.expression.type.test,
            regex: /^is\s+(not)?\s*([a-zA-Z_]\w*(\s?as)?)/,
            next: Twig.expression.set.operations.concat([Twig.expression.type.parameter.start]),
            compile(token, stack, output) {
                token.filter = token.match[2];
                token.modifier = token.match[1];
                delete token.match;
                delete token.value;
                output.push(token);
            },
            parse(token, stack, context) {
                const value = stack.pop();
                const state = this;

                return parseParams(state, token.params, context)
                    .then(params => {
                        const result = Twig.test(token.filter, value, params);

                        if (token.modifier === 'not') {
                            stack.push(!result);
                        } else {
                            stack.push(result);
                        }
                    });
            }
        },
        {
            type: Twig.expression.type.comma,
            // Match a comma
            regex: /^,/,
            next: Twig.expression.set.expressions.concat([Twig.expression.type.array.end, Twig.expression.type.object.end]),
            compile(token, stack, output) {
                let i = stack.length - 1;
                let stackToken;

                delete token.match;
                delete token.value;

                // Pop tokens off the stack until the start of the object
                for (;i >= 0; i--) {
                    stackToken = stack.pop();
                    if (stackToken.type === Twig.expression.type.object.start ||
                            stackToken.type === Twig.expression.type.parameter.start ||
                            stackToken.type === Twig.expression.type.array.start) {
                        stack.push(stackToken);
                        break;
                    }

                    output.push(stackToken);
                }

                output.push(token);
            }
        },
        {
            /**
             * Match a number (integer or decimal)
             */
            type: Twig.expression.type.number,
            // Match a number
            regex: /^-?\d+(\.\d+)?/,
            next: Twig.expression.set.operations,
            compile(token, stack, output) {
                token.value = Number(token.value);
                output.push(token);
            },
            parse: Twig.expression.fn.parse.pushValue
        },
        {
            type: Twig.expression.type.operator.binary,
            // Match any of ??, ?:, +, *, /, -, %, ~, <, <=, >, >=, !=, ==, **, ?, :, and, b-and, or, b-or, b-xor, in, not in
            // and, or, in, not in, matches, starts with, ends with can be followed by a space or parenthesis
            regex: /(^\?\?|^\?:|^(b-and)|^(b-or)|^(b-xor)|^[+\-~%?]|^[:](?!\d\])|^[!=]==?|^[!<>]=?|^\*\*?|^\/\/?|^(and)[(|\s+]|^(or)[(|\s+]|^(in)[(|\s+]|^(not in)[(|\s+]|^(matches)|^(starts with)|^(ends with)|^\.\.)/,
            next: Twig.expression.set.expressions,
            transform(match, tokens) {
                switch (match[0]) {
                    case 'and(':
                    case 'or(':
                    case 'in(':
                    case 'not in(':
                        // Strip off the ( if it exists
                        tokens[tokens.length - 1].value = match[2];
                        return match[0];
                    default:
                        return '';
                }
            },
            compile(token, stack, output) {
                delete token.match;

                token.value = token.value.trim();
                const {value} = token;
                const operator = Twig.expression.operator.lookup(value, token);

                Twig.log.trace('Twig.expression.compile: ', 'Operator: ', operator, ' from ', value);

                while (stack.length > 0 &&
                       (stack[stack.length - 1].type === Twig.expression.type.operator.unary || stack[stack.length - 1].type === Twig.expression.type.operator.binary) &&
                            (
                                (operator.associativity === Twig.expression.operator.leftToRight &&
                                 operator.precidence >= stack[stack.length - 1].precidence) ||

                                (operator.associativity === Twig.expression.operator.rightToLeft &&
                                 operator.precidence > stack[stack.length - 1].precidence)
                            )
                ) {
                    const temp = stack.pop();
                    output.push(temp);
                }

                if (value === ':') {
                    // Check if this is a ternary or object key being set
                    if (stack[stack.length - 1] && stack[stack.length - 1].value === '?') {
                        // Continue as normal for a ternary
                    } else {
                        // This is not a ternary so we push the token to the output where it can be handled
                        //   when the assocated object is closed.
                        const keyToken = output.pop();

                        if (keyToken.type === Twig.expression.type.string ||
                                keyToken.type === Twig.expression.type.variable) {
                            token.key = keyToken.value;
                        } else if (keyToken.type === Twig.expression.type.number) {
                            // Convert integer keys into string keys
                            token.key = keyToken.value.toString();
                        } else if (keyToken.expression &&
                            (keyToken.type === Twig.expression.type.parameter.end ||
                            keyToken.type === Twig.expression.type.subexpression.end)) {
                            token.params = keyToken.params;
                        } else {
                            throw new Twig.Error('Unexpected value before \':\' of ' + keyToken.type + ' = ' + keyToken.value);
                        }

                        output.push(token);
                    }
                } else {
                    stack.push(operator);
                }
            },
            parse(token, stack, context) {
                const state = this;

                if (token.key) {
                    // Handle ternary ':' operator
                    stack.push(token);
                } else if (token.params) {
                    // Handle "{(expression):value}"
                    return Twig.expression.parseAsync.call(state, token.params, context)
                        .then(key => {
                            token.key = key;
                            stack.push(token);

                            // If we're in a loop, we might need token.params later, especially in this form of "(expression):value"
                            if (!context.loop) {
                                delete (token.params);
                            }
                        });
                } else {
                    Twig.expression.operator.parse(token.value, stack);
                }
            }
        },
        {
            type: Twig.expression.type.operator.unary,
            // Match any of not
            regex: /(^not\s+)/,
            next: Twig.expression.set.expressions,
            compile(token, stack, output) {
                delete token.match;

                token.value = token.value.trim();
                const {value} = token;
                const operator = Twig.expression.operator.lookup(value, token);

                Twig.log.trace('Twig.expression.compile: ', 'Operator: ', operator, ' from ', value);

                while (stack.length > 0 &&
                       (stack[stack.length - 1].type === Twig.expression.type.operator.unary || stack[stack.length - 1].type === Twig.expression.type.operator.binary) &&
                            (
                                (operator.associativity === Twig.expression.operator.leftToRight &&
                                 operator.precidence >= stack[stack.length - 1].precidence) ||

                                (operator.associativity === Twig.expression.operator.rightToLeft &&
                                 operator.precidence > stack[stack.length - 1].precidence)
                            )
                ) {
                    const temp = stack.pop();
                    output.push(temp);
                }

                stack.push(operator);
            },
            parse(token, stack) {
                Twig.expression.operator.parse(token.value, stack);
            }
        },
        {
            /**
             * Match a string. This is anything between a pair of single or double quotes.
             */
            type: Twig.expression.type.string,
            // See: http://blog.stevenlevithan.com/archives/match-quoted-string
            regex: /^(["'])(?:(?=(\\?))\2[\s\S])*?\1/,
            next: Twig.expression.set.operationsExtended,
            compile(token, stack, output) {
                let {value} = token;
                delete token.match;

                // Remove the quotes from the string
                if (value.substring(0, 1) === '"') {
                    value = value.replace('\\"', '"');
                } else {
                    value = value.replace('\\\'', '\'');
                }

                token.value = value.substring(1, value.length - 1).replace(/\\n/g, '\n').replace(/\\r/g, '\r');
                Twig.log.trace('Twig.expression.compile: ', 'String value: ', token.value);
                output.push(token);
            },
            parse: Twig.expression.fn.parse.pushValue
        },
        {
            /**
             * Match a subexpression set start.
             */
            type: Twig.expression.type.subexpression.start,
            regex: /^\(/,
            next: Twig.expression.set.expressions.concat([Twig.expression.type.subexpression.end]),
            compile(token, stack, output) {
                token.value = '(';
                output.push(token);
                stack.push(token);
            },
            parse: Twig.expression.fn.parse.push
        },
        {
            /**
             * Match a subexpression set end.
             */
            type: Twig.expression.type.subexpression.end,
            regex: /^\)/,
            next: Twig.expression.set.operationsExtended,
            validate(match, tokens) {
                // Iterate back through previous tokens to ensure we follow a subexpression start
                let i = tokens.length - 1;
                let foundSubexpressionStart = false;
                let nextSubexpressionStartInvalid = false;
                let unclosedParameterCount = 0;

                while (!foundSubexpressionStart && i >= 0) {
                    const token = tokens[i];

                    foundSubexpressionStart = token.type === Twig.expression.type.subexpression.start;

                    // If we have previously found a subexpression end, then this subexpression start is the start of
                    // that subexpression, not the subexpression we are searching for
                    if (foundSubexpressionStart && nextSubexpressionStartInvalid) {
                        nextSubexpressionStartInvalid = false;
                        foundSubexpressionStart = false;
                    }

                    // Count parameter tokens to ensure we dont return truthy for a parameter opener
                    if (token.type === Twig.expression.type.parameter.start) {
                        unclosedParameterCount++;
                    } else if (token.type === Twig.expression.type.parameter.end) {
                        unclosedParameterCount--;
                    } else if (token.type === Twig.expression.type.subexpression.end) {
                        nextSubexpressionStartInvalid = true;
                    }

                    i--;
                }

                // If we found unclosed parameters, return false
                // If we didnt find subexpression start, return false
                // Otherwise return true

                return (foundSubexpressionStart && (unclosedParameterCount === 0));
            },
            compile(token, stack, output) {
                // This is basically a copy of parameter end compilation
                let stackToken;
                const endToken = token;

                stackToken = stack.pop();
                while (stack.length > 0 && stackToken.type !== Twig.expression.type.subexpression.start) {
                    output.push(stackToken);
                    stackToken = stack.pop();
                }

                // Move contents of parens into preceding filter
                const paramStack = [];
                while (token.type !== Twig.expression.type.subexpression.start) {
                    // Add token to arguments stack
                    paramStack.unshift(token);
                    token = output.pop();
                }

                paramStack.unshift(token);

                // If the token at the top of the *stack* is a function token, pop it onto the output queue.
                // Get the token preceding the parameters
                stackToken = stack[stack.length - 1];

                if (stackToken === undefined ||
                    (stackToken.type !== Twig.expression.type._function &&
                    stackToken.type !== Twig.expression.type.filter &&
                    stackToken.type !== Twig.expression.type.test &&
                    stackToken.type !== Twig.expression.type.key.brackets)) {
                    endToken.expression = true;

                    // Remove start and end token from stack
                    paramStack.pop();
                    paramStack.shift();

                    endToken.params = paramStack;

                    output.push(endToken);
                } else {
                    // This should never be hit
                    endToken.expression = false;
                    stackToken.params = paramStack;
                }
            },
            parse(token, stack, context) {
                const state = this;

                if (token.expression) {
                    return Twig.expression.parseAsync.call(state, token.params, context)
                        .then(value => {
                            stack.push(value);
                        });
                }

                throw new Twig.Error('Unexpected subexpression end when token is not marked as an expression');
            }
        },
        {
            /**
             * Match a parameter set start.
             */
            type: Twig.expression.type.parameter.start,
            regex: /^\(/,
            next: Twig.expression.set.expressions.concat([Twig.expression.type.parameter.end]),
            validate(match, tokens) {
                const lastToken = tokens[tokens.length - 1];
                // We can't use the regex to test if we follow a space because expression is trimmed
                return lastToken && (Twig.expression.reservedWords.indexOf(lastToken.value.trim()) < 0);
            },
            compile: Twig.expression.fn.compile.pushBoth,
            parse: Twig.expression.fn.parse.push
        },
        {
            /**
             * Match a parameter set end.
             */
            type: Twig.expression.type.parameter.end,
            regex: /^\)/,
            next: Twig.expression.set.operationsExtended,
            compile(token, stack, output) {
                let stackToken;
                const endToken = token;

                stackToken = stack.pop();
                while (stack.length > 0 && stackToken.type !== Twig.expression.type.parameter.start) {
                    output.push(stackToken);
                    stackToken = stack.pop();
                }

                // Move contents of parens into preceding filter
                const paramStack = [];
                while (token.type !== Twig.expression.type.parameter.start) {
                    // Add token to arguments stack
                    paramStack.unshift(token);
                    token = output.pop();
                }

                paramStack.unshift(token);

                // Get the token preceding the parameters
                token = output[output.length - 1];

                if (token === undefined ||
                    (token.type !== Twig.expression.type._function &&
                    token.type !== Twig.expression.type.filter &&
                    token.type !== Twig.expression.type.test &&
                    token.type !== Twig.expression.type.key.brackets)) {
                    endToken.expression = true;

                    // Remove start and end token from stack
                    paramStack.pop();
                    paramStack.shift();

                    endToken.params = paramStack;

                    output.push(endToken);
                } else {
                    endToken.expression = false;
                    token.params = paramStack;
                }
            },
            parse(token, stack, context) {
                const newArray = [];
                let arrayEnded = false;
                let value = null;
                const state = this;

                if (token.expression) {
                    return Twig.expression.parseAsync.call(state, token.params, context)
                        .then(value => {
                            stack.push(value);
                        });
                }

                while (stack.length > 0) {
                    value = stack.pop();
                    // Push values into the array until the start of the array
                    if (value && value.type && value.type === Twig.expression.type.parameter.start) {
                        arrayEnded = true;
                        break;
                    }

                    newArray.unshift(value);
                }

                if (!arrayEnded) {
                    throw new Twig.Error('Expected end of parameter set.');
                }

                stack.push(newArray);
            }
        },
        {
            type: Twig.expression.type.slice,
            regex: /^\[(\d*:\d*)\]/,
            next: Twig.expression.set.operationsExtended,
            compile(token, stack, output) {
                const sliceRange = token.match[1].split(':');

                // SliceStart can be undefined when we pass parameters to the slice filter later
                const sliceStart = (sliceRange[0]) ? parseInt(sliceRange[0], 10) : undefined;
                const sliceEnd = (sliceRange[1]) ? parseInt(sliceRange[1], 10) : undefined;

                token.value = 'slice';
                token.params = [sliceStart, sliceEnd];

                // SliceEnd can't be undefined as the slice filter doesn't check for this, but it does check the length
                // of the params array, so just shorten it.
                if (!sliceEnd) {
                    token.params = [sliceStart];
                }

                output.push(token);
            },
            parse(token, stack) {
                const input = stack.pop();
                const {params} = token;
                const state = this;

                stack.push(Twig.filter.call(state, token.value, input, params));
            }
        },
        {
            /**
             * Match an array start.
             */
            type: Twig.expression.type.array.start,
            regex: /^\[/,
            next: Twig.expression.set.expressions.concat([Twig.expression.type.array.end]),
            compile: Twig.expression.fn.compile.pushBoth,
            parse: Twig.expression.fn.parse.push
        },
        {
            /**
             * Match an array end.
             */
            type: Twig.expression.type.array.end,
            regex: /^\]/,
            next: Twig.expression.set.operationsExtended,
            compile(token, stack, output) {
                let i = stack.length - 1;
                let stackToken;
                // Pop tokens off the stack until the start of the object
                for (;i >= 0; i--) {
                    stackToken = stack.pop();
                    if (stackToken.type === Twig.expression.type.array.start) {
                        break;
                    }

                    output.push(stackToken);
                }

                output.push(token);
            },
            parse(token, stack) {
                const newArray = [];
                let arrayEnded = false;
                let value = null;

                while (stack.length > 0) {
                    value = stack.pop();
                    // Push values into the array until the start of the array
                    if (value.type && value.type === Twig.expression.type.array.start) {
                        arrayEnded = true;
                        break;
                    }

                    newArray.unshift(value);
                }

                if (!arrayEnded) {
                    throw new Twig.Error('Expected end of array.');
                }

                stack.push(newArray);
            }
        },
        // Token that represents the start of a hash map '}'
        //
        // Hash maps take the form:
        //    { "key": 'value', "another_key": item }
        //
        // Keys must be quoted (either single or double) and values can be any expression.
        {
            type: Twig.expression.type.object.start,
            regex: /^\{/,
            next: Twig.expression.set.expressions.concat([Twig.expression.type.object.end]),
            compile: Twig.expression.fn.compile.pushBoth,
            parse: Twig.expression.fn.parse.push
        },

        // Token that represents the end of a Hash Map '}'
        //
        // This is where the logic for building the internal
        // representation of a hash map is defined.
        {
            type: Twig.expression.type.object.end,
            regex: /^\}/,
            next: Twig.expression.set.operationsExtended,
            compile(token, stack, output) {
                let i = stack.length - 1;
                let stackToken;

                // Pop tokens off the stack until the start of the object
                for (;i >= 0; i--) {
                    stackToken = stack.pop();
                    if (stackToken && stackToken.type === Twig.expression.type.object.start) {
                        break;
                    }

                    output.push(stackToken);
                }

                output.push(token);
            },
            parse(endToken, stack) {
                const newObject = {};
                let objectEnded = false;
                let token = null;
                let hasValue = false;
                let value = null;

                while (stack.length > 0) {
                    token = stack.pop();
                    // Push values into the array until the start of the object
                    if (token && token.type && token.type === Twig.expression.type.object.start) {
                        objectEnded = true;
                        break;
                    }

                    if (token && token.type && (token.type === Twig.expression.type.operator.binary || token.type === Twig.expression.type.operator.unary) && token.key) {
                        if (!hasValue) {
                            throw new Twig.Error('Missing value for key \'' + token.key + '\' in object definition.');
                        }

                        newObject[token.key] = value;

                        // Preserve the order that elements are added to the map
                        // This is necessary since JavaScript objects don't
                        // guarantee the order of keys
                        if (newObject._keys === undefined) {
                            newObject._keys = [];
                        }

                        newObject._keys.unshift(token.key);

                        // Reset value check
                        value = null;
                        hasValue = false;
                    } else {
                        hasValue = true;
                        value = token;
                    }
                }

                if (!objectEnded) {
                    throw new Twig.Error('Unexpected end of object.');
                }

                stack.push(newObject);
            }
        },

        // Token representing a filter
        //
        // Filters can follow any expression and take the form:
        //    expression|filter(optional, args)
        //
        // Filter parsing is done in the Twig.filters namespace.
        {
            type: Twig.expression.type.filter,
            // Match a | then a letter or _, then any number of letters, numbers, _ or -
            regex: /^\|\s?([a-zA-Z_][a-zA-Z0-9_-]*)/,
            next: Twig.expression.set.operationsExtended.concat([
                Twig.expression.type.parameter.start
            ]),
            compile(token, stack, output) {
                token.value = token.match[1];
                output.push(token);
            },
            parse(token, stack, context) {
                const input = stack.pop();
                const state = this;

                return parseParams(state, token.params, context)
                    .then(params => {
                        return Twig.filter.call(state, token.value, input, params);
                    })
                    .then(value => {
                        stack.push(value);
                    });
            }
        },
        {
            type: Twig.expression.type._function,
            // Match any letter or _, then any number of letters, numbers, _ or - followed by (
            regex: /^([a-zA-Z_]\w*)\s*\(/,
            next: Twig.expression.type.parameter.start,
            validate(match) {
                // Make sure this function is not a reserved word
                return match[1] && (Twig.expression.reservedWords.indexOf(match[1]) < 0);
            },
            transform() {
                return '(';
            },
            compile(token, stack, output) {
                const fn = token.match[1];
                token.fn = fn;
                // Cleanup token
                delete token.match;
                delete token.value;

                output.push(token);
            },
            parse(token, stack, context) {
                const state = this;
                const {fn} = token;
                let value;

                return parseParams(state, token.params, context)
                    .then(params => {
                        if (Twig.functions[fn]) {
                        // Get the function from the built-in functions
                            value = Twig.functions[fn].apply(state, params);
                        } else if (typeof context[fn] === 'function') {
                        // Get the function from the user/context defined functions
                            value = context[fn](...params);
                        } else {
                            throw new Twig.Error(fn + ' function does not exist and is not defined in the context');
                        }

                        return value;
                    })
                    .then(result => {
                        stack.push(result);
                    });
            }
        },

        // Token representing a variable.
        //
        // Variables can contain letters, numbers, underscores and
        // dashes, but must start with a letter or underscore.
        //
        // Variables are retrieved from the render context and take
        // the value of 'undefined' if the given variable doesn't
        // exist in the context.
        {
            type: Twig.expression.type.variable,
            // Match any letter or _, then any number of letters, numbers, _ or -
            regex: /^[a-zA-Z_]\w*/,
            next: Twig.expression.set.operationsExtended.concat([
                Twig.expression.type.parameter.start
            ]),
            compile: Twig.expression.fn.compile.push,
            validate(match) {
                return (Twig.expression.reservedWords.indexOf(match[0]) < 0);
            },
            parse(token, stack, context) {
                const state = this;

                // Get the variable from the context
                return Twig.expression.resolveAsync.call(state, context[token.value], context)
                    .then(value => {
                        if (state.template.options.strictVariables && value === undefined) {
                            throw new Twig.Error('Variable "' + token.value + '" does not exist.');
                        }

                        stack.push(value);
                    });
            }
        },
        {
            type: Twig.expression.type.key.period,
            regex: /^\.(\w+)/,
            next: Twig.expression.set.operationsExtended.concat([
                Twig.expression.type.parameter.start
            ]),
            compile(token, stack, output) {
                token.key = token.match[1];
                delete token.match;
                delete token.value;

                output.push(token);
            },
            parse(token, stack, context, nextToken) {
                const state = this;
                const {key} = token;
                const object = stack.pop();
                let value;

                if (object && !Object.prototype.hasOwnProperty.call(object, key) && state.template.options.strictVariables) {
                    const keys = Object.keys(object);
                    if (keys.length > 0) {
                        throw new Twig.Error('Key "' + key + '" for object with keys "' + Object.keys(object).join(', ') + '" does not exist.');
                    } else {
                        throw new Twig.Error('Key "' + key + '" does not exist as the object is empty.');
                    }
                }

                return parseParams(state, token.params, context)
                    .then(params => {
                        if (object === null || object === undefined) {
                            value = undefined;
                        } else {
                            const capitalize = function (value) {
                                return value.substr(0, 1).toUpperCase() + value.substr(1);
                            };

                            // Get the variable from the context
                            if (typeof object === 'object' && key in object) {
                                value = object[key];
                            } else if (object['get' + capitalize(key)]) {
                                value = object['get' + capitalize(key)];
                            } else if (object['is' + capitalize(key)]) {
                                value = object['is' + capitalize(key)];
                            } else {
                                value = undefined;
                            }
                        }

                        // When resolving an expression we need to pass nextToken in case the expression is a function
                        return Twig.expression.resolveAsync.call(state, value, context, params, nextToken, object);
                    })
                    .then(result => {
                        stack.push(result);
                    });
            }
        },
        {
            type: Twig.expression.type.key.brackets,
            regex: /^\[([^\]:]*)\]/,
            next: Twig.expression.set.operationsExtended.concat([
                Twig.expression.type.parameter.start
            ]),
            compile(token, stack, output) {
                const match = token.match[1];
                delete token.value;
                delete token.match;

                // The expression stack for the key
                token.stack = Twig.expression.compile({
                    value: match
                }).stack;

                output.push(token);
            },
            parse(token, stack, context, nextToken) {
                // Evaluate key
                const state = this;
                let params = null;
                let object;
                let value;

                return parseParams(state, token.params, context)
                    .then(parameters => {
                        params = parameters;
                        return Twig.expression.parseAsync.call(state, token.stack, context);
                    })
                    .then(key => {
                        object = stack.pop();

                        if (object && !Object.prototype.hasOwnProperty.call(object, key) && state.template.options.strictVariables) {
                            const keys = Object.keys(object);
                            if (keys.length > 0) {
                                throw new Twig.Error('Key "' + key + '" for array with keys "' + keys.join(', ') + '" does not exist.');
                            } else {
                                throw new Twig.Error('Key "' + key + '" does not exist as the array is empty.');
                            }
                        } else if (object === null || object === undefined) {
                            return null;
                        }

                        // Get the variable from the context
                        if (typeof object === 'object' && key in object) {
                            value = object[key];
                        } else {
                            value = null;
                        }

                        // When resolving an expression we need to pass nextToken in case the expression is a function
                        return Twig.expression.resolveAsync.call(state, value, object, params, nextToken);
                    })
                    .then(result => {
                        stack.push(result);
                    });
            }
        },
        {
            /**
             * Match a null value.
             */
            type: Twig.expression.type._null,
            // Match a number
            regex: /^(null|NULL|none|NONE)/,
            next: Twig.expression.set.operations,
            compile(token, stack, output) {
                delete token.match;
                token.value = null;
                output.push(token);
            },
            parse: Twig.expression.fn.parse.pushValue
        },
        {
            /**
             * Match the context
             */
            type: Twig.expression.type.context,
            regex: /^_context/,
            next: Twig.expression.set.operationsExtended.concat([
                Twig.expression.type.parameter.start
            ]),
            compile: Twig.expression.fn.compile.push,
            parse(token, stack, context) {
                stack.push(context);
            }
        },
        {
            /**
             * Match a boolean
             */
            type: Twig.expression.type.bool,
            regex: /^(true|TRUE|false|FALSE)/,
            next: Twig.expression.set.operations,
            compile(token, stack, output) {
                token.value = (token.match[0].toLowerCase() === 'true');
                delete token.match;
                output.push(token);
            },
            parse: Twig.expression.fn.parse.pushValue
        }
    ];

    /**
     * Resolve a context value.
     *
     * If the value is a function, it is executed with a context parameter.
     *
     * @param {string} key The context object key.
     * @param {Object} context The render context.
     */
    Twig.expression.resolveAsync = function (value, context, params, nextToken, object) {
        const state = this;

        if (typeof value !== 'function') {
            return Twig.Promise.resolve(value);
        }

        let promise = Twig.Promise.resolve(params);

        /*
        If value is a function, it will have been impossible during the compile stage to determine that a following
        set of parentheses were parameters for this function.

        Those parentheses will have therefore been marked as an expression, with their own parameters, which really
        belong to this function.

        Those parameters will also need parsing in case they are actually an expression to pass as parameters.
            */
        if (nextToken && nextToken.type === Twig.expression.type.parameter.end) {
            // When parsing these parameters, we need to get them all back, not just the last item on the stack.
            const tokensAreParameters = true;

            promise = promise.then(() => {
                return nextToken.params && Twig.expression.parseAsync.call(state, nextToken.params, context, tokensAreParameters);
            })
                .then(p => {
                // Clean up the parentheses tokens on the next loop
                    nextToken.cleanup = true;

                    return p;
                });
        }

        return promise.then(params => {
            return value.apply(object || context, params || []);
        });
    };

    Twig.expression.resolve = function (value, context, params, nextToken, object) {
        return Twig.async.potentiallyAsync(this, false, function () {
            return Twig.expression.resolveAsync.call(this, value, context, params, nextToken, object);
        });
    };

    /**
     * Registry for logic handlers.
     */
    Twig.expression.handler = {};

    /**
     * Define a new expression type, available at Twig.logic.type.{type}
     *
     * @param {string} type The name of the new type.
     */
    Twig.expression.extendType = function (type) {
        Twig.expression.type[type] = 'Twig.expression.type.' + type;
    };

    /**
     * Extend the expression parsing functionality with a new definition.
     *
     * Token definitions follow this format:
     *  {
     *      type:     One of Twig.expression.type.[type], either pre-defined or added using
     *                    Twig.expression.extendType
     *
     *      next:     Array of types from Twig.expression.type that can follow this token,
     *
     *      regex:    A regex or array of regex's that should match the token.
     *
     *      compile: function(token, stack, output) called when this token is being compiled.
     *                   Should return an object with stack and output set.
     *
     *      parse:   function(token, stack, context) called when this token is being parsed.
     *                   Should return an object with stack and context set.
     *  }
     *
     * @param {Object} definition A token definition.
     */
    Twig.expression.extend = function (definition) {
        if (!definition.type) {
            throw new Twig.Error('Unable to extend logic definition. No type provided for ' + definition);
        }

        Twig.expression.handler[definition.type] = definition;
    };

    // Extend with built-in expressions
    while (Twig.expression.definitions.length > 0) {
        Twig.expression.extend(Twig.expression.definitions.shift());
    }

    /**
     * Break an expression into tokens defined in Twig.expression.definitions.
     *
     * @param {string} expression The string to tokenize.
     *
     * @return {Array} An array of tokens.
     */
    Twig.expression.tokenize = function (expression) {
        const tokens = [];
        // Keep an offset of the location in the expression for error messages.
        let expOffset = 0;
        // The valid next tokens of the previous token
        let next = null;
        // Match information
        let type;
        let regex;
        let regexI;
        // The possible next token for the match
        let tokenNext;
        // Has a match been found from the definitions
        let matchFound;
        let invalidMatches = [];

        const matchFunction = function (...args) {
            // Don't pass arguments to `Array.slice`, that is a performance killer
            let matchI = arguments.length - 2;
            const match = new Array(matchI);

            while (matchI-- > 0) {
                match[matchI] = args[matchI];
            }

            Twig.log.trace('Twig.expression.tokenize',
                'Matched a ', type, ' regular expression of ', match);

            if (next && next.indexOf(type) < 0) {
                invalidMatches.push(
                    type + ' cannot follow a ' + tokens[tokens.length - 1].type +
                           ' at template:' + expOffset + ' near \'' + match[0].substring(0, 20) +
                           '...\''
                );

                // Not a match, don't change the expression
                return match[0];
            }

            const handler = Twig.expression.handler[type];

            // Validate the token if a validation function is provided
            if (handler.validate && !handler.validate(match, tokens)) {
                return match[0];
            }

            invalidMatches = [];

            tokens.push({
                type,
                value: match[0],
                match
            });

            matchFound = true;
            next = tokenNext;
            expOffset += match[0].length;

            // Does the token need to return output back to the expression string
            // e.g. a function match of cycle( might return the '(' back to the expression
            // This allows look-ahead to differentiate between token types (e.g. functions and variable names)
            if (handler.transform) {
                return handler.transform(match, tokens);
            }

            return '';
        };

        Twig.log.debug('Twig.expression.tokenize', 'Tokenizing expression ', expression);

        while (expression.length > 0) {
            expression = expression.trim();
            for (type in Twig.expression.handler) {
                if (Object.hasOwnProperty.call(Twig.expression.handler, type)) {
                    tokenNext = Twig.expression.handler[type].next;
                    regex = Twig.expression.handler[type].regex;
                    Twig.log.trace('Checking type ', type, ' on ', expression);

                    matchFound = false;

                    if (Array.isArray(regex)) {
                        regexI = regex.length;
                        while (regexI-- > 0) {
                            expression = expression.replace(regex[regexI], matchFunction);
                        }
                    } else {
                        expression = expression.replace(regex, matchFunction);
                    }

                    // An expression token has been matched. Break the for loop and start trying to
                    //  match the next template (if expression isn't empty.)
                    if (matchFound) {
                        break;
                    }
                }
            }

            if (!matchFound) {
                if (invalidMatches.length > 0) {
                    throw new Twig.Error(invalidMatches.join(' OR '));
                } else {
                    throw new Twig.Error('Unable to parse \'' + expression + '\' at template position' + expOffset);
                }
            }
        }

        Twig.log.trace('Twig.expression.tokenize', 'Tokenized to ', tokens);
        return tokens;
    };

    /**
     * Compile an expression token.
     *
     * @param {Object} rawToken The uncompiled token.
     *
     * @return {Object} The compiled token.
     */
    Twig.expression.compile = function (rawToken) {
        const expression = rawToken.value;
        // Tokenize expression
        const tokens = Twig.expression.tokenize(expression);
        let token = null;
        const output = [];
        const stack = [];
        let tokenTemplate = null;

        Twig.log.trace('Twig.expression.compile: ', 'Compiling ', expression);

        // Push tokens into RPN stack using the Shunting-yard algorithm
        // See http://en.wikipedia.org/wiki/Shunting_yard_algorithm

        while (tokens.length > 0) {
            token = tokens.shift();
            tokenTemplate = Twig.expression.handler[token.type];

            Twig.log.trace('Twig.expression.compile: ', 'Compiling ', token);

            // Compile the template
            tokenTemplate.compile(token, stack, output);

            Twig.log.trace('Twig.expression.compile: ', 'Stack is', stack);
            Twig.log.trace('Twig.expression.compile: ', 'Output is', output);
        }

        while (stack.length > 0) {
            output.push(stack.pop());
        }

        Twig.log.trace('Twig.expression.compile: ', 'Final output is', output);

        rawToken.stack = output;
        delete rawToken.value;

        return rawToken;
    };

    /**
     * Parse an RPN expression stack within a context.
     *
     * @param {Array} tokens An array of compiled expression tokens.
     * @param {Object} context The render context to parse the tokens with.
     *
     * @return {Object} The result of parsing all the tokens. The result
     *                  can be anything, String, Array, Object, etc... based on
     *                  the given expression.
     */
    Twig.expression.parse = function (tokens, context, tokensAreParameters, allowAsync) {
        const state = this;

        // If the token isn't an array, make it one.
        if (!Array.isArray(tokens)) {
            tokens = [tokens];
        }

        // The output stack
        const stack = [];
        const loopTokenFixups = [];
        const binaryOperator = Twig.expression.type.operator.binary;

        return Twig.async.potentiallyAsync(state, allowAsync, () => {
            return Twig.async.forEach(tokens, (token, index) => {
                let tokenTemplate = null;
                let nextToken = null;
                let result;

                // If the token is marked for cleanup, we don't need to parse it
                if (token.cleanup) {
                    return;
                }

                // Determine the token that follows this one so that we can pass it to the parser
                if (tokens.length > index + 1) {
                    nextToken = tokens[index + 1];
                }

                tokenTemplate = Twig.expression.handler[token.type];

                if (tokenTemplate.parse) {
                    result = tokenTemplate.parse.call(state, token, stack, context, nextToken);
                }

                // Store any binary tokens for later if we are in a loop.
                if (token.type === binaryOperator && context.loop) {
                    loopTokenFixups.push(token);
                }

                return result;
            })
                .then(() => {
                // Check every fixup and remove "key" as long as they still have "params". This covers the use case where
                // a ":" operator is used in a loop with a "(expression):" statement. We need to be able to evaluate the expression
                    let len = loopTokenFixups.length;
                    let loopTokenFixup = null;

                    while (len-- > 0) {
                        loopTokenFixup = loopTokenFixups[len];
                        if (loopTokenFixup.params && loopTokenFixup.key) {
                            delete loopTokenFixup.key;
                        }
                    }

                    // If parse has been called with a set of tokens that are parameters, we need to return the whole stack,
                    // wrapped in an Array.
                    if (tokensAreParameters) {
                        const params = stack.splice(0);

                        stack.push(params);
                    }

                    // Pop the final value off the stack
                    return stack.pop();
                });
        });
    };

    return Twig;
};


/***/ }),
/* 7 */
/***/ (function(module, exports) {

// ## twig.expression.operator.js
//
// This file handles operator lookups and parsing.
module.exports = function (Twig) {
    'use strict';

    /**
     * Operator associativity constants.
     */
    Twig.expression.operator = {
        leftToRight: 'leftToRight',
        rightToLeft: 'rightToLeft'
    };

    const containment = function (a, b) {
        if (b === undefined || b === null) {
            return null;
        }

        if (b.indexOf !== undefined) {
            // String
            return (a === b || a !== '') && b.indexOf(a) > -1;
        }

        let el;
        for (el in b) {
            if (Object.hasOwnProperty.call(b, el) && b[el] === a) {
                return true;
            }
        }

        return false;
    };

    /**
     * Get the precidence and associativity of an operator. These follow the order that C/C++ use.
     * See http://en.wikipedia.org/wiki/Operators_in_C_and_C++ for the table of values.
     */
    Twig.expression.operator.lookup = function (operator, token) {
        switch (operator) {
            case '..':
                token.precidence = 20;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case ',':
                token.precidence = 18;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            // Ternary
            case '?:':
            case '?':
            case ':':
                token.precidence = 16;
                token.associativity = Twig.expression.operator.rightToLeft;
                break;

            // Null-coalescing operator
            case '??':
                token.precidence = 15;
                token.associativity = Twig.expression.operator.rightToLeft;
                break;

            case 'or':
                token.precidence = 14;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'and':
                token.precidence = 13;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'b-or':
                token.precidence = 12;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'b-xor':
                token.precidence = 11;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'b-and':
                token.precidence = 10;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case '==':
            case '!=':
                token.precidence = 9;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case '<':
            case '<=':
            case '>':
            case '>=':
            case 'not in':
            case 'in':
                token.precidence = 8;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case '~': // String concatination
            case '+':
            case '-':
                token.precidence = 6;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case '//':
            case '**':
            case '*':
            case '/':
            case '%':
                token.precidence = 5;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'not':
                token.precidence = 3;
                token.associativity = Twig.expression.operator.rightToLeft;
                break;

            case 'matches':
                token.precidence = 8;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'starts with':
                token.precidence = 8;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            case 'ends with':
                token.precidence = 8;
                token.associativity = Twig.expression.operator.leftToRight;
                break;

            default:
                throw new Twig.Error('Failed to lookup operator: ' + operator + ' is an unknown operator.');
        }

        token.operator = operator;
        return token;
    };

    /**
     * Handle operations on the RPN stack.
     *
     * Returns the updated stack.
     */
    Twig.expression.operator.parse = function (operator, stack) {
        Twig.log.trace('Twig.expression.operator.parse: ', 'Handling ', operator);
        let a;
        let b;
        let c;

        if (operator === '?') {
            c = stack.pop();
        }

        b = stack.pop();
        if (operator !== 'not') {
            a = stack.pop();
        }

        if (operator !== 'in' && operator !== 'not in' && operator !== '??') {
            if (a && Array.isArray(a)) {
                a = a.length;
            }

            if (b && Array.isArray(b)) {
                b = b.length;
            }
        }

        if (operator === 'matches') {
            if (b && typeof b === 'string') {
                const reParts = b.match(/^\/(.*)\/([gims]?)$/);
                const reBody = reParts[1];
                const reFlags = reParts[2];
                b = new RegExp(reBody, reFlags);
            }
        }

        switch (operator) {
            case ':':
                // Ignore
                break;

            case '??':
                if (a === undefined) {
                    a = b;
                    b = c;
                    c = undefined;
                }

                if (a !== undefined && a !== null) {
                    stack.push(a);
                } else {
                    stack.push(b);
                }

                break;
            case '?:':
                if (Twig.lib.boolval(a)) {
                    stack.push(a);
                } else {
                    stack.push(b);
                }

                break;
            case '?':
                if (a === undefined) {
                    // An extended ternary.
                    a = b;
                    b = c;
                    c = undefined;
                }

                if (Twig.lib.boolval(a)) {
                    stack.push(b);
                } else {
                    stack.push(c);
                }

                break;

            case '+':
                b = parseFloat(b);
                a = parseFloat(a);
                stack.push(a + b);
                break;

            case '-':
                b = parseFloat(b);
                a = parseFloat(a);
                stack.push(a - b);
                break;

            case '*':
                b = parseFloat(b);
                a = parseFloat(a);
                stack.push(a * b);
                break;

            case '/':
                b = parseFloat(b);
                a = parseFloat(a);
                stack.push(a / b);
                break;

            case '//':
                b = parseFloat(b);
                a = parseFloat(a);
                stack.push(Math.floor(a / b));
                break;

            case '%':
                b = parseFloat(b);
                a = parseFloat(a);
                stack.push(a % b);
                break;

            case '~':
                stack.push((typeof a !== 'undefined' && a !== null ? a.toString() : '') +
                          (typeof b !== 'undefined' && b !== null ? b.toString() : ''));
                break;

            case 'not':
            case '!':
                stack.push(!Twig.lib.boolval(b));
                break;

            case '<':
                stack.push(a < b);
                break;

            case '<=':
                stack.push(a <= b);
                break;

            case '>':
                stack.push(a > b);
                break;

            case '>=':
                stack.push(a >= b);
                break;

            case '===':
                stack.push(a === b);
                break;

            case '==':
                /* eslint-disable-next-line eqeqeq */
                stack.push(a == b);
                break;

            case '!==':
                stack.push(a !== b);
                break;

            case '!=':
                /* eslint-disable-next-line eqeqeq */
                stack.push(a != b);
                break;

            case 'or':
                stack.push(Twig.lib.boolval(a) || Twig.lib.boolval(b));
                break;

            case 'b-or':
                stack.push(a | b);
                break;

            case 'b-xor':
                stack.push(a ^ b);
                break;

            case 'and':
                stack.push(Twig.lib.boolval(a) && Twig.lib.boolval(b));
                break;

            case 'b-and':
                stack.push(a & b);
                break;

            case '**':
                stack.push(a ** b);
                break;

            case 'not in':
                stack.push(!containment(a, b));
                break;

            case 'in':
                stack.push(containment(a, b));
                break;

            case 'matches':
                stack.push(b.test(a));
                break;

            case 'starts with':
                stack.push(typeof a === 'string' && a.indexOf(b) === 0);
                break;

            case 'ends with':
                stack.push(typeof a === 'string' && a.indexOf(b, a.length - b.length) !== -1);
                break;

            case '..':
                stack.push(Twig.functions.range(a, b));
                break;

            default:
                throw new Twig.Error('Failed to parse operator: ' + operator + ' is an unknown operator.');
        }
    };

    return Twig;
};


/***/ }),
/* 8 */
/***/ (function(module, exports) {

// ## twig.filters.js
//
// This file handles parsing filters.
module.exports = function (Twig) {
    // Determine object type
    function is(type, obj) {
        const clas = Object.prototype.toString.call(obj).slice(8, -1);
        return obj !== undefined && obj !== null && clas === type;
    }

    Twig.filters = {
        // String Filters
        upper(value) {
            if (typeof value !== 'string') {
                return value;
            }

            return value.toUpperCase();
        },
        lower(value) {
            if (typeof value !== 'string') {
                return value;
            }

            return value.toLowerCase();
        },
        capitalize(value) {
            if (typeof value !== 'string') {
                return value;
            }

            return value.substr(0, 1).toUpperCase() + value.toLowerCase().substr(1);
        },
        title(value) {
            if (typeof value !== 'string') {
                return value;
            }

            return value.toLowerCase().replace(/(^|\s)([a-z])/g, (m, p1, p2) => {
                return p1 + p2.toUpperCase();
            });
        },
        length(value) {
            if (Twig.lib.is('Array', value) || typeof value === 'string') {
                return value.length;
            }

            if (Twig.lib.is('Object', value)) {
                if (value._keys === undefined) {
                    return Object.keys(value).length;
                }

                return value._keys.length;
            }

            return 0;
        },

        // Array/Object Filters
        reverse(value) {
            if (is('Array', value)) {
                return value.reverse();
            }

            if (is('String', value)) {
                return value.split('').reverse().join('');
            }

            if (is('Object', value)) {
                const keys = value._keys || Object.keys(value).reverse();
                value._keys = keys;
                return value;
            }
        },
        sort(value) {
            if (is('Array', value)) {
                return value.sort();
            }

            if (is('Object', value)) {
                // Sorting objects isn't obvious since the order of
                // returned keys isn't guaranteed in JavaScript.
                // Because of this we use a "hidden" key called _keys to
                // store the keys in the order we want to return them.

                delete value._keys;
                const keys = Object.keys(value);
                const sortedKeys = keys.sort((a, b) => {
                    let a1;
                    let b1;

                    // If a and b are comparable, we're fine :-)
                    if ((value[a] > value[b]) === !(value[a] <= value[b])) {
                        return value[a] > value[b] ? 1 :
                            (value[a] < value[b] ? -1 : 0);
                    }

                    // If a and b can be parsed as numbers, we can compare
                    // their numeric value
                    if (!isNaN(a1 = parseFloat(value[a])) &&
                                !isNaN(b1 = parseFloat(value[b]))) {
                        return a1 > b1 ? 1 : (a1 < b1 ? -1 : 0);
                    }

                    // If one of the values is a string, we convert the
                    // other value to string as well
                    if (typeof value[a] === 'string') {
                        return value[a] > value[b].toString() ? 1 :
                            (value[a] < value[b].toString() ? -1 : 0);
                    }

                    if (typeof value[b] === 'string') {
                        return value[a].toString() > value[b] ? 1 :
                            (value[a].toString() < value[b] ? -1 : 0);
                    }
                    // Everything failed - return 'null' as sign, that
                    // the values are not comparable

                    return null;
                });
                value._keys = sortedKeys;
                return value;
            }
        },
        keys(value) {
            if (value === undefined || value === null) {
                return;
            }

            const keyset = value._keys || Object.keys(value);
            const output = [];

            keyset.forEach(key => {
                if (key === '_keys') {
                    return;
                } // Ignore the _keys property

                if (Object.hasOwnProperty.call(value, key)) {
                    output.push(key);
                }
            });
            return output;
        },
        /* eslint-disable-next-line camelcase */
        url_encode(value) {
            if (value === undefined || value === null) {
                return;
            }

            if (Twig.lib.is('Object', value)) {
                const serialize = function (obj, prefix) {
                    const result = [];
                    const keyset = obj._keys || Object.keys(obj);

                    keyset.forEach(key => {
                        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                            return;
                        }

                        const resultKey = prefix ? prefix + '[' + key + ']' : key;
                        const resultValue = obj[key];

                        result.push(
                            (Twig.lib.is('Object', resultValue) || Array.isArray(resultValue)) ?
                                serialize(resultValue, resultKey) :
                                encodeURIComponent(resultKey) + '=' + encodeURIComponent(resultValue)
                        );
                    });

                    return result.join('&amp;');
                };

                return serialize(value);
            }

            let result = encodeURIComponent(value);
            result = result.replace('\'', '%27');
            return result;
        },
        join(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            let joinStr = '';
            let output = [];
            let keyset = null;

            if (params && params[0]) {
                joinStr = params[0];
            }

            if (is('Array', value)) {
                output = value;
            } else {
                keyset = value._keys || Object.keys(value);
                keyset.forEach(key => {
                    if (key === '_keys') {
                        return;
                    } // Ignore the _keys property

                    if (Object.hasOwnProperty.call(value, key)) {
                        output.push(value[key]);
                    }
                });
            }

            return output.join(joinStr);
        },
        default(value, params) {
            if (params !== undefined && params.length > 1) {
                throw new Twig.Error('default filter expects one argument');
            }

            if (value === undefined || value === null || value === '') {
                if (params === undefined) {
                    return '';
                }

                return params[0];
            }

            return value;
        },
        /* eslint-disable-next-line camelcase */
        json_encode(value) {
            if (value === undefined || value === null) {
                return 'null';
            }

            if ((typeof value === 'object') && (is('Array', value))) {
                const output = [];

                value.forEach(v => {
                    output.push(Twig.filters.json_encode(v));
                });

                return '[' + output.join(',') + ']';
            }

            if ((typeof value === 'object') && (is('Date', value))) {
                return '"' + value.toISOString() + '"';
            }

            if (typeof value === 'object') {
                const keyset = value._keys || Object.keys(value);
                const output = [];

                keyset.forEach(key => {
                    output.push(JSON.stringify(key) + ':' + Twig.filters.json_encode(value[key]));
                });

                return '{' + output.join(',') + '}';
            }

            return JSON.stringify(value);
        },
        merge(value, params) {
            let obj = [];
            let arrIndex = 0;
            let keyset = [];

            // Check to see if all the objects being merged are arrays
            if (is('Array', value)) {
                params.forEach(param => {
                    if (!is('Array', param)) {
                        obj = { };
                    }
                });
            } else {
                // Create obj as an Object
                obj = { };
            }

            if (!is('Array', obj)) {
                obj._keys = [];
            }

            if (is('Array', value)) {
                value.forEach(val => {
                    if (obj._keys) {
                        obj._keys.push(arrIndex);
                    }

                    obj[arrIndex] = val;
                    arrIndex++;
                });
            } else {
                keyset = value._keys || Object.keys(value);
                keyset.forEach(key => {
                    obj[key] = value[key];
                    obj._keys.push(key);

                    // Handle edge case where a number index in an object is greater than
                    //   the array counter. In such a case, the array counter is increased
                    //   one past the index.
                    //
                    // Example {{ ["a", "b"]|merge({"4":"value"}, ["c", "d"])
                    // Without this, d would have an index of "4" and overwrite the value
                    //   of "value"
                    const intKey = parseInt(key, 10);
                    if (!isNaN(intKey) && intKey >= arrIndex) {
                        arrIndex = intKey + 1;
                    }
                });
            }

            // Mixin the merge arrays
            params.forEach(param => {
                if (is('Array', param)) {
                    param.forEach(val => {
                        if (obj._keys) {
                            obj._keys.push(arrIndex);
                        }

                        obj[arrIndex] = val;
                        arrIndex++;
                    });
                } else {
                    keyset = param._keys || Object.keys(param);
                    keyset.forEach(key => {
                        if (!obj[key]) {
                            obj._keys.push(key);
                        }

                        obj[key] = param[key];

                        const intKey = parseInt(key, 10);
                        if (!isNaN(intKey) && intKey >= arrIndex) {
                            arrIndex = intKey + 1;
                        }
                    });
                }
            });
            if (params.length === 0) {
                throw new Twig.Error('Filter merge expects at least one parameter');
            }

            return obj;
        },

        date(value, params) {
            const date = Twig.functions.date(value);
            const format = params && Boolean(params.length) ? params[0] : 'F j, Y H:i';
            return Twig.lib.date(format.replace(/\\\\/g, '\\'), date);
        },
        /* eslint-disable-next-line camelcase */
        date_modify(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            if (params === undefined || params.length !== 1) {
                throw new Twig.Error('date_modify filter expects 1 argument');
            }

            const modifyText = params[0];
            let time;

            if (Twig.lib.is('Date', value)) {
                time = Twig.lib.strtotime(modifyText, value.getTime() / 1000);
            }

            if (Twig.lib.is('String', value)) {
                time = Twig.lib.strtotime(modifyText, Twig.lib.strtotime(value));
            }

            if (Twig.lib.is('Number', value)) {
                time = Twig.lib.strtotime(modifyText, value);
            }

            return new Date(time * 1000);
        },

        replace(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            const pairs = params[0];
            let tag;
            for (tag in pairs) {
                if (Object.hasOwnProperty.call(pairs, tag) && tag !== '_keys') {
                    value = Twig.lib.replaceAll(value, tag, pairs[tag]);
                }
            }

            return value;
        },

        format(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            return Twig.lib.vsprintf(value, params);
        },

        striptags(value, allowed) {
            if (value === undefined || value === null) {
                return;
            }

            return Twig.lib.stripTags(value, allowed);
        },

        escape(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            let strategy = 'html';
            if (params && Boolean(params.length) && params[0] !== true) {
                strategy = params[0];
            }

            if (strategy === 'html') {
                const rawValue = value.toString().replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
                return new Twig.Markup(rawValue, 'html');
            }

            if (strategy === 'js') {
                const rawValue = value.toString();
                let result = '';

                for (let i = 0; i < rawValue.length; i++) {
                    if (rawValue[i].match(/^[a-zA-Z0-9,._]$/)) {
                        result += rawValue[i];
                    } else {
                        const charCode = rawValue.charCodeAt(i);

                        if (charCode < 0x80) {
                            result += '\\x' + charCode.toString(16).toUpperCase();
                        } else {
                            result += Twig.lib.sprintf('\\u%04s', charCode.toString(16).toUpperCase());
                        }
                    }
                }

                return new Twig.Markup(result, 'js');
            }

            if (strategy === 'css') {
                const rawValue = value.toString();
                let result = '';

                for (let i = 0; i < rawValue.length; i++) {
                    if (rawValue[i].match(/^[a-zA-Z0-9]$/)) {
                        result += rawValue[i];
                    } else {
                        const charCode = rawValue.charCodeAt(i);
                        result += '\\' + charCode.toString(16).toUpperCase() + ' ';
                    }
                }

                return new Twig.Markup(result, 'css');
            }

            if (strategy === 'url') {
                const result = Twig.filters.url_encode(value);
                return new Twig.Markup(result, 'url');
            }

            if (strategy === 'html_attr') {
                const rawValue = value.toString();
                let result = '';

                for (let i = 0; i < rawValue.length; i++) {
                    if (rawValue[i].match(/^[a-zA-Z0-9,.\-_]$/)) {
                        result += rawValue[i];
                    } else if (rawValue[i].match(/^[&<>"]$/)) {
                        result += rawValue[i].replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;');
                    } else {
                        const charCode = rawValue.charCodeAt(i);

                        // The following replaces characters undefined in HTML with
                        // the hex entity for the Unicode replacement character.
                        if (charCode <= 0x1F && charCode !== 0x09 && charCode !== 0x0A && charCode !== 0x0D) {
                            result += '&#xFFFD;';
                        } else if (charCode < 0x80) {
                            result += Twig.lib.sprintf('&#x%02s;', charCode.toString(16).toUpperCase());
                        } else {
                            result += Twig.lib.sprintf('&#x%04s;', charCode.toString(16).toUpperCase());
                        }
                    }
                }

                return new Twig.Markup(result, 'html_attr');
            }

            throw new Twig.Error('escape strategy unsupported');
        },

        /* Alias of escape */
        e(value, params) {
            return Twig.filters.escape(value, params);
        },

        nl2br(value) {
            if (value === undefined || value === null) {
                return;
            }

            const linebreakTag = 'BACKSLASH_n_replace';
            const br = '<br />' + linebreakTag;

            value = Twig.filters.escape(value)
                .replace(/\r\n/g, br)
                .replace(/\r/g, br)
                .replace(/\n/g, br);

            value = Twig.lib.replaceAll(value, linebreakTag, '\n');

            return new Twig.Markup(value);
        },

        /**
         * Adapted from: http://phpjs.org/functions/number_format:481
         */
        /* eslint-disable-next-line camelcase */
        number_format(value, params) {
            let number = value;
            const decimals = (params && params[0]) ? params[0] : undefined;
            const dec = (params && params[1] !== undefined) ? params[1] : '.';
            const sep = (params && params[2] !== undefined) ? params[2] : ',';

            number = (String(number)).replace(/[^0-9+\-Ee.]/g, '');
            const n = isFinite(Number(number)) ? Number(number) : 0;
            const prec = isFinite(Number(decimals)) ? Math.abs(decimals) : 0;
            let s = '';
            const toFixedFix = function (n, prec) {
                const k = 10 ** prec;
                return String(Math.round(n * k) / k);
            };

            // Fix for IE parseFloat(0.55).toFixed(0) = 0;
            s = (prec ? toFixedFix(n, prec) : String(Math.round(n))).split('.');
            if (s[0].length > 3) {
                s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
            }

            if ((s[1] || '').length < prec) {
                s[1] = s[1] || '';
                s[1] += new Array(prec - s[1].length + 1).join('0');
            }

            return s.join(dec);
        },

        trim(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            let str = String(value);
            let whitespace;
            if (params && params[0]) {
                whitespace = String(params[0]);
            } else {
                whitespace = ' \n\r\t\f\u000B\u00A0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000';
            }

            for (let i = 0; i < str.length; i++) {
                if (whitespace.indexOf(str.charAt(i)) === -1) {
                    str = str.substring(i);
                    break;
                }
            }

            for (let i = str.length - 1; i >= 0; i--) {
                if (whitespace.indexOf(str.charAt(i)) === -1) {
                    str = str.substring(0, i + 1);
                    break;
                }
            }

            return whitespace.indexOf(str.charAt(0)) === -1 ? str : '';
        },

        truncate(value, params) {
            let length = 30;
            let preserve = false;
            let separator = '...';

            value = String(value);
            if (params) {
                if (params[0]) {
                    length = params[0];
                }

                if (params[1]) {
                    preserve = params[1];
                }

                if (params[2]) {
                    separator = params[2];
                }
            }

            if (value.length > length) {
                if (preserve) {
                    length = value.indexOf(' ', length);
                    if (length === -1) {
                        return value;
                    }
                }

                value = value.substr(0, length) + separator;
            }

            return value;
        },

        slice(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            if (params === undefined || params.length === 0) {
                throw new Twig.Error('slice filter expects at least 1 argument');
            }

            // Default to start of string
            const start = params[0] || 0;
            // Default to length of string
            const length = params.length > 1 ? params[1] : value.length;
            // Handle negative start values
            const startIndex = start >= 0 ? start : Math.max(value.length + start, 0);

            if (Twig.lib.is('Array', value)) {
                const output = [];
                for (let i = startIndex; i < startIndex + length && i < value.length; i++) {
                    output.push(value[i]);
                }

                return output;
            }

            if (Twig.lib.is('String', value)) {
                return value.substr(startIndex, length);
            }

            throw new Twig.Error('slice filter expects value to be an array or string');
        },

        abs(value) {
            if (value === undefined || value === null) {
                return;
            }

            return Math.abs(value);
        },

        first(value) {
            if (is('Array', value)) {
                return value[0];
            }

            if (is('Object', value)) {
                if ('_keys' in value) {
                    return value[value._keys[0]];
                }
            } else if (typeof value === 'string') {
                return value.substr(0, 1);
            }
        },

        split(value, params) {
            if (value === undefined || value === null) {
                return;
            }

            if (params === undefined || params.length === 0 || params.length > 2) {
                throw new Twig.Error('split filter expects 1 or 2 argument');
            }

            if (Twig.lib.is('String', value)) {
                const delimiter = params[0];
                const limit = params[1];
                const split = value.split(delimiter);

                if (limit === undefined) {
                    return split;
                }

                if (limit < 0) {
                    return value.split(delimiter, split.length + limit);
                }

                const limitedSplit = [];

                if (delimiter === '') {
                    // Empty delimiter
                    // "aabbcc"|split('', 2)
                    //     -> ['aa', 'bb', 'cc']

                    while (split.length > 0) {
                        let temp = '';
                        for (let i = 0; i < limit && split.length > 0; i++) {
                            temp += split.shift();
                        }

                        limitedSplit.push(temp);
                    }
                } else {
                    // Non-empty delimiter
                    // "one,two,three,four,five"|split(',', 3)
                    //     -> ['one', 'two', 'three,four,five']

                    for (let i = 0; i < limit - 1 && split.length > 0; i++) {
                        limitedSplit.push(split.shift());
                    }

                    if (split.length > 0) {
                        limitedSplit.push(split.join(delimiter));
                    }
                }

                return limitedSplit;
            }

            throw new Twig.Error('split filter expects value to be a string');
        },
        last(value) {
            if (Twig.lib.is('Object', value)) {
                let keys;

                if (value._keys === undefined) {
                    keys = Object.keys(value);
                } else {
                    keys = value._keys;
                }

                return value[keys[keys.length - 1]];
            }

            // String|array
            return value[value.length - 1];
        },
        raw(value) {
            return new Twig.Markup(value);
        },
        batch(items, params) {
            let size = params.shift();
            const fill = params.shift();
            let last;
            let missing;

            if (!Twig.lib.is('Array', items)) {
                throw new Twig.Error('batch filter expects items to be an array');
            }

            if (!Twig.lib.is('Number', size)) {
                throw new Twig.Error('batch filter expects size to be a number');
            }

            size = Math.ceil(size);

            const result = Twig.lib.chunkArray(items, size);

            if (fill && items.length % size !== 0) {
                last = result.pop();
                missing = size - last.length;

                while (missing--) {
                    last.push(fill);
                }

                result.push(last);
            }

            return result;
        },
        round(value, params) {
            params = params || [];

            const precision = params.length > 0 ? params[0] : 0;
            const method = params.length > 1 ? params[1] : 'common';

            value = parseFloat(value);

            if (precision && !Twig.lib.is('Number', precision)) {
                throw new Twig.Error('round filter expects precision to be a number');
            }

            if (method === 'common') {
                return Twig.lib.round(value, precision);
            }

            if (!Twig.lib.is('Function', Math[method])) {
                throw new Twig.Error('round filter expects method to be \'floor\', \'ceil\', or \'common\'');
            }

            return Math[method](value * (10 ** precision)) / (10 ** precision);
        },
        spaceless(value) {
            return value.replace(/>\s+</g, '><').trim();
        }
    };

    Twig.filter = function (filter, value, params) {
        const state = this;

        if (!Twig.filters[filter]) {
            throw new Twig.Error('Unable to find filter ' + filter);
        }

        return Twig.filters[filter].call(state, value, params);
    };

    Twig.filter.extend = function (filter, definition) {
        Twig.filters[filter] = definition;
    };

    return Twig;
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// ## twig.functions.js
//
// This file handles parsing filters.
module.exports = function (Twig) {
    /**
     * @constant
     * @type {string}
     */
    const TEMPLATE_NOT_FOUND_MESSAGE = 'Template "{name}" is not defined.';

    Twig.functions = {
        //  Attribute, block, constant, date, dump, parent, random,.

        // Range function from http://phpjs.org/functions/range:499
        // Used under an MIT License
        range(low, high, step) {
            // http://kevin.vanzonneveld.net
            // +   original by: Waldo Malqui Silva
            // *     example 1: range ( 0, 12 );
            // *     returns 1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
            // *     example 2: range( 0, 100, 10 );
            // *     returns 2: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
            // *     example 3: range( 'a', 'i' );
            // *     returns 3: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
            // *     example 4: range( 'c', 'a' );
            // *     returns 4: ['c', 'b', 'a']
            const matrix = [];
            let inival;
            let endval;
            const walker = step || 1;
            let chars = false;

            if (!isNaN(low) && !isNaN(high)) {
                inival = parseInt(low, 10);
                endval = parseInt(high, 10);
            } else if (isNaN(low) && isNaN(high)) {
                chars = true;
                inival = low.charCodeAt(0);
                endval = high.charCodeAt(0);
            } else {
                inival = (isNaN(low) ? 0 : low);
                endval = (isNaN(high) ? 0 : high);
            }

            const plus = (!((inival > endval)));
            if (plus) {
                while (inival <= endval) {
                    matrix.push(((chars) ? String.fromCharCode(inival) : inival));
                    inival += walker;
                }
            } else {
                while (inival >= endval) {
                    matrix.push(((chars) ? String.fromCharCode(inival) : inival));
                    inival -= walker;
                }
            }

            return matrix;
        },
        cycle(arr, i) {
            const pos = i % arr.length;
            return arr[pos];
        },
        dump(...args) {
            // Don't pass arguments to `Array.slice`, that is a performance killer

            const argsCopy = [...args];
            const state = this;

            const EOL = '\n';
            const indentChar = '  ';
            let indentTimes = 0;
            let out = '';
            const indent = function (times) {
                let ind = '';
                while (times > 0) {
                    times--;
                    ind += indentChar;
                }

                return ind;
            };

            const displayVar = function (variable) {
                out += indent(indentTimes);
                if (typeof (variable) === 'object') {
                    dumpVar(variable);
                } else if (typeof (variable) === 'function') {
                    out += 'function()' + EOL;
                } else if (typeof (variable) === 'string') {
                    out += 'string(' + variable.length + ') "' + variable + '"' + EOL;
                } else if (typeof (variable) === 'number') {
                    out += 'number(' + variable + ')' + EOL;
                } else if (typeof (variable) === 'boolean') {
                    out += 'bool(' + variable + ')' + EOL;
                }
            };

            const dumpVar = function (variable) {
                let i;
                if (variable === null) {
                    out += 'NULL' + EOL;
                } else if (variable === undefined) {
                    out += 'undefined' + EOL;
                } else if (typeof variable === 'object') {
                    out += indent(indentTimes) + typeof (variable);
                    indentTimes++;
                    out += '(' + (function (obj) {
                        let size = 0;
                        let key;
                        for (key in obj) {
                            if (Object.hasOwnProperty.call(obj, key)) {
                                size++;
                            }
                        }

                        return size;
                    })(variable) + ') {' + EOL;
                    for (i in variable) {
                        if (Object.hasOwnProperty.call(variable, i)) {
                            out += indent(indentTimes) + '[' + i + ']=> ' + EOL;
                            displayVar(variable[i]);
                        }
                    }

                    indentTimes--;
                    out += indent(indentTimes) + '}' + EOL;
                } else {
                    displayVar(variable);
                }
            };

            // Handle no argument case by dumping the entire render context
            if (argsCopy.length === 0) {
                argsCopy.push(state.context);
            }

            argsCopy.forEach(variable => {
                dumpVar(variable);
            });

            return out;
        },
        date(date) {
            let dateObj;
            if (date === undefined || date === null || date === '') {
                dateObj = new Date();
            } else if (Twig.lib.is('Date', date)) {
                dateObj = date;
            } else if (Twig.lib.is('String', date)) {
                if (date.match(/^\d+$/)) {
                    dateObj = new Date(date * 1000);
                } else {
                    dateObj = new Date(Twig.lib.strtotime(date) * 1000);
                }
            } else if (Twig.lib.is('Number', date)) {
                // Timestamp
                dateObj = new Date(date * 1000);
            } else {
                throw new Twig.Error('Unable to parse date ' + date);
            }

            return dateObj;
        },
        block(blockName) {
            const state = this;

            const block = state.getBlock(blockName);

            if (block !== undefined) {
                return block.render(state, state.context);
            }
        },
        parent() {
            const state = this;

            return state.getBlock(state.getNestingStackToken(Twig.logic.type.block).blockName, true).render(state, state.context);
        },
        attribute(object, method, params) {
            if (Twig.lib.is('Object', object)) {
                if (Object.hasOwnProperty.call(object, method)) {
                    if (typeof object[method] === 'function') {
                        return object[method].apply(undefined, params);
                    }

                    return object[method];
                }
            }

            // Array will return element 0-index
            return object[method] || undefined;
        },
        max(values, ...args) {
            if (Twig.lib.is('Object', values)) {
                delete values._keys;
                return Twig.lib.max(values);
            }

            return Twig.lib.max.apply(null, [values, ...args]);
        },
        min(values, ...args) {
            if (Twig.lib.is('Object', values)) {
                delete values._keys;
                return Twig.lib.min(values);
            }

            return Twig.lib.min.apply(null, [values, ...args]);
        },
        /* eslint-disable-next-line camelcase */
        template_from_string(template) {
            const state = this;

            if (template === undefined) {
                template = '';
            }

            return Twig.Templates.parsers.twig({
                options: state.template.options,
                data: template
            });
        },
        random(value) {
            const LIMIT_INT31 = 0x80000000;

            function getRandomNumber(n) {
                const random = Math.floor(Math.random() * LIMIT_INT31);
                const min = Math.min.call(null, 0, n);
                const max = Math.max.call(null, 0, n);
                return min + Math.floor((max - min + 1) * random / LIMIT_INT31);
            }

            if (Twig.lib.is('Number', value)) {
                return getRandomNumber(value);
            }

            if (Twig.lib.is('String', value)) {
                return value.charAt(getRandomNumber(value.length - 1));
            }

            if (Twig.lib.is('Array', value)) {
                return value[getRandomNumber(value.length - 1)];
            }

            if (Twig.lib.is('Object', value)) {
                const keys = Object.keys(value);
                return value[keys[getRandomNumber(keys.length - 1)]];
            }

            return getRandomNumber(LIMIT_INT31 - 1);
        },

        /**
         * Returns the content of a template without rendering it
         * @param {string} name
         * @param {boolean} [ignoreMissing=false]
         * @returns {string}
         */
        source(name, ignoreMissing) {
            let templateSource;
            let templateFound = false;
            const isNodeEnvironment =   true && typeof module.exports !== 'undefined' && typeof window === 'undefined';
            let loader;
            const path = name;

            // If we are running in a node.js environment, set the loader to 'fs'.
            if (isNodeEnvironment) {
                loader = 'fs';
            } else {
                loader = 'ajax';
            }

            // Build the params object
            const params = {
                id: name,
                path,
                method: loader,
                parser: 'source',
                async: false,
                fetchTemplateSource: true
            };

            // Default ignoreMissing to false
            if (typeof ignoreMissing === 'undefined') {
                ignoreMissing = false;
            }

            // Try to load the remote template
            //
            // on exception, log it
            try {
                templateSource = Twig.Templates.loadRemote(name, params);

                // If the template is undefined or null, set the template to an empty string and do NOT flip the
                // boolean indicating we found the template
                //
                // else, all is good! flip the boolean indicating we found the template
                if (typeof templateSource === 'undefined' || templateSource === null) {
                    templateSource = '';
                } else {
                    templateFound = true;
                }
            } catch (error) {
                Twig.log.debug('Twig.functions.source: ', 'Problem loading template  ', error);
            }

            // If the template was NOT found AND we are not ignoring missing templates, return the same message
            // that is returned by the PHP implementation of the twig source() function
            //
            // else, return the template source
            if (!templateFound && !ignoreMissing) {
                return TEMPLATE_NOT_FOUND_MESSAGE.replace('{name}', name);
            }

            return templateSource;
        }
    };

    Twig._function = function (_function, value, params) {
        if (!Twig.functions[_function]) {
            throw new Twig.Error('Unable to find function ' + _function);
        }

        return Twig.functions[_function](value, params);
    };

    Twig._function.extend = function (_function, definition) {
        Twig.functions[_function] = definition;
    };

    return Twig;
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// ## twig.lib.js
//
// This file contains 3rd party libraries used within twig.
//
// Copies of the licenses for the code included here can be found in the
// LICENSES.md file.
//

module.exports = function (Twig) {
    // Namespace for libraries
    Twig.lib = { };

    Twig.lib.sprintf = __webpack_require__(0);
    Twig.lib.vsprintf = __webpack_require__(11);
    Twig.lib.round = __webpack_require__(12);
    Twig.lib.max = __webpack_require__(13);
    Twig.lib.min = __webpack_require__(14);
    Twig.lib.stripTags = __webpack_require__(15);
    Twig.lib.strtotime = __webpack_require__(16);
    Twig.lib.date = __webpack_require__(17);
    Twig.lib.boolval = __webpack_require__(18);

    Twig.lib.is = function (type, obj) {
        if (typeof obj === 'undefined' || obj === null) {
            return false;
        }

        switch (type) {
            case 'Array':
                return Array.isArray(obj);
            case 'Date':
                return obj instanceof Date;
            case 'String':
                return (typeof obj === 'string' || obj instanceof String);
            case 'Number':
                return (typeof obj === 'number' || obj instanceof Number);
            case 'Function':
                return (typeof obj === 'function');
            case 'Object':
                return obj instanceof Object;
            default:
                return false;
        }
    };

    Twig.lib.replaceAll = function (string, search, replace) {
        // Escape possible regular expression syntax
        const searchEscaped = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        return string.replace(new RegExp(searchEscaped, 'g'), replace);
    };

    // Chunk an array (arr) into arrays of (size) items, returns an array of arrays, or an empty array on invalid input
    Twig.lib.chunkArray = function (arr, size) {
        const returnVal = [];
        let x = 0;
        const len = arr.length;

        if (size < 1 || !Array.isArray(arr)) {
            return [];
        }

        while (x < len) {
            returnVal.push(arr.slice(x, x += size));
        }

        return returnVal;
    };

    return Twig;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function vsprintf(format, args) {
  //  discuss at: http://locutus.io/php/vsprintf/
  // original by: ejsanders
  //   example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1])
  //   returns 1: '1988-08-01'

  var sprintf = __webpack_require__(0);

  return sprintf.apply(this, [format].concat(args));
};
//# sourceMappingURL=vsprintf.js.map

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function round(value, precision, mode) {
  //  discuss at: http://locutus.io/php/round/
  // original by: Philip Peterson
  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)
  //  revised by: T.Wild
  //  revised by: Rafał Kukawski (http://blog.kukawski.pl)
  //    input by: Greenseed
  //    input by: meo
  //    input by: William
  //    input by: Josep Sanz (http://www.ws3.es/)
  // bugfixed by: Brett Zamir (http://brett-zamir.me)
  //      note 1: Great work. Ideas for improvement:
  //      note 1: - code more compliant with developer guidelines
  //      note 1: - for implementing PHP constant arguments look at
  //      note 1: the pathinfo() function, it offers the greatest
  //      note 1: flexibility & compatibility possible
  //   example 1: round(1241757, -3)
  //   returns 1: 1242000
  //   example 2: round(3.6)
  //   returns 2: 4
  //   example 3: round(2.835, 2)
  //   returns 3: 2.84
  //   example 4: round(1.1749999999999, 2)
  //   returns 4: 1.17
  //   example 5: round(58551.799999999996, 2)
  //   returns 5: 58551.8

  var m, f, isHalf, sgn; // helper variables
  // making sure precision is integer
  precision |= 0;
  m = Math.pow(10, precision);
  value *= m;
  // sign of the number
  sgn = value > 0 | -(value < 0);
  isHalf = value % 1 === 0.5 * sgn;
  f = Math.floor(value);

  if (isHalf) {
    switch (mode) {
      case 'PHP_ROUND_HALF_DOWN':
        // rounds .5 toward zero
        value = f + (sgn < 0);
        break;
      case 'PHP_ROUND_HALF_EVEN':
        // rouds .5 towards the next even integer
        value = f + f % 2 * sgn;
        break;
      case 'PHP_ROUND_HALF_ODD':
        // rounds .5 towards the next odd integer
        value = f + !(f % 2);
        break;
      default:
        // rounds .5 away from zero
        value = f + (sgn > 0);
    }
  }

  return (isHalf ? value : Math.round(value)) / m;
};
//# sourceMappingURL=round.js.map

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

module.exports = function max() {
  //  discuss at: http://locutus.io/php/max/
  // original by: Onno Marsman (https://twitter.com/onnomarsman)
  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)
  // improved by: Jack
  //      note 1: Long code cause we're aiming for maximum PHP compatibility
  //   example 1: max(1, 3, 5, 6, 7)
  //   returns 1: 7
  //   example 2: max([2, 4, 5])
  //   returns 2: 5
  //   example 3: max(0, 'hello')
  //   returns 3: 0
  //   example 4: max('hello', 0)
  //   returns 4: 'hello'
  //   example 5: max(-1, 'hello')
  //   returns 5: 'hello'
  //   example 6: max([2, 4, 8], [2, 5, 7])
  //   returns 6: [2, 5, 7]

  var ar;
  var retVal;
  var i = 0;
  var n = 0;
  var argv = arguments;
  var argc = argv.length;
  var _obj2Array = function _obj2Array(obj) {
    if (Object.prototype.toString.call(obj) === '[object Array]') {
      return obj;
    } else {
      var ar = [];
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ar.push(obj[i]);
        }
      }
      return ar;
    }
  };
  var _compare = function _compare(current, next) {
    var i = 0;
    var n = 0;
    var tmp = 0;
    var nl = 0;
    var cl = 0;

    if (current === next) {
      return 0;
    } else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {
      if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
        current = _obj2Array(current);
        next = _obj2Array(next);
        cl = current.length;
        nl = next.length;
        if (nl > cl) {
          return 1;
        } else if (nl < cl) {
          return -1;
        }
        for (i = 0, n = cl; i < n; ++i) {
          tmp = _compare(current[i], next[i]);
          if (tmp === 1) {
            return 1;
          } else if (tmp === -1) {
            return -1;
          }
        }
        return 0;
      }
      return -1;
    } else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
      return 1;
    } else if (isNaN(next) && !isNaN(current)) {
      if (current === 0) {
        return 0;
      }
      return current < 0 ? 1 : -1;
    } else if (isNaN(current) && !isNaN(next)) {
      if (next === 0) {
        return 0;
      }
      return next > 0 ? 1 : -1;
    }

    if (next === current) {
      return 0;
    }

    return next > current ? 1 : -1;
  };

  if (argc === 0) {
    throw new Error('At least one value should be passed to max()');
  } else if (argc === 1) {
    if (_typeof(argv[0]) === 'object') {
      ar = _obj2Array(argv[0]);
    } else {
      throw new Error('Wrong parameter count for max()');
    }
    if (ar.length === 0) {
      throw new Error('Array must contain at least one element for max()');
    }
  } else {
    ar = argv;
  }

  retVal = ar[0];
  for (i = 1, n = ar.length; i < n; ++i) {
    if (_compare(retVal, ar[i]) === 1) {
      retVal = ar[i];
    }
  }

  return retVal;
};
//# sourceMappingURL=max.js.map

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

module.exports = function min() {
  //  discuss at: http://locutus.io/php/min/
  // original by: Onno Marsman (https://twitter.com/onnomarsman)
  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)
  // improved by: Jack
  //      note 1: Long code cause we're aiming for maximum PHP compatibility
  //   example 1: min(1, 3, 5, 6, 7)
  //   returns 1: 1
  //   example 2: min([2, 4, 5])
  //   returns 2: 2
  //   example 3: min(0, 'hello')
  //   returns 3: 0
  //   example 4: min('hello', 0)
  //   returns 4: 'hello'
  //   example 5: min(-1, 'hello')
  //   returns 5: -1
  //   example 6: min([2, 4, 8], [2, 5, 7])
  //   returns 6: [2, 4, 8]

  var ar;
  var retVal;
  var i = 0;
  var n = 0;
  var argv = arguments;
  var argc = argv.length;
  var _obj2Array = function _obj2Array(obj) {
    if (Object.prototype.toString.call(obj) === '[object Array]') {
      return obj;
    }
    var ar = [];
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        ar.push(obj[i]);
      }
    }
    return ar;
  };

  var _compare = function _compare(current, next) {
    var i = 0;
    var n = 0;
    var tmp = 0;
    var nl = 0;
    var cl = 0;

    if (current === next) {
      return 0;
    } else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {
      if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
        current = _obj2Array(current);
        next = _obj2Array(next);
        cl = current.length;
        nl = next.length;
        if (nl > cl) {
          return 1;
        } else if (nl < cl) {
          return -1;
        }
        for (i = 0, n = cl; i < n; ++i) {
          tmp = _compare(current[i], next[i]);
          if (tmp === 1) {
            return 1;
          } else if (tmp === -1) {
            return -1;
          }
        }
        return 0;
      }
      return -1;
    } else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
      return 1;
    } else if (isNaN(next) && !isNaN(current)) {
      if (current === 0) {
        return 0;
      }
      return current < 0 ? 1 : -1;
    } else if (isNaN(current) && !isNaN(next)) {
      if (next === 0) {
        return 0;
      }
      return next > 0 ? 1 : -1;
    }

    if (next === current) {
      return 0;
    }

    return next > current ? 1 : -1;
  };

  if (argc === 0) {
    throw new Error('At least one value should be passed to min()');
  } else if (argc === 1) {
    if (_typeof(argv[0]) === 'object') {
      ar = _obj2Array(argv[0]);
    } else {
      throw new Error('Wrong parameter count for min()');
    }

    if (ar.length === 0) {
      throw new Error('Array must contain at least one element for min()');
    }
  } else {
    ar = argv;
  }

  retVal = ar[0];

  for (i = 1, n = ar.length; i < n; ++i) {
    if (_compare(retVal, ar[i]) === -1) {
      retVal = ar[i];
    }
  }

  return retVal;
};
//# sourceMappingURL=min.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function strip_tags(input, allowed) {
  // eslint-disable-line camelcase
  //  discuss at: http://locutus.io/php/strip_tags/
  // original by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Luke Godfrey
  // improved by: Kevin van Zonneveld (http://kvz.io)
  //    input by: Pul
  //    input by: Alex
  //    input by: Marc Palau
  //    input by: Brett Zamir (http://brett-zamir.me)
  //    input by: Bobby Drake
  //    input by: Evertjan Garretsen
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Eric Nagel
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Tomasz Wesolowski
  //  revised by: Rafał Kukawski (http://blog.kukawski.pl)
  //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>')
  //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
  //   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>')
  //   returns 2: '<p>Kevin van Zonneveld</p>'
  //   example 3: strip_tags("<a href='http://kvz.io'>Kevin van Zonneveld</a>", "<a>")
  //   returns 3: "<a href='http://kvz.io'>Kevin van Zonneveld</a>"
  //   example 4: strip_tags('1 < 5 5 > 1')
  //   returns 4: '1 < 5 5 > 1'
  //   example 5: strip_tags('1 <br/> 1')
  //   returns 5: '1  1'
  //   example 6: strip_tags('1 <br/> 1', '<br>')
  //   returns 6: '1 <br/> 1'
  //   example 7: strip_tags('1 <br/> 1', '<br><br/>')
  //   returns 7: '1 <br/> 1'

  // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
  allowed = (((allowed || '') + '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');

  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi;
  var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;

  return input.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {
    return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
  });
};
//# sourceMappingURL=strip_tags.js.map

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function strtotime(text, now) {
  //  discuss at: http://locutus.io/php/strtotime/
  // original by: Caio Ariede (http://caioariede.com)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Caio Ariede (http://caioariede.com)
  // improved by: A. Matías Quezada (http://amatiasq.com)
  // improved by: preuter
  // improved by: Brett Zamir (http://brett-zamir.me)
  // improved by: Mirko Faber
  //    input by: David
  // bugfixed by: Wagner B. Soares
  // bugfixed by: Artur Tchernychev
  // bugfixed by: Stephan Bösch-Plepelits (http://github.com/plepe)
  //      note 1: Examples all have a fixed timestamp to prevent
  //      note 1: tests to fail because of variable time(zones)
  //   example 1: strtotime('+1 day', 1129633200)
  //   returns 1: 1129719600
  //   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200)
  //   returns 2: 1130425202
  //   example 3: strtotime('last month', 1129633200)
  //   returns 3: 1127041200
  //   example 4: strtotime('2009-05-04 08:30:00 GMT')
  //   returns 4: 1241425800
  //   example 5: strtotime('2009-05-04 08:30:00+00')
  //   returns 5: 1241425800
  //   example 6: strtotime('2009-05-04 08:30:00+02:00')
  //   returns 6: 1241418600
  //   example 7: strtotime('2009-05-04T08:30:00Z')
  //   returns 7: 1241425800

  var parsed;
  var match;
  var today;
  var year;
  var date;
  var days;
  var ranges;
  var len;
  var times;
  var regex;
  var i;
  var fail = false;

  if (!text) {
    return fail;
  }

  // Unecessary spaces
  text = text.replace(/^\s+|\s+$/g, '').replace(/\s{2,}/g, ' ').replace(/[\t\r\n]/g, '').toLowerCase();

  // in contrast to php, js Date.parse function interprets:
  // dates given as yyyy-mm-dd as in timezone: UTC,
  // dates with "." or "-" as MDY instead of DMY
  // dates with two-digit years differently
  // etc...etc...
  // ...therefore we manually parse lots of common date formats
  var pattern = new RegExp(['^(\\d{1,4})', '([\\-\\.\\/:])', '(\\d{1,2})', '([\\-\\.\\/:])', '(\\d{1,4})', '(?:\\s(\\d{1,2}):(\\d{2})?:?(\\d{2})?)?', '(?:\\s([A-Z]+)?)?$'].join(''));
  match = text.match(pattern);

  if (match && match[2] === match[4]) {
    if (match[1] > 1901) {
      switch (match[2]) {
        case '-':
          // YYYY-M-D
          if (match[3] > 12 || match[5] > 31) {
            return fail;
          }

          return new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        case '.':
          // YYYY.M.D is not parsed by strtotime()
          return fail;
        case '/':
          // YYYY/M/D
          if (match[3] > 12 || match[5] > 31) {
            return fail;
          }

          return new Date(match[1], parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
      }
    } else if (match[5] > 1901) {
      switch (match[2]) {
        case '-':
          // D-M-YYYY
          if (match[3] > 12 || match[1] > 31) {
            return fail;
          }

          return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        case '.':
          // D.M.YYYY
          if (match[3] > 12 || match[1] > 31) {
            return fail;
          }

          return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        case '/':
          // M/D/YYYY
          if (match[1] > 12 || match[3] > 31) {
            return fail;
          }

          return new Date(match[5], parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
      }
    } else {
      switch (match[2]) {
        case '-':
          // YY-M-D
          if (match[3] > 12 || match[5] > 31 || match[1] < 70 && match[1] > 38) {
            return fail;
          }

          year = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1];
          return new Date(year, parseInt(match[3], 10) - 1, match[5], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        case '.':
          // D.M.YY or H.MM.SS
          if (match[5] >= 70) {
            // D.M.YY
            if (match[3] > 12 || match[1] > 31) {
              return fail;
            }

            return new Date(match[5], parseInt(match[3], 10) - 1, match[1], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
          }
          if (match[5] < 60 && !match[6]) {
            // H.MM.SS
            if (match[1] > 23 || match[3] > 59) {
              return fail;
            }

            today = new Date();
            return new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000;
          }

          // invalid format, cannot be parsed
          return fail;
        case '/':
          // M/D/YY
          if (match[1] > 12 || match[3] > 31 || match[5] < 70 && match[5] > 38) {
            return fail;
          }

          year = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5];
          return new Date(year, parseInt(match[1], 10) - 1, match[3], match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
        case ':':
          // HH:MM:SS
          if (match[1] > 23 || match[3] > 59 || match[5] > 59) {
            return fail;
          }

          today = new Date();
          return new Date(today.getFullYear(), today.getMonth(), today.getDate(), match[1] || 0, match[3] || 0, match[5] || 0) / 1000;
      }
    }
  }

  // other formats and "now" should be parsed by Date.parse()
  if (text === 'now') {
    return now === null || isNaN(now) ? new Date().getTime() / 1000 | 0 : now | 0;
  }
  if (!isNaN(parsed = Date.parse(text))) {
    return parsed / 1000 | 0;
  }
  // Browsers !== Chrome have problems parsing ISO 8601 date strings, as they do
  // not accept lower case characters, space, or shortened time zones.
  // Therefore, fix these problems and try again.
  // Examples:
  //   2015-04-15 20:33:59+02
  //   2015-04-15 20:33:59z
  //   2015-04-15t20:33:59+02:00
  pattern = new RegExp(['^([0-9]{4}-[0-9]{2}-[0-9]{2})', '[ t]', '([0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?)', '([\\+-][0-9]{2}(:[0-9]{2})?|z)'].join(''));
  match = text.match(pattern);
  if (match) {
    // @todo: time zone information
    if (match[4] === 'z') {
      match[4] = 'Z';
    } else if (match[4].match(/^([\+-][0-9]{2})$/)) {
      match[4] = match[4] + ':00';
    }

    if (!isNaN(parsed = Date.parse(match[1] + 'T' + match[2] + match[4]))) {
      return parsed / 1000 | 0;
    }
  }

  date = now ? new Date(now * 1000) : new Date();
  days = {
    'sun': 0,
    'mon': 1,
    'tue': 2,
    'wed': 3,
    'thu': 4,
    'fri': 5,
    'sat': 6
  };
  ranges = {
    'yea': 'FullYear',
    'mon': 'Month',
    'day': 'Date',
    'hou': 'Hours',
    'min': 'Minutes',
    'sec': 'Seconds'
  };

  function lastNext(type, range, modifier) {
    var diff;
    var day = days[range];

    if (typeof day !== 'undefined') {
      diff = day - date.getDay();

      if (diff === 0) {
        diff = 7 * modifier;
      } else if (diff > 0 && type === 'last') {
        diff -= 7;
      } else if (diff < 0 && type === 'next') {
        diff += 7;
      }

      date.setDate(date.getDate() + diff);
    }
  }

  function process(val) {
    // @todo: Reconcile this with regex using \s, taking into account
    // browser issues with split and regexes
    var splt = val.split(' ');
    var type = splt[0];
    var range = splt[1].substring(0, 3);
    var typeIsNumber = /\d+/.test(type);
    var ago = splt[2] === 'ago';
    var num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1);

    if (typeIsNumber) {
      num *= parseInt(type, 10);
    }

    if (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\.)?$/i)) {
      return date['set' + ranges[range]](date['get' + ranges[range]]() + num);
    }

    if (range === 'wee') {
      return date.setDate(date.getDate() + num * 7);
    }

    if (type === 'next' || type === 'last') {
      lastNext(type, range, num);
    } else if (!typeIsNumber) {
      return false;
    }

    return true;
  }

  times = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' + '|sunday|sun\\.?|monday|mon\\.?|tuesday|tue\\.?|wednesday|wed\\.?' + '|thursday|thu\\.?|friday|fri\\.?|saturday|sat\\.?)';
  regex = '([+-]?\\d+\\s' + times + '|' + '(last|next)\\s' + times + ')(\\sago)?';

  match = text.match(new RegExp(regex, 'gi'));
  if (!match) {
    return fail;
  }

  for (i = 0, len = match.length; i < len; i++) {
    if (!process(match[i])) {
      return fail;
    }
  }

  return date.getTime() / 1000;
};
//# sourceMappingURL=strtotime.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function date(format, timestamp) {
  //  discuss at: http://locutus.io/php/date/
  // original by: Carlos R. L. Rodrigues (http://www.jsfromhell.com)
  // original by: gettimeofday
  //    parts by: Peter-Paul Koch (http://www.quirksmode.org/js/beat.html)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: MeEtc (http://yass.meetcweb.com)
  // improved by: Brad Touesnard
  // improved by: Tim Wiel
  // improved by: Bryan Elliott
  // improved by: David Randall
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Brett Zamir (http://brett-zamir.me)
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Thomas Beaucourt (http://www.webapp.fr)
  // improved by: JT
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Rafał Kukawski (http://blog.kukawski.pl)
  // improved by: Theriault (https://github.com/Theriault)
  //    input by: Brett Zamir (http://brett-zamir.me)
  //    input by: majak
  //    input by: Alex
  //    input by: Martin
  //    input by: Alex Wilson
  //    input by: Haravikk
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: majak
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Brett Zamir (http://brett-zamir.me)
  // bugfixed by: omid (http://locutus.io/php/380:380#comment_137122)
  // bugfixed by: Chris (http://www.devotis.nl/)
  //      note 1: Uses global: locutus to store the default timezone
  //      note 1: Although the function potentially allows timezone info
  //      note 1: (see notes), it currently does not set
  //      note 1: per a timezone specified by date_default_timezone_set(). Implementers might use
  //      note 1: $locutus.currentTimezoneOffset and
  //      note 1: $locutus.currentTimezoneDST set by that function
  //      note 1: in order to adjust the dates in this function
  //      note 1: (or our other date functions!) accordingly
  //   example 1: date('H:m:s \\m \\i\\s \\m\\o\\n\\t\\h', 1062402400)
  //   returns 1: '07:09:40 m is month'
  //   example 2: date('F j, Y, g:i a', 1062462400)
  //   returns 2: 'September 2, 2003, 12:26 am'
  //   example 3: date('Y W o', 1062462400)
  //   returns 3: '2003 36 2003'
  //   example 4: var $x = date('Y m d', (new Date()).getTime() / 1000)
  //   example 4: $x = $x + ''
  //   example 4: var $result = $x.length // 2009 01 09
  //   returns 4: 10
  //   example 5: date('W', 1104534000)
  //   returns 5: '52'
  //   example 6: date('B t', 1104534000)
  //   returns 6: '999 31'
  //   example 7: date('W U', 1293750000.82); // 2010-12-31
  //   returns 7: '52 1293750000'
  //   example 8: date('W', 1293836400); // 2011-01-01
  //   returns 8: '52'
  //   example 9: date('W Y-m-d', 1293974054); // 2011-01-02
  //   returns 9: '52 2011-01-02'
  //        test: skip-1 skip-2 skip-5

  var jsdate, f;
  // Keep this here (works, but for code commented-out below for file size reasons)
  // var tal= [];
  var txtWords = ['Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  // trailing backslash -> (dropped)
  // a backslash followed by any character (including backslash) -> the character
  // empty string -> empty string
  var formatChr = /\\?(.?)/gi;
  var formatChrCb = function formatChrCb(t, s) {
    return f[t] ? f[t]() : s;
  };
  var _pad = function _pad(n, c) {
    n = String(n);
    while (n.length < c) {
      n = '0' + n;
    }
    return n;
  };
  f = {
    // Day
    d: function d() {
      // Day of month w/leading 0; 01..31
      return _pad(f.j(), 2);
    },
    D: function D() {
      // Shorthand day name; Mon...Sun
      return f.l().slice(0, 3);
    },
    j: function j() {
      // Day of month; 1..31
      return jsdate.getDate();
    },
    l: function l() {
      // Full day name; Monday...Sunday
      return txtWords[f.w()] + 'day';
    },
    N: function N() {
      // ISO-8601 day of week; 1[Mon]..7[Sun]
      return f.w() || 7;
    },
    S: function S() {
      // Ordinal suffix for day of month; st, nd, rd, th
      var j = f.j();
      var i = j % 10;
      if (i <= 3 && parseInt(j % 100 / 10, 10) === 1) {
        i = 0;
      }
      return ['st', 'nd', 'rd'][i - 1] || 'th';
    },
    w: function w() {
      // Day of week; 0[Sun]..6[Sat]
      return jsdate.getDay();
    },
    z: function z() {
      // Day of year; 0..365
      var a = new Date(f.Y(), f.n() - 1, f.j());
      var b = new Date(f.Y(), 0, 1);
      return Math.round((a - b) / 864e5);
    },

    // Week
    W: function W() {
      // ISO-8601 week number
      var a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3);
      var b = new Date(a.getFullYear(), 0, 4);
      return _pad(1 + Math.round((a - b) / 864e5 / 7), 2);
    },

    // Month
    F: function F() {
      // Full month name; January...December
      return txtWords[6 + f.n()];
    },
    m: function m() {
      // Month w/leading 0; 01...12
      return _pad(f.n(), 2);
    },
    M: function M() {
      // Shorthand month name; Jan...Dec
      return f.F().slice(0, 3);
    },
    n: function n() {
      // Month; 1...12
      return jsdate.getMonth() + 1;
    },
    t: function t() {
      // Days in month; 28...31
      return new Date(f.Y(), f.n(), 0).getDate();
    },

    // Year
    L: function L() {
      // Is leap year?; 0 or 1
      var j = f.Y();
      return j % 4 === 0 & j % 100 !== 0 | j % 400 === 0;
    },
    o: function o() {
      // ISO-8601 year
      var n = f.n();
      var W = f.W();
      var Y = f.Y();
      return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);
    },
    Y: function Y() {
      // Full year; e.g. 1980...2010
      return jsdate.getFullYear();
    },
    y: function y() {
      // Last two digits of year; 00...99
      return f.Y().toString().slice(-2);
    },

    // Time
    a: function a() {
      // am or pm
      return jsdate.getHours() > 11 ? 'pm' : 'am';
    },
    A: function A() {
      // AM or PM
      return f.a().toUpperCase();
    },
    B: function B() {
      // Swatch Internet time; 000..999
      var H = jsdate.getUTCHours() * 36e2;
      // Hours
      var i = jsdate.getUTCMinutes() * 60;
      // Minutes
      // Seconds
      var s = jsdate.getUTCSeconds();
      return _pad(Math.floor((H + i + s + 36e2) / 86.4) % 1e3, 3);
    },
    g: function g() {
      // 12-Hours; 1..12
      return f.G() % 12 || 12;
    },
    G: function G() {
      // 24-Hours; 0..23
      return jsdate.getHours();
    },
    h: function h() {
      // 12-Hours w/leading 0; 01..12
      return _pad(f.g(), 2);
    },
    H: function H() {
      // 24-Hours w/leading 0; 00..23
      return _pad(f.G(), 2);
    },
    i: function i() {
      // Minutes w/leading 0; 00..59
      return _pad(jsdate.getMinutes(), 2);
    },
    s: function s() {
      // Seconds w/leading 0; 00..59
      return _pad(jsdate.getSeconds(), 2);
    },
    u: function u() {
      // Microseconds; 000000-999000
      return _pad(jsdate.getMilliseconds() * 1000, 6);
    },

    // Timezone
    e: function e() {
      // Timezone identifier; e.g. Atlantic/Azores, ...
      // The following works, but requires inclusion of the very large
      // timezone_abbreviations_list() function.
      /*              return that.date_default_timezone_get();
       */
      var msg = 'Not supported (see source code of date() for timezone on how to add support)';
      throw new Error(msg);
    },
    I: function I() {
      // DST observed?; 0 or 1
      // Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.
      // If they are not equal, then DST is observed.
      var a = new Date(f.Y(), 0);
      // Jan 1
      var c = Date.UTC(f.Y(), 0);
      // Jan 1 UTC
      var b = new Date(f.Y(), 6);
      // Jul 1
      // Jul 1 UTC
      var d = Date.UTC(f.Y(), 6);
      return a - c !== b - d ? 1 : 0;
    },
    O: function O() {
      // Difference to GMT in hour format; e.g. +0200
      var tzo = jsdate.getTimezoneOffset();
      var a = Math.abs(tzo);
      return (tzo > 0 ? '-' : '+') + _pad(Math.floor(a / 60) * 100 + a % 60, 4);
    },
    P: function P() {
      // Difference to GMT w/colon; e.g. +02:00
      var O = f.O();
      return O.substr(0, 3) + ':' + O.substr(3, 2);
    },
    T: function T() {
      // The following works, but requires inclusion of the very
      // large timezone_abbreviations_list() function.
      /*              var abbr, i, os, _default;
      if (!tal.length) {
        tal = that.timezone_abbreviations_list();
      }
      if ($locutus && $locutus.default_timezone) {
        _default = $locutus.default_timezone;
        for (abbr in tal) {
          for (i = 0; i < tal[abbr].length; i++) {
            if (tal[abbr][i].timezone_id === _default) {
              return abbr.toUpperCase();
            }
          }
        }
      }
      for (abbr in tal) {
        for (i = 0; i < tal[abbr].length; i++) {
          os = -jsdate.getTimezoneOffset() * 60;
          if (tal[abbr][i].offset === os) {
            return abbr.toUpperCase();
          }
        }
      }
      */
      return 'UTC';
    },
    Z: function Z() {
      // Timezone offset in seconds (-43200...50400)
      return -jsdate.getTimezoneOffset() * 60;
    },

    // Full Date/Time
    c: function c() {
      // ISO-8601 date.
      return 'Y-m-d\\TH:i:sP'.replace(formatChr, formatChrCb);
    },
    r: function r() {
      // RFC 2822
      return 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb);
    },
    U: function U() {
      // Seconds since UNIX epoch
      return jsdate / 1000 | 0;
    }
  };

  var _date = function _date(format, timestamp) {
    jsdate = timestamp === undefined ? new Date() // Not provided
    : timestamp instanceof Date ? new Date(timestamp) // JS Date()
    : new Date(timestamp * 1000) // UNIX timestamp (auto-convert to int)
    ;
    return format.replace(formatChr, formatChrCb);
  };

  return _date(format, timestamp);
};
//# sourceMappingURL=date.js.map

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function boolval(mixedVar) {
  // original by: Will Rowe
  //   example 1: boolval(true)
  //   returns 1: true
  //   example 2: boolval(false)
  //   returns 2: false
  //   example 3: boolval(0)
  //   returns 3: false
  //   example 4: boolval(0.0)
  //   returns 4: false
  //   example 5: boolval('')
  //   returns 5: false
  //   example 6: boolval('0')
  //   returns 6: false
  //   example 7: boolval([])
  //   returns 7: false
  //   example 8: boolval('')
  //   returns 8: false
  //   example 9: boolval(null)
  //   returns 9: false
  //   example 10: boolval(undefined)
  //   returns 10: false
  //   example 11: boolval('true')
  //   returns 11: true

  if (mixedVar === false) {
    return false;
  }

  if (mixedVar === 0 || mixedVar === 0.0) {
    return false;
  }

  if (mixedVar === '' || mixedVar === '0') {
    return false;
  }

  if (Array.isArray(mixedVar) && mixedVar.length === 0) {
    return false;
  }

  if (mixedVar === null || mixedVar === undefined) {
    return false;
  }

  return true;
};
//# sourceMappingURL=boolval.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function (Twig) {
    'use strict';

    Twig.Templates.registerLoader('ajax', function (location, params, callback, errorCallback) {
        let template;
        const {precompiled} = params;
        const parser = this.parsers[params.parser] || this.parser.twig;

        if (typeof XMLHttpRequest === 'undefined') {
            throw new Twig.Error('Unsupported platform: Unable to do ajax requests ' +
                                 'because there is no "XMLHTTPRequest" implementation');
        }

        const xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function () {
            let data = null;

            if (xmlhttp.readyState === 4) {
                if (xmlhttp.status === 200 || (window.cordova && xmlhttp.status === 0)) {
                    Twig.log.debug('Got template ', xmlhttp.responseText);

                    if (precompiled === true) {
                        data = JSON.parse(xmlhttp.responseText);
                    } else {
                        data = xmlhttp.responseText;
                    }

                    params.url = location;
                    params.data = data;

                    template = parser.call(this, params);

                    if (typeof callback === 'function') {
                        callback(template);
                    }
                } else if (typeof errorCallback === 'function') {
                    errorCallback(xmlhttp);
                }
            }
        };

        xmlhttp.open('GET', location, Boolean(params.async));
        xmlhttp.send();

        if (params.async) {
            // TODO: return deferred promise
            return true;
        }

        return template;
    });
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function (Twig) {
    'use strict';

    let fs;
    let path;

    try {
        // Require lib dependencies at runtime
        fs = __webpack_require__(21);
        path = __webpack_require__(1);
    } catch (error) {
        // NOTE: this is in a try/catch to avoid errors cross platform
    }

    Twig.Templates.registerLoader('fs', function (location, params, callback, errorCallback) {
        let template;
        let data = null;
        const {precompiled} = params;
        const parser = this.parsers[params.parser] || this.parser.twig;

        if (!fs || !path) {
            throw new Twig.Error('Unsupported platform: Unable to load from file ' +
                                 'because there is no "fs" or "path" implementation');
        }

        const loadTemplateFn = function (err, data) {
            if (err) {
                if (typeof errorCallback === 'function') {
                    errorCallback(err);
                }

                return;
            }

            if (precompiled === true) {
                data = JSON.parse(data);
            }

            params.data = data;
            params.path = params.path || location;

            // Template is in data
            template = parser.call(this, params);

            if (typeof callback === 'function') {
                callback(template);
            }
        };

        params.path = params.path || location;

        if (params.async) {
            fs.stat(params.path, (err, stats) => {
                if (err || !stats.isFile()) {
                    if (typeof errorCallback === 'function') {
                        errorCallback(new Twig.Error('Unable to find template file ' + params.path));
                    }

                    return;
                }

                fs.readFile(params.path, 'utf8', loadTemplateFn);
            });
            // TODO: return deferred promise
            return true;
        }

        try {
            if (!fs.statSync(params.path).isFile()) {
                throw new Twig.Error('Unable to find template file ' + params.path);
            }
        } catch (error) {
            throw new Twig.Error('Unable to find template file ' + params.path);
        }

        data = fs.readFileSync(params.path, 'utf8');
        loadTemplateFn(undefined, data);
        return template;
    });
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! fs */ 1);

/***/ }),
/* 22 */
/***/ (function(module, exports) {

// ## twig.logic.js
//
// This file handles tokenizing, compiling and parsing logic tokens. {% ... %}
module.exports = function (Twig) {
    'use strict';

    /**
     * Namespace for logic handling.
     */
    Twig.logic = {};

    /**
     * Logic token types.
     */
    Twig.logic.type = {
        if_: 'Twig.logic.type.if',
        endif: 'Twig.logic.type.endif',
        for_: 'Twig.logic.type.for',
        endfor: 'Twig.logic.type.endfor',
        else_: 'Twig.logic.type.else',
        elseif: 'Twig.logic.type.elseif',
        set: 'Twig.logic.type.set',
        setcapture: 'Twig.logic.type.setcapture',
        endset: 'Twig.logic.type.endset',
        filter: 'Twig.logic.type.filter',
        endfilter: 'Twig.logic.type.endfilter',
        apply: 'Twig.logic.type.apply',
        endapply: 'Twig.logic.type.endapply',
        shortblock: 'Twig.logic.type.shortblock',
        block: 'Twig.logic.type.block',
        endblock: 'Twig.logic.type.endblock',
        extends_: 'Twig.logic.type.extends',
        use: 'Twig.logic.type.use',
        include: 'Twig.logic.type.include',
        spaceless: 'Twig.logic.type.spaceless',
        endspaceless: 'Twig.logic.type.endspaceless',
        macro: 'Twig.logic.type.macro',
        endmacro: 'Twig.logic.type.endmacro',
        import_: 'Twig.logic.type.import',
        from: 'Twig.logic.type.from',
        embed: 'Twig.logic.type.embed',
        endembed: 'Twig.logic.type.endembed',
        with: 'Twig.logic.type.with',
        endwith: 'Twig.logic.type.endwith',
        deprecated: 'Twig.logic.type.deprecated'
    };

    // Regular expressions for handling logic tokens.
    //
    // Properties:
    //
    //      type:  The type of expression this matches
    //
    //      regex: A regular expression that matches the format of the token
    //
    //      next:  What logic tokens (if any) pop this token off the logic stack. If empty, the
    //             logic token is assumed to not require an end tag and isn't push onto the stack.
    //
    //      open:  Does this tag open a logic expression or is it standalone. For example,
    //             {% endif %} cannot exist without an opening {% if ... %} tag, so open = false.
    //
    //  Functions:
    //
    //      compile: A function that handles compiling the token into an output token ready for
    //               parsing with the parse function.
    //
    //      parse:   A function that parses the compiled token into output (HTML / whatever the
    //               template represents).
    Twig.logic.definitions = [
        {
            /**
             * If type logic tokens.
             *
             *  Format: {% if expression %}
             */
            type: Twig.logic.type.if_,
            regex: /^if\s?([\s\S]+)$/,
            next: [
                Twig.logic.type.else_,
                Twig.logic.type.elseif,
                Twig.logic.type.endif
            ],
            open: true,
            compile(token) {
                const expression = token.match[1];
                // Compile the expression.
                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;
                delete token.match;
                return token;
            },
            parse(token, context, chain) {
                const state = this;

                return Twig.expression.parseAsync.call(state, token.stack, context)
                    .then(result => {
                        chain = true;

                        if (Twig.lib.boolval(result)) {
                            chain = false;

                            return state.parseAsync(token.output, context);
                        }

                        return '';
                    })
                    .then(output => {
                        return {
                            chain,
                            output
                        };
                    });
            }
        },
        {
            /**
             * Else if type logic tokens.
             *
             *  Format: {% elseif expression %}
             */
            type: Twig.logic.type.elseif,
            regex: /^elseif\s?([^\s].*)$/,
            next: [
                Twig.logic.type.else_,
                Twig.logic.type.elseif,
                Twig.logic.type.endif
            ],
            open: false,
            compile(token) {
                const expression = token.match[1];
                // Compile the expression.
                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;
                delete token.match;
                return token;
            },
            parse(token, context, chain) {
                const state = this;

                return Twig.expression.parseAsync.call(state, token.stack, context)
                    .then(result => {
                        if (chain && Twig.lib.boolval(result)) {
                            chain = false;

                            return state.parseAsync(token.output, context);
                        }

                        return '';
                    })
                    .then(output => {
                        return {
                            chain,
                            output
                        };
                    });
            }
        },
        {
            /**
             * Else type logic tokens.
             *
             *  Format: {% else %}
             */
            type: Twig.logic.type.else_,
            regex: /^else$/,
            next: [
                Twig.logic.type.endif,
                Twig.logic.type.endfor
            ],
            open: false,
            parse(token, context, chain) {
                let promise = Twig.Promise.resolve('');
                const state = this;

                if (chain) {
                    promise = state.parseAsync(token.output, context);
                }

                return promise.then(output => {
                    return {
                        chain,
                        output
                    };
                });
            }
        },
        {
            /**
             * End if type logic tokens.
             *
             *  Format: {% endif %}
             */
            type: Twig.logic.type.endif,
            regex: /^endif$/,
            next: [],
            open: false
        },
        {
            /**
             * For type logic tokens.
             *
             *  Format: {% for expression %}
             */
            type: Twig.logic.type.for_,
            regex: /^for\s+([a-zA-Z0-9_,\s]+)\s+in\s+([\S\s]+?)(?:\s+if\s+([^\s].*))?$/,
            next: [
                Twig.logic.type.else_,
                Twig.logic.type.endfor
            ],
            open: true,
            compile(token) {
                const keyValue = token.match[1];
                const expression = token.match[2];
                const conditional = token.match[3];
                let kvSplit = null;

                token.keyVar = null;
                token.valueVar = null;

                if (keyValue.indexOf(',') >= 0) {
                    kvSplit = keyValue.split(',');
                    if (kvSplit.length === 2) {
                        token.keyVar = kvSplit[0].trim();
                        token.valueVar = kvSplit[1].trim();
                    } else {
                        throw new Twig.Error('Invalid expression in for loop: ' + keyValue);
                    }
                } else {
                    token.valueVar = keyValue.trim();
                }

                // Valid expressions for a for loop
                //   for item     in expression
                //   for key,item in expression

                // Compile the expression.
                token.expression = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                // Compile the conditional (if available)
                if (conditional) {
                    token.conditional = Twig.expression.compile.call(this, {
                        type: Twig.expression.type.expression,
                        value: conditional
                    }).stack;
                }

                delete token.match;
                return token;
            },
            parse(token, context, continueChain) {
                // Parse expression
                const output = [];
                let len;
                let index = 0;
                let keyset;
                const state = this;
                const {conditional} = token;
                const buildLoop = function (index, len) {
                    const isConditional = conditional !== undefined;
                    return {
                        index: index + 1,
                        index0: index,
                        revindex: isConditional ? undefined : len - index,
                        revindex0: isConditional ? undefined : len - index - 1,
                        first: (index === 0),
                        last: isConditional ? undefined : (index === len - 1),
                        length: isConditional ? undefined : len,
                        parent: context
                    };
                };

                // Run once for each iteration of the loop
                const loop = function (key, value) {
                    const innerContext = {...context};

                    innerContext[token.valueVar] = value;

                    if (token.keyVar) {
                        innerContext[token.keyVar] = key;
                    }

                    // Loop object
                    innerContext.loop = buildLoop(index, len);

                    const promise = conditional === undefined ?
                        Twig.Promise.resolve(true) :
                        Twig.expression.parseAsync.call(state, conditional, innerContext);

                    return promise.then(condition => {
                        if (!condition) {
                            return;
                        }

                        return state.parseAsync(token.output, innerContext)
                            .then(tokenOutput => {
                                output.push(tokenOutput);
                                index += 1;
                            });
                    })
                        .then(() => {
                            // Delete loop-related variables from the context
                            delete innerContext.loop;
                            delete innerContext[token.valueVar];
                            delete innerContext[token.keyVar];

                            // Merge in values that exist in context but have changed
                            // in inner_context.
                            Twig.merge(context, innerContext, true);
                        });
                };

                return Twig.expression.parseAsync.call(state, token.expression, context)
                    .then(result => {
                        if (Array.isArray(result)) {
                            len = result.length;
                            return Twig.async.forEach(result, value => {
                                const key = index;

                                return loop(key, value);
                            });
                        }

                        if (Twig.lib.is('Object', result)) {
                            if (result._keys === undefined) {
                                keyset = Object.keys(result);
                            } else {
                                keyset = result._keys;
                            }

                            len = keyset.length;
                            return Twig.async.forEach(keyset, key => {
                            // Ignore the _keys property, it's internal to twig.js
                                if (key === '_keys') {
                                    return;
                                }

                                return loop(key, result[key]);
                            });
                        }
                    })
                    .then(() => {
                    // Only allow else statements if no output was generated
                        continueChain = (output.length === 0);

                        return {
                            chain: continueChain,
                            context,
                            output: Twig.output.call(state.template, output)
                        };
                    });
            }
        },
        {
            /**
             * End for type logic tokens.
             *
             *  Format: {% endfor %}
             */
            type: Twig.logic.type.endfor,
            regex: /^endfor$/,
            next: [],
            open: false
        },
        {
            /**
             * Set type logic tokens.
             *
             *  Format: {% set key = expression %}
             */
            type: Twig.logic.type.set,
            regex: /^set\s+([a-zA-Z0-9_,\s]+)\s*=\s*([\s\S]+)$/,
            next: [],
            open: true,
            compile(token) { //
                const key = token.match[1].trim();
                const expression = token.match[2];
                // Compile the expression.
                const expressionStack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                token.key = key;
                token.expression = expressionStack;

                delete token.match;
                return token;
            },
            parse(token, context, continueChain) {
                const {key} = token;
                const state = this;

                return Twig.expression.parseAsync.call(state, token.expression, context)
                    .then(value => {
                        if (value === context) {
                        /*  If storing the context in a variable, it needs to be a clone of the current state of context.
                            Otherwise we have a context with infinite recursion.
                            Fixes #341
                        */
                            value = {...value};
                        }

                        context[key] = value;

                        return {
                            chain: continueChain,
                            context
                        };
                    });
            }
        },
        {
            /**
             * Set capture type logic tokens.
             *
             *  Format: {% set key %}
             */
            type: Twig.logic.type.setcapture,
            regex: /^set\s+([a-zA-Z0-9_,\s]+)$/,
            next: [
                Twig.logic.type.endset
            ],
            open: true,
            compile(token) {
                const key = token.match[1].trim();

                token.key = key;

                delete token.match;
                return token;
            },
            parse(token, context, continueChain) {
                const state = this;
                const {key} = token;

                return state.parseAsync(token.output, context)
                    .then(output => {
                    // Set on both the global and local context
                        state.context[key] = output;
                        context[key] = output;

                        return {
                            chain: continueChain,
                            context
                        };
                    });
            }
        },
        {
            /**
             * End set type block logic tokens.
             *
             *  Format: {% endset %}
             */
            type: Twig.logic.type.endset,
            regex: /^endset$/,
            next: [],
            open: false
        },
        {
            /**
             * Filter logic tokens.
             *
             *  Format: {% filter upper %} or {% filter lower|escape %}
             */
            type: Twig.logic.type.filter,
            regex: /^filter\s+(.+)$/,
            next: [
                Twig.logic.type.endfilter
            ],
            open: true,
            compile(token) {
                const expression = '|' + token.match[1].trim();
                // Compile the expression.
                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;
                delete token.match;
                return token;
            },
            parse(token, context, chain) {
                const state = this;

                return state.parseAsync(token.output, context)
                    .then(output => {
                        const stack = [{
                            type: Twig.expression.type.string,
                            value: output
                        }].concat(token.stack);

                        return Twig.expression.parseAsync.call(state, stack, context);
                    })
                    .then(output => {
                        return {
                            chain,
                            output
                        };
                    });
            }
        },
        {
            /**
             * End filter logic tokens.
             *
             *  Format: {% endfilter %}
             */
            type: Twig.logic.type.endfilter,
            regex: /^endfilter$/,
            next: [],
            open: false
        },
        {
            /**
             * Apply logic tokens.
             *
             *  Format: {% apply upper %} or {% apply lower|escape %}
             */
            type: Twig.logic.type.apply,
            regex: /^apply\s+(.+)$/,
            next: [
                Twig.logic.type.endapply
            ],
            open: true,
            compile(token) {
                const expression = '|' + token.match[1].trim();
                // Compile the expression.
                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;
                delete token.match;
                return token;
            },
            parse(token, context, chain) {
                const state = this;

                return state.parseAsync(token.output, context)
                    .then(output => {
                        const stack = [{
                            type: Twig.expression.type.string,
                            value: output
                        }].concat(token.stack);

                        return Twig.expression.parseAsync.call(state, stack, context);
                    })
                    .then(output => {
                        return {
                            chain,
                            output
                        };
                    });
            }
        },
        {
            /**
             * End apply logic tokens.
             *
             *  Format: {% endapply %}
             */
            type: Twig.logic.type.endapply,
            regex: /^endapply$/,
            next: [],
            open: false
        },
        {
            /**
             * Block logic tokens.
             *
             *  Format: {% block title %}
             */
            type: Twig.logic.type.block,
            regex: /^block\s+(\w+)$/,
            next: [
                Twig.logic.type.endblock
            ],
            open: true,
            compile(token) {
                token.blockName = token.match[1].trim();
                delete token.match;

                return token;
            },
            parse(token, context, chain) {
                const state = this;
                let promise = Twig.Promise.resolve();

                state.template.blocks.defined[token.blockName] = new Twig.Block(state.template, token);

                if (
                    state.template.parentTemplate === null ||
                    state.template.parentTemplate instanceof Twig.Template
                ) {
                    promise = state.getBlock(token.blockName).render(state, context);
                }

                return promise.then(output => {
                    return {
                        chain,
                        output
                    };
                });
            }
        },
        {
            /**
             * Block shorthand logic tokens.
             *
             *  Format: {% block title expression %}
             */
            type: Twig.logic.type.shortblock,
            regex: /^block\s+(\w+)\s+(.+)$/,
            next: [],
            open: true,
            compile(token) {
                const template = this;

                token.expression = token.match[2].trim();
                token.output = Twig.expression.compile({
                    type: Twig.expression.type.expression,
                    value: token.expression
                }).stack;

                return Twig.logic.handler[Twig.logic.type.block].compile.apply(template, [token]);
            },
            parse(...args) {
                const state = this;

                return Twig.logic.handler[Twig.logic.type.block].parse.apply(state, args);
            }
        },
        {
            /**
             * End block logic tokens.
             *
             *  Format: {% endblock %}
             */
            type: Twig.logic.type.endblock,
            regex: /^endblock(?:\s+(\w+))?$/,
            next: [],
            open: false
        },
        {
            /**
             * Block logic tokens.
             *
             *  Format: {% extends "template.twig" %}
             */
            type: Twig.logic.type.extends_,
            regex: /^extends\s+(.+)$/,
            next: [],
            open: true,
            compile(token) {
                const expression = token.match[1].trim();
                delete token.match;

                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                return token;
            },
            parse(token, context, chain) {
                const state = this;

                return Twig.expression.parseAsync.call(state, token.stack, context)
                    .then(fileName => {
                        state.template.parentTemplate = fileName;

                        return {
                            chain,
                            output: ''
                        };
                    });
            }
        },
        {
            /**
             * Block logic tokens.
             *
             *  Format: {% use "template.twig" %}
             */
            type: Twig.logic.type.use,
            regex: /^use\s+(.+)$/,
            next: [],
            open: true,
            compile(token) {
                const expression = token.match[1].trim();
                delete token.match;

                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                return token;
            },
            parse(token, context, chain) {
                const state = this;

                return Twig.expression.parseAsync.call(state, token.stack, context)
                    .then(filePath => {
                        // Create a new state instead of using the current state
                        // any defined blocks will be created in isolation

                        const useTemplate = state.template.importFile(filePath);

                        const useState = new Twig.ParseState(useTemplate);
                        return useState.parseAsync(useTemplate.tokens)
                            .then(() => {
                                state.template.blocks.imported = {
                                    ...state.template.blocks.imported,
                                    ...useState.getBlocks()
                                };
                            });
                    })
                    .then(() => {
                        return {
                            chain,
                            output: ''
                        };
                    });
            }
        },
        {
            /**
             * Block logic tokens.
             *
             *  Format: {% includes "template.twig" [with {some: 'values'} only] %}
             */
            type: Twig.logic.type.include,
            regex: /^include\s+(.+?)(?:\s|$)(ignore missing(?:\s|$))?(?:with\s+([\S\s]+?))?(?:\s|$)(only)?$/,
            next: [],
            open: true,
            compile(token) {
                const {match} = token;
                const expression = match[1].trim();
                const ignoreMissing = match[2] !== undefined;
                const withContext = match[3];
                const only = ((match[4] !== undefined) && match[4].length);

                delete token.match;

                token.only = only;
                token.ignoreMissing = ignoreMissing;

                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                if (withContext !== undefined) {
                    token.withStack = Twig.expression.compile.call(this, {
                        type: Twig.expression.type.expression,
                        value: withContext.trim()
                    }).stack;
                }

                return token;
            },
            parse(token, context, chain) {
                // Resolve filename
                let innerContext = token.only ? {} : {...context};
                const {ignoreMissing} = token;
                const state = this;
                let promise = null;
                const result = {chain, output: ''};

                if (typeof token.withStack === 'undefined') {
                    promise = Twig.Promise.resolve();
                } else {
                    promise = Twig.expression.parseAsync.call(state, token.withStack, context)
                        .then(withContext => {
                            innerContext = {
                                ...innerContext,
                                ...withContext
                            };
                        });
                }

                return promise
                    .then(() => {
                        return Twig.expression.parseAsync.call(state, token.stack, context);
                    })
                    .then(file => {
                        if (file instanceof Twig.Template) {
                            return file.renderAsync(
                                innerContext,
                                {
                                    isInclude: true
                                }
                            );
                        }

                        try {
                            return state.template.importFile(file).renderAsync(
                                innerContext,
                                {
                                    isInclude: true
                                }
                            );
                        } catch (error) {
                            if (ignoreMissing) {
                                return '';
                            }

                            throw error;
                        }
                    })
                    .then(output => {
                        if (output !== '') {
                            result.output = output;
                        }

                        return result;
                    });
            }
        },
        {
            type: Twig.logic.type.spaceless,
            regex: /^spaceless$/,
            next: [
                Twig.logic.type.endspaceless
            ],
            open: true,

            // Parse the html and return it without any spaces between tags
            parse(token, context, chain) {
                const state = this;

                // Parse the output without any filter
                return state.parseAsync(token.output, context)
                    .then(tokenOutput => {
                        const // A regular expression to find closing and opening tags with spaces between them
                            rBetweenTagSpaces = />\s+</g;
                        // Replace all space between closing and opening html tags
                        let output = tokenOutput.replace(rBetweenTagSpaces, '><').trim();
                        // Rewrap output as a Twig.Markup
                        output = new Twig.Markup(output);
                        return {
                            chain,
                            output
                        };
                    });
            }
        },

        // Add the {% endspaceless %} token
        {
            type: Twig.logic.type.endspaceless,
            regex: /^endspaceless$/,
            next: [],
            open: false
        },
        {
            /**
             * Macro logic tokens.
             *
             * Format: {% macro input(name = default, value, type, size) %}
             *
             */
            type: Twig.logic.type.macro,
            regex: /^macro\s+(\w+)\s*\(\s*((?:\w+(?:\s*=\s*([\s\S]+))?(?:,\s*)?)*)\s*\)$/,
            next: [
                Twig.logic.type.endmacro
            ],
            open: true,
            compile(token) {
                const macroName = token.match[1];
                const rawParameters = token.match[2].split(/\s*,\s*/);
                const parameters = rawParameters.map(rawParameter => {
                    return rawParameter.split(/\s*=\s*/)[0];
                });
                const parametersCount = parameters.length;

                // Duplicate check
                if (parametersCount > 1) {
                    const uniq = {};
                    for (let i = 0; i < parametersCount; i++) {
                        const parameter = parameters[i];
                        if (uniq[parameter]) {
                            throw new Twig.Error('Duplicate arguments for parameter: ' + parameter);
                        } else {
                            uniq[parameter] = 1;
                        }
                    }
                }

                token.macroName = macroName;
                token.parameters = parameters;
                token.defaults = rawParameters.reduce(function (defaults, rawParameter) {
                    const pair = rawParameter.split(/\s*=\s*/);
                    const key = pair[0];
                    const expression = pair[1];

                    if (expression) {
                        defaults[key] = Twig.expression.compile.call(this, {
                            type: Twig.expression.type.expression,
                            value: expression
                        }).stack;
                    } else {
                        defaults[key] = undefined;
                    }

                    return defaults;
                }, {});

                delete token.match;
                return token;
            },
            parse(token, context, chain) {
                const state = this;

                state.macros[token.macroName] = function (...args) {
                    // Pass global context and other macros
                    const macroContext = {
                        _self: state.macros
                    };
                    // Save arguments

                    return Twig.async.forEach(token.parameters, function (prop, i) {
                        // Add parameters from context to macroContext
                        if (typeof args[i] !== 'undefined') {
                            macroContext[prop] = args[i];
                            return true;
                        }

                        if (typeof token.defaults[prop] !== 'undefined') {
                            return Twig.expression.parseAsync.call(this, token.defaults[prop], context)
                                .then(value => {
                                    macroContext[prop] = value;
                                    return Twig.Promise.resolve();
                                });
                        }

                        macroContext[prop] = undefined;
                        return true;
                    }).then(() => {
                        // Render
                        return state.parseAsync(token.output, macroContext);
                    });
                };

                return {
                    chain,
                    output: ''
                };
            }
        },
        {
            /**
             * End macro logic tokens.
             *
             * Format: {% endmacro %}
             */
            type: Twig.logic.type.endmacro,
            regex: /^endmacro$/,
            next: [],
            open: false
        },
        {
            /*
            * Import logic tokens.
            *
            * Format: {% import "template.twig" as form %}
            */
            type: Twig.logic.type.import_,
            regex: /^import\s+(.+)\s+as\s+(\w+)$/,
            next: [],
            open: true,
            compile(token) {
                const expression = token.match[1].trim();
                const contextName = token.match[2].trim();
                delete token.match;

                token.expression = expression;
                token.contextName = contextName;

                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                return token;
            },
            parse(token, context, chain) {
                const state = this;
                const output = {
                    chain,
                    output: ''
                };

                if (token.expression === '_self') {
                    context[token.contextName] = state.macros;
                    return output;
                }

                return Twig.expression.parseAsync.call(state, token.stack, context)
                    .then(filePath => {
                        return state.template.importFile(filePath || token.expression);
                    })
                    .then(importTemplate => {
                        const importState = new Twig.ParseState(importTemplate);

                        return importState.parseAsync(importTemplate.tokens).then(() => {
                            context[token.contextName] = importState.macros;

                            return output;
                        });
                    });
            }
        },
        {
            /*
            * From logic tokens.
            *
            * Format: {% from "template.twig" import func as form %}
            */
            type: Twig.logic.type.from,
            regex: /^from\s+(.+)\s+import\s+([a-zA-Z0-9_, ]+)$/,
            next: [],
            open: true,
            compile(token) {
                const expression = token.match[1].trim();
                const macroExpressions = token.match[2].trim().split(/\s*,\s*/);
                const macroNames = {};

                for (let i = 0; i < macroExpressions.length; i++) {
                    const res = macroExpressions[i];

                    // Match function as variable
                    const macroMatch = res.match(/^(\w+)\s+as\s+(\w+)$/);
                    if (macroMatch) {
                        macroNames[macroMatch[1].trim()] = macroMatch[2].trim();
                    } else if (res.match(/^(\w+)$/)) {
                        macroNames[res] = res;
                    } else {
                        // ignore import
                    }
                }

                delete token.match;

                token.expression = expression;
                token.macroNames = macroNames;

                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                return token;
            },
            parse(token, context, chain) {
                const state = this;
                let promise;

                if (token.expression === '_self') {
                    promise = Twig.Promise.resolve(state.macros);
                } else {
                    promise = Twig.expression.parseAsync.call(state, token.stack, context)
                        .then(filePath => {
                            return state.template.importFile(filePath || token.expression);
                        })
                        .then(importTemplate => {
                            const importState = new Twig.ParseState(importTemplate);

                            return importState.parseAsync(importTemplate.tokens).then(() => {
                                return importState.macros;
                            });
                        });
                }

                return promise
                    .then(macros => {
                        for (const macroName in token.macroNames) {
                            if (macros[macroName] !== undefined) {
                                context[token.macroNames[macroName]] = macros[macroName];
                            }
                        }

                        return {
                            chain,
                            output: ''
                        };
                    });
            }
        },
        {
            /**
             * The embed tag combines the behaviour of include and extends.
             * It allows you to include another template's contents, just like include does.
             *
             *  Format: {% embed "template.twig" [with {some: 'values'} only] %}
             */
            type: Twig.logic.type.embed,
            regex: /^embed\s+(.+?)(?:\s+(ignore missing))?(?:\s+with\s+([\S\s]+?))?(?:\s+(only))?$/,
            next: [
                Twig.logic.type.endembed
            ],
            open: true,
            compile(token) {
                const {match} = token;
                const expression = match[1].trim();
                const ignoreMissing = match[2] !== undefined;
                const withContext = match[3];
                const only = ((match[4] !== undefined) && match[4].length);

                delete token.match;

                token.only = only;
                token.ignoreMissing = ignoreMissing;

                token.stack = Twig.expression.compile.call(this, {
                    type: Twig.expression.type.expression,
                    value: expression
                }).stack;

                if (withContext !== undefined) {
                    token.withStack = Twig.expression.compile.call(this, {
                        type: Twig.expression.type.expression,
                        value: withContext.trim()
                    }).stack;
                }

                return token;
            },
            parse(token, context, chain) {
                let embedContext = {};
                let promise = Twig.Promise.resolve();
                let state = this;

                if (!token.only) {
                    embedContext = {...context};
                }

                if (token.withStack !== undefined) {
                    promise = Twig.expression.parseAsync.call(state, token.withStack, context).then(withContext => {
                        embedContext = {...embedContext, ...withContext};
                    });
                }

                return promise
                    .then(() => {
                        return Twig.expression.parseAsync.call(state, token.stack, embedContext);
                    })
                    .then(fileName => {
                        const embedOverrideTemplate = new Twig.Template({
                            data: token.output,
                            id: state.template.id,
                            base: state.template.base,
                            path: state.template.path,
                            url: state.template.url,
                            name: state.template.name,
                            method: state.template.method,
                            options: state.template.options
                        });

                        try {
                            embedOverrideTemplate.importFile(fileName);
                        } catch (error) {
                            if (token.ignoreMissing) {
                                return '';
                            }

                            // Errors preserve references to variables in scope,
                            // this removes `this` from the scope.
                            state = null;

                            throw error;
                        }

                        embedOverrideTemplate.parentTemplate = fileName;

                        return embedOverrideTemplate.renderAsync(
                            embedContext,
                            {
                                isInclude: true
                            }
                        );
                    })
                    .then(output => {
                        return {
                            chain,
                            output
                        };
                    });
            }
        },
        /* Add the {% endembed %} token
         *
         */
        {
            type: Twig.logic.type.endembed,
            regex: /^endembed$/,
            next: [],
            open: false
        },
        {
            /**
             * Block logic tokens.
             *
             *  Format: {% with {some: 'values'} [only] %}
             */
            type: Twig.logic.type.with,
            regex: /^(?:with\s+([\S\s]+?))(?:\s|$)(only)?$/,
            next: [
                Twig.logic.type.endwith
            ],
            open: true,
            compile(token) {
                const {match} = token;
                const withContext = match[1];
                const only = ((match[2] !== undefined) && match[2].length);

                delete token.match;

                token.only = only;

                if (withContext !== undefined) {
                    token.withStack = Twig.expression.compile.call(this, {
                        type: Twig.expression.type.expression,
                        value: withContext.trim()
                    }).stack;
                }

                return token;
            },
            parse(token, context, chain) {
                // Resolve filename
                let innerContext = {};
                let i;
                const state = this;
                let promise = Twig.Promise.resolve();

                if (!token.only) {
                    innerContext = {...context};
                }

                if (token.withStack !== undefined) {
                    promise = Twig.expression.parseAsync.call(state, token.withStack, context)
                        .then(withContext => {
                            for (i in withContext) {
                                if (Object.hasOwnProperty.call(withContext, i)) {
                                    innerContext[i] = withContext[i];
                                }
                            }
                        });
                }

                return promise
                    .then(() => {
                        return state.parseAsync(token.output, innerContext);
                    })
                    .then(output => {
                        return {
                            chain,
                            output
                        };
                    });
            }
        },
        {
            type: Twig.logic.type.endwith,
            regex: /^endwith$/,
            next: [],
            open: false
        },
        {
            /**
             * Deprecated type logic tokens.
             *
             *  Format: {% deprecated 'Description' %}
             */
            type: Twig.logic.type.deprecated,
            regex: /^deprecated\s+(.+)$/,
            next: [],
            open: true,
            compile(token) {
                console.warn('Deprecation notice: ' + token.match[1]);

                return token;
            },
            parse() {
                return {};
            }
        }

    ];

    /**
     * Registry for logic handlers.
     */
    Twig.logic.handler = {};

    /**
     * Define a new token type, available at Twig.logic.type.{type}
     */
    Twig.logic.extendType = function (type, value) {
        value = value || ('Twig.logic.type' + type);
        Twig.logic.type[type] = value;
    };

    /**
     * Extend the logic parsing functionality with a new token definition.
     *
     * // Define a new tag
     * Twig.logic.extend({
     *     type: Twig.logic.type.{type},
     *     // The pattern to match for this token
     *     regex: ...,
     *     // What token types can follow this token, leave blank if any.
     *     next: [ ... ]
     *     // Create and return compiled version of the token
     *     compile: function(token) { ... }
     *     // Parse the compiled token with the context provided by the render call
     *     //   and whether this token chain is complete.
     *     parse: function(token, context, chain) { ... }
     * });
     *
     * @param {Object} definition The new logic expression.
     */
    Twig.logic.extend = function (definition) {
        if (definition.type) {
            Twig.logic.extendType(definition.type);
        } else {
            throw new Twig.Error('Unable to extend logic definition. No type provided for ' + definition);
        }

        Twig.logic.handler[definition.type] = definition;
    };

    // Extend with built-in expressions
    while (Twig.logic.definitions.length > 0) {
        Twig.logic.extend(Twig.logic.definitions.shift());
    }

    /**
     * Compile a logic token into an object ready for parsing.
     *
     * @param {Object} rawToken An uncompiled logic token.
     *
     * @return {Object} A compiled logic token, ready for parsing.
     */
    Twig.logic.compile = function (rawToken) {
        const expression = rawToken.value.trim();
        let token = Twig.logic.tokenize.call(this, expression);
        const tokenTemplate = Twig.logic.handler[token.type];

        // Check if the token needs compiling
        if (tokenTemplate.compile) {
            token = tokenTemplate.compile.call(this, token);
            Twig.log.trace('Twig.logic.compile: ', 'Compiled logic token to ', token);
        }

        return token;
    };

    /**
     * Tokenize logic expressions. This function matches token expressions against regular
     * expressions provided in token definitions provided with Twig.logic.extend.
     *
     * @param {string} expression the logic token expression to tokenize
     *                (i.e. what's between {% and %})
     *
     * @return {Object} The matched token with type set to the token type and match to the regex match.
     */
    Twig.logic.tokenize = function (expression) {
        let tokenTemplateType = null;
        let tokenType = null;
        let tokenRegex = null;
        let regexArray = null;
        let regexLen = null;
        let regexI = null;
        let match = null;

        // Ignore whitespace around expressions.
        expression = expression.trim();

        for (tokenTemplateType in Twig.logic.handler) {
            if (Object.hasOwnProperty.call(Twig.logic.handler, tokenTemplateType)) {
                // Get the type and regex for this template type
                tokenType = Twig.logic.handler[tokenTemplateType].type;
                tokenRegex = Twig.logic.handler[tokenTemplateType].regex;

                // Handle multiple regular expressions per type.
                regexArray = tokenRegex;
                if (!Array.isArray(tokenRegex)) {
                    regexArray = [tokenRegex];
                }

                regexLen = regexArray.length;
                // Check regular expressions in the order they were specified in the definition.
                for (regexI = 0; regexI < regexLen; regexI++) {
                    match = regexArray[regexI].exec(expression);
                    if (match !== null) {
                        Twig.log.trace('Twig.logic.tokenize: ', 'Matched a ', tokenType, ' regular expression of ', match);
                        return {
                            type: tokenType,
                            match
                        };
                    }
                }
            }
        }

        // No regex matches
        throw new Twig.Error('Unable to parse \'' + expression.trim() + '\'');
    };

    /**
     * Parse a logic token within a given context.
     *
     * What are logic chains?
     *      Logic chains represent a series of tokens that are connected,
     *          for example:
     *          {% if ... %} {% else %} {% endif %}
     *
     *      The chain parameter is used to signify if a chain is open of closed.
     *      open:
     *          More tokens in this chain should be parsed.
     *      closed:
     *          This token chain has completed parsing and any additional
     *          tokens (else, elseif, etc...) should be ignored.
     *
     * @param {Object} token The compiled token.
     * @param {Object} context The render context.
     * @param {boolean} chain Is this an open logic chain. If false, that means a
     *                        chain is closed and no further cases should be parsed.
     */
    Twig.logic.parse = function (token, context, chain, allowAsync) {
        return Twig.async.potentiallyAsync(this, allowAsync, function () {
            Twig.log.debug('Twig.logic.parse: ', 'Parsing logic token ', token);

            const tokenTemplate = Twig.logic.handler[token.type];
            let result;
            const state = this;

            if (!tokenTemplate.parse) {
                return '';
            }

            state.nestingStack.unshift(token);
            result = tokenTemplate.parse.call(state, token, context || {}, chain);

            if (Twig.isPromise(result)) {
                result = result.then(result => {
                    state.nestingStack.shift();

                    return result;
                });
            } else {
                state.nestingStack.shift();
            }

            return result;
        });
    };

    return Twig;
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = function (Twig) {
    'use strict';

    Twig.Templates.registerParser('source', params => {
        return params.data || '';
    });
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function (Twig) {
    'use strict';

    Twig.Templates.registerParser('twig', params => {
        return new Twig.Template(params);
    });
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// ## twig.path.js
//
// This file handles path parsing
module.exports = function (Twig) {
    'use strict';

    /**
     * Namespace for path handling.
     */
    Twig.path = {};

    /**
     * Generate the canonical version of a url based on the given base path and file path and in
     * the previously registered namespaces.
     *
     * @param  {string} template The Twig Template
     * @param  {string} _file    The file path, may be relative and may contain namespaces.
     *
     * @return {string}          The canonical version of the path
     */
    Twig.path.parsePath = function (template, _file) {
        let k = null;
        const {namespaces} = template.options;
        let file = _file || '';
        const hasNamespaces = namespaces && typeof namespaces === 'object';

        if (hasNamespaces) {
            for (k in namespaces) {
                if (file.indexOf(k) === -1) {
                    continue;
                }

                // Check if keyed namespace exists at path's start
                const colon = new RegExp('^' + k + '::');
                const atSign = new RegExp('^@' + k + '/');
                // Add slash to the end of path
                const namespacePath = namespaces[k].replace(/([^/])$/, '$1/');

                if (colon.test(file)) {
                    file = file.replace(colon, namespacePath);
                    return file;
                }

                if (atSign.test(file)) {
                    file = file.replace(atSign, namespacePath);
                    return file;
                }
            }
        }

        return Twig.path.relativePath(template, file);
    };

    /**
     * Generate the relative canonical version of a url based on the given base path and file path.
     *
     * @param {Twig.Template} template The Twig.Template.
     * @param {string} _file The file path, relative to the base path.
     *
     * @return {string} The canonical version of the path.
     */
    Twig.path.relativePath = function (template, _file) {
        let base;
        let basePath;
        let sepChr = '/';
        const newPath = [];
        let file = _file || '';
        let val;

        if (template.url) {
            if (typeof template.base === 'undefined') {
                base = template.url;
            } else {
                // Add slash to the end of path
                base = template.base.replace(/([^/])$/, '$1/');
            }
        } else if (template.path) {
            // Get the system-specific path separator
            const path = __webpack_require__(1);
            const sep = path.sep || sepChr;
            const relative = new RegExp('^\\.{1,2}' + sep.replace('\\', '\\\\'));
            file = file.replace(/\//g, sep);

            if (template.base !== undefined && file.match(relative) === null) {
                file = file.replace(template.base, '');
                base = template.base + sep;
            } else {
                base = path.normalize(template.path);
            }

            base = base.replace(sep + sep, sep);
            sepChr = sep;
        } else if ((template.name || template.id) && template.method && template.method !== 'fs' && template.method !== 'ajax') {
            // Custom registered loader
            base = template.base || template.name || template.id;
        } else {
            throw new Twig.Error('Cannot extend an inline template.');
        }

        basePath = base.split(sepChr);

        // Remove file from url
        basePath.pop();
        basePath = basePath.concat(file.split(sepChr));

        while (basePath.length > 0) {
            val = basePath.shift();
            if (val === '.') {
                // Ignore
            } else if (val === '..' && newPath.length > 0 && newPath[newPath.length - 1] !== '..') {
                newPath.pop();
            } else {
                newPath.push(val);
            }
        }

        return newPath.join(sepChr);
    };

    return Twig;
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

// ## twig.tests.js
//
// This file handles expression tests. (is empty, is not defined, etc...)
module.exports = function (Twig) {
    'use strict';
    Twig.tests = {
        empty(value) {
            if (value === null || value === undefined) {
                return true;
            }

            // Handler numbers
            if (typeof value === 'number') {
                return false;
            } // Numbers are never "empty"

            // Handle strings and arrays
            if (value.length > 0) {
                return false;
            }

            // Handle objects
            for (const key in value) {
                if (Object.hasOwnProperty.call(value, key)) {
                    return false;
                }
            }

            return true;
        },
        odd(value) {
            return value % 2 === 1;
        },
        even(value) {
            return value % 2 === 0;
        },
        divisibleby(value, params) {
            return value % params[0] === 0;
        },
        defined(value) {
            return value !== undefined;
        },
        none(value) {
            return value === null;
        },
        null(value) {
            return this.none(value); // Alias of none
        },
        'same as'(value, params) {
            return value === params[0];
        },
        sameas(value, params) {
            console.warn('`sameas` is deprecated use `same as`');
            return Twig.tests['same as'](value, params);
        },
        iterable(value) {
            return value && (Twig.lib.is('Array', value) || Twig.lib.is('Object', value));
        }
        /*
        Constant ?
         */
    };

    Twig.test = function (test, value, params) {
        if (!Twig.tests[test]) {
            throw Twig.Error('Test ' + test + ' is not defined.');
        }

        return Twig.tests[test](value, params);
    };

    Twig.test.extend = function (test, definition) {
        Twig.tests[test] = definition;
    };

    return Twig;
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

// ## twig.async.js
//
// This file handles asynchronous tasks within twig.
module.exports = function (Twig) {
    'use strict';

    const STATE_UNKNOWN = 0;
    const STATE_RESOLVED = 1;
    const STATE_REJECTED = 2;

    Twig.ParseState.prototype.parseAsync = function (tokens, context) {
        return this.parse(tokens, context, true);
    };

    Twig.expression.parseAsync = function (tokens, context, tokensAreParameters) {
        const state = this;

        return Twig.expression.parse.call(state, tokens, context, tokensAreParameters, true);
    };

    Twig.logic.parseAsync = function (token, context, chain) {
        const state = this;

        return Twig.logic.parse.call(state, token, context, chain, true);
    };

    Twig.Template.prototype.renderAsync = function (context, params) {
        return this.render(context, params, true);
    };

    Twig.async = {};

    /**
     * Checks for `thenable` objects
     */
    Twig.isPromise = function (obj) {
        return obj && obj.then && (typeof obj.then === 'function');
    };

    /**
     * Handling of code paths that might either return a promise
     * or a value depending on whether async code is used.
     *
     * @see https://github.com/twigjs/twig.js/blob/master/ASYNC.md#detecting-asynchronous-behaviour
     */
    function potentiallyAsyncSlow(that, allowAsync, action) {
        let result = action.call(that);
        let err = null;
        let isAsync = true;

        if (!Twig.isPromise(result)) {
            return result;
        }

        result.then(res => {
            result = res;
            isAsync = false;
        }).catch(error => {
            err = error;
        });

        if (err !== null) {
            throw err;
        }

        if (isAsync) {
            throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');
        }

        return result;
    }

    Twig.async.potentiallyAsync = function (that, allowAsync, action) {
        if (allowAsync) {
            return Twig.Promise.resolve(action.call(that));
        }

        return potentiallyAsyncSlow(that, allowAsync, action);
    };

    function run(fn, resolve, reject) {
        try {
            fn(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }

    function pending(handlers, onResolved, onRejected) {
        const h = [onResolved, onRejected, -2];

        // The promise has yet to be rejected or resolved.
        if (!handlers) {
            handlers = h;
        } else if (handlers[2] === -2) {
            // Only allocate an array when there are multiple handlers
            handlers = [handlers, h];
        } else {
            handlers.push(h);
        }

        return handlers;
    }

    /**
     * Really small thenable to represent promises that resolve immediately.
     *
     */
    Twig.Thenable = function (then, value, state) {
        this.then = then;
        this._value = state ? value : null;
        this._state = state || STATE_UNKNOWN;
    };

    Twig.Thenable.prototype.catch = function (onRejected) {
        // THe promise will not throw, it has already resolved.
        if (this._state === STATE_RESOLVED) {
            return this;
        }

        return this.then(null, onRejected);
    };

    /**
     * The `then` method attached to a Thenable when it has resolved.
     *
     */
    Twig.Thenable.resolvedThen = function (onResolved) {
        try {
            return Twig.Promise.resolve(onResolved(this._value));
        } catch (error) {
            return Twig.Promise.reject(error);
        }
    };

    /**
     * The `then` method attached to a Thenable when it has rejected.
     *
     */
    Twig.Thenable.rejectedThen = function (onResolved, onRejected) {
        // Shortcut for rejected twig promises
        if (!onRejected || typeof onRejected !== 'function') {
            return this;
        }

        const value = this._value;

        let result;
        try {
            result = onRejected(value);
        } catch (error) {
            result = Twig.Promise.reject(error);
        }

        return Twig.Promise.resolve(result);
    };

    /**
     * An alternate implementation of a Promise that does not fully follow
     * the spec, but instead works fully synchronous while still being
     * thenable.
     *
     * These promises can be mixed with regular promises at which point
     * the synchronous behaviour is lost.
     */
    Twig.Promise = function (executor) {
        let state = STATE_UNKNOWN;
        let value = null;

        let changeState = function (nextState, nextValue) {
            state = nextState;
            value = nextValue;
        };

        function onReady(v) {
            changeState(STATE_RESOLVED, v);
        }

        function onReject(e) {
            changeState(STATE_REJECTED, e);
        }

        run(executor, onReady, onReject);

        // If the promise settles right after running the executor we can
        // return a Promise with it's state already set.
        //
        // Twig.Promise.resolve and Twig.Promise.reject both use the more
        // efficient `Twig.Thenable` for this purpose.
        if (state === STATE_RESOLVED) {
            return Twig.Promise.resolve(value);
        }

        if (state === STATE_REJECTED) {
            return Twig.Promise.reject(value);
        }
        // If we managed to get here our promise is going to resolve asynchronous.

        changeState = new Twig.FullPromise();

        return changeState.promise;
    };

    /**
     * Promise implementation that can handle being resolved at any later time.
     *
     */
    Twig.FullPromise = function () {
        let handlers = null;

        // The state has been changed to either resolve, or reject
        // which means we should call the handler.
        function resolved(onResolved) {
            onResolved(p._value);
        }

        function rejected(onResolved, onRejected) {
            onRejected(p._value);
        }

        let append = function (onResolved, onRejected) {
            handlers = pending(handlers, onResolved, onRejected);
        };

        function changeState(newState, v) {
            if (p._state) {
                return;
            }

            p._value = v;
            p._state = newState;

            append = newState === STATE_RESOLVED ? resolved : rejected;

            if (!handlers) {
                return;
            }

            if (handlers[2] === -2) {
                append(handlers[0], handlers[1]);
                handlers = null;
            }

            handlers.forEach(h => {
                append(h[0], h[1]);
            });
            handlers = null;
        }

        const p = new Twig.Thenable((onResolved, onRejected) => {
            const hasResolved = typeof onResolved === 'function';

            // Shortcut for resolved twig promises
            if (p._state === STATE_RESOLVED && !hasResolved) {
                return Twig.Promise.resolve(p._value);
            }

            if (p._state === STATE_RESOLVED) {
                try {
                    return Twig.Promise.resolve(onResolved(p._value));
                } catch (error) {
                    return Twig.Promise.reject(error);
                }
            }

            const hasRejected = typeof onRejected === 'function';

            return new Twig.Promise((resolve, reject) => {
                append(
                    hasResolved ? result => {
                        try {
                            resolve(onResolved(result));
                        } catch (error) {
                            reject(error);
                        }
                    } : resolve,
                    hasRejected ? err => {
                        try {
                            resolve(onRejected(err));
                        } catch (error) {
                            reject(error);
                        }
                    } : reject
                );
            });
        });

        changeState.promise = p;

        return changeState;
    };

    Twig.Promise.defaultResolved = new Twig.Thenable(Twig.Thenable.resolvedThen, undefined, STATE_RESOLVED);
    Twig.Promise.emptyStringResolved = new Twig.Thenable(Twig.Thenable.resolvedThen, '', STATE_RESOLVED);

    Twig.Promise.resolve = function (value) {
        if (arguments.length === 0 || typeof value === 'undefined') {
            return Twig.Promise.defaultResolved;
        }

        if (Twig.isPromise(value)) {
            return value;
        }

        // Twig often resolves with an empty string, we optimize for this
        // scenario by returning a fixed promise. This reduces the load on
        // garbage collection.
        if (value === '') {
            return Twig.Promise.emptyStringResolved;
        }

        return new Twig.Thenable(Twig.Thenable.resolvedThen, value, STATE_RESOLVED);
    };

    Twig.Promise.reject = function (e) {
        // `e` should never be a promise.
        return new Twig.Thenable(Twig.Thenable.rejectedThen, e, STATE_REJECTED);
    };

    Twig.Promise.all = function (promises) {
        const results = new Array(promises.length);

        return Twig.async.forEach(promises, (p, index) => {
            if (!Twig.isPromise(p)) {
                results[index] = p;
                return;
            }

            if (p._state === STATE_RESOLVED) {
                results[index] = p._value;
                return;
            }

            return p.then(v => {
                results[index] = v;
            });
        }).then(() => {
            return results;
        });
    };

    /**
    * Go over each item in a fashion compatible with Twig.forEach,
    * allow the function to return a promise or call the third argument
    * to signal it is finished.
    *
    * Each item in the array will be called sequentially.
    */
    Twig.async.forEach = function (arr, callback) {
        const len = arr.length;
        let index = 0;

        function next() {
            let resp = null;

            do {
                if (index === len) {
                    return Twig.Promise.resolve();
                }

                resp = callback(arr[index], index);
                index++;

            // While the result of the callback is not a promise or it is
            // a promise that has settled we can use a regular loop which
            // is much faster.
            } while (!resp || !Twig.isPromise(resp) || resp._state === STATE_RESOLVED);

            return resp.then(next);
        }

        return next();
    };

    return Twig;
};


/***/ }),
/* 28 */
/***/ (function(module, exports) {

// ## twig.exports.js
//
// This file provides extension points and other hooks into the twig functionality.

module.exports = function (Twig) {
    'use strict';
    Twig.exports = {
        VERSION: Twig.VERSION
    };

    /**
     * Create and compile a twig.js template.
     *
     * @param {Object} param Paramteres for creating a Twig template.
     *
     * @return {Twig.Template} A Twig template ready for rendering.
     */
    Twig.exports.twig = function (params) {
        'use strict';
        const {id} = params;
        const options = {
            strictVariables: params.strict_variables || false,
            // TODO: turn autoscape on in the next major version
            autoescape: (params.autoescape !== null && params.autoescape) || false,
            allowInlineIncludes: params.allowInlineIncludes || false,
            rethrow: params.rethrow || false,
            namespaces: params.namespaces
        };

        if (Twig.cache && id) {
            Twig.validateId(id);
        }

        if (params.debug !== undefined) {
            Twig.debug = params.debug;
        }

        if (params.trace !== undefined) {
            Twig.trace = params.trace;
        }

        if (params.data !== undefined) {
            return Twig.Templates.parsers.twig({
                data: params.data,
                path: Object.hasOwnProperty.call(params, 'path') ? params.path : undefined,
                module: params.module,
                id,
                options
            });
        }

        if (params.ref !== undefined) {
            if (params.id !== undefined) {
                throw new Twig.Error('Both ref and id cannot be set on a twig.js template.');
            }

            return Twig.Templates.load(params.ref);
        }

        if (params.method !== undefined) {
            if (!Twig.Templates.isRegisteredLoader(params.method)) {
                throw new Twig.Error('Loader for "' + params.method + '" is not defined.');
            }

            return Twig.Templates.loadRemote(params.name || params.href || params.path || id || undefined, {
                id,
                method: params.method,
                parser: params.parser || 'twig',
                base: params.base,
                module: params.module,
                precompiled: params.precompiled,
                async: params.async,
                options

            }, params.load, params.error);
        }

        if (params.href !== undefined) {
            return Twig.Templates.loadRemote(params.href, {
                id,
                method: 'ajax',
                parser: params.parser || 'twig',
                base: params.base,
                module: params.module,
                precompiled: params.precompiled,
                async: params.async,
                options

            }, params.load, params.error);
        }

        if (params.path !== undefined) {
            return Twig.Templates.loadRemote(params.path, {
                id,
                method: 'fs',
                parser: params.parser || 'twig',
                base: params.base,
                module: params.module,
                precompiled: params.precompiled,
                async: params.async,
                options
            }, params.load, params.error);
        }
    };

    // Extend Twig with a new filter.
    Twig.exports.extendFilter = function (filter, definition) {
        Twig.filter.extend(filter, definition);
    };

    // Extend Twig with a new function.
    Twig.exports.extendFunction = function (fn, definition) {
        Twig._function.extend(fn, definition);
    };

    // Extend Twig with a new test.
    Twig.exports.extendTest = function (test, definition) {
        Twig.test.extend(test, definition);
    };

    // Extend Twig with a new definition.
    Twig.exports.extendTag = function (definition) {
        Twig.logic.extend(definition);
    };

    // Provide an environment for extending Twig core.
    // Calls fn with the internal Twig object.
    Twig.exports.extend = function (fn) {
        fn(Twig);
    };

    /**
     * Provide an extension for use with express 2.
     *
     * @param {string} markup The template markup.
     * @param {array} options The express options.
     *
     * @return {string} The rendered template.
     */
    Twig.exports.compile = function (markup, options) {
        const id = options.filename;
        const path = options.filename;

        // Try to load the template from the cache
        const template = new Twig.Template({
            data: markup,
            path,
            id,
            options: options.settings['twig options']
        }); // Twig.Templates.load(id) ||

        return function (context) {
            return template.render(context);
        };
    };

    /**
     * Provide an extension for use with express 3.
     *
     * @param {string} path The location of the template file on disk.
     * @param {Object|Function} The options or callback.
     * @param {Function} fn callback.
     *
     * @throws Twig.Error
     */
    Twig.exports.renderFile = function (path, options, fn) {
        // Handle callback in options
        if (typeof options === 'function') {
            fn = options;
            options = {};
        }

        options = options || {};

        const settings = options.settings || {};

        // Mixin any options provided to the express app.
        const viewOptions = settings['twig options'];

        const params = {
            path,
            base: settings.views,
            load(template) {
                // Render and return template as a simple string, see https://github.com/twigjs/twig.js/pull/348 for more information
                if (!viewOptions || !viewOptions.allowAsync) {
                    fn(null, String(template.render(options)));
                    return;
                }

                template.renderAsync(options)
                    .then(out => fn(null, out), fn);
            }
        };

        if (viewOptions) {
            for (const option in viewOptions) {
                if (Object.hasOwnProperty.call(viewOptions, option)) {
                    params[option] = viewOptions[option];
                }
            }
        }

        Twig.exports.twig(params);
    };

    // Express 3 handler
    Twig.exports.__express = Twig.exports.renderFile;

    /**
     * Shoud Twig.js cache templates.
     * Disable during development to see changes to templates without
     * reloading, and disable in production to improve performance.
     *
     * @param {boolean} cache
     */
    Twig.exports.cache = function (cache) {
        Twig.cache = cache;
    };

    // We need to export the path module so we can effectively test it
    Twig.exports.path = Twig.path;

    // Export our filters.
    // Resolves #307
    Twig.exports.filters = Twig.filters;

    // Export our tests.
    Twig.exports.tests = Twig.tests;

    Twig.exports.Promise = Twig.Promise;

    return Twig;
};


/***/ })
/******/ ]);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/js/index.ts":
/*!*************************!*\
  !*** ./src/js/index.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var svg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svg.js */ "./node_modules/svg.js/dist/svg.js");
/* harmony import */ var svg_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(svg_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _knot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./knot */ "./src/js/knot/index.ts");
/* harmony import */ var _summary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./summary */ "./src/js/summary/index.ts");
document.body.innerHTML = __webpack_require__(/*! ../twig/content.twig */ "./src/twig/content.twig")();



const knot = new _knot__WEBPACK_IMPORTED_MODULE_1__["Knot"]({ vertices: 256, halfedges: 512, faces: 0 });
const start = knot.createVertex();
knot.setStaticLocation(start, 0, 0.5);
knot.setRadius(start, 0.4);
const end = knot.createVertex();
knot.setStaticLocation(end, 1, 0.5);
knot.setRadius(end, 0.4);
knot.createEdge(start, end);
knot.subdivide();
knot.subdivide();
knot.subdivide();
knot.subdivide();
knot.subdivide();
for (const element of document.getElementsByClassName('knot-horizontal')) {
    const picture = svg_js__WEBPACK_IMPORTED_MODULE_0__(element);
    picture.size('100%', '20px');
    picture.viewbox({ x: 0.0, y: 0.0, width: 1.0, height: 1.0 });
    picture.attr('preserveAspectRatio', 'none');
    Object(_knot__WEBPACK_IMPORTED_MODULE_1__["render"])(knot, picture);
}
/** SUMMARY **/
const summaryRoot = document.getElementById('summary-content');
for (const heading of _summary__WEBPACK_IMPORTED_MODULE_2__["extract"](document.body).children) {
    summaryRoot.append(_summary__WEBPACK_IMPORTED_MODULE_2__["generate"](heading));
}
/**
* Adversial table.
*/
//generateAdversialTable(document.getElementById('adversial-test-table'))
/**
* Self table.
*/
//generateSelfTable(document.getElementById('self-resolution-table'))


/***/ }),

/***/ "./src/js/knot/Knot.ts":
/*!*****************************!*\
  !*** ./src/js/knot/Knot.ts ***!
  \*****************************/
/*! exports provided: Knot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Knot", function() { return Knot; });
/* harmony import */ var _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cedric-demongivert/gl-tool-collection */ "./node_modules/@cedric-demongivert/gl-tool-collection/index.js");
/* harmony import */ var _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cedric-demongivert/gl-tool-math */ "./node_modules/@cedric-demongivert/gl-tool-math/index.js");
/* harmony import */ var _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cedric_demongivert_gl_tool_halfedge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cedric-demongivert/gl-tool-halfedge */ "./node_modules/@cedric-demongivert/gl-tool-halfedge/index.js");
/* harmony import */ var _cedric_demongivert_gl_tool_halfedge__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cedric_demongivert_gl_tool_halfedge__WEBPACK_IMPORTED_MODULE_2__);



class Knot extends _cedric_demongivert_gl_tool_halfedge__WEBPACK_IMPORTED_MODULE_2__["HalfedgeStructure"] {
    /**
    * Instantiate a new empty 2D knot with the given capacity.
    *
    * @param capacity - An object that describe the capacity to allocate to the new knot structure.
    */
    constructor(capacity) {
        super(capacity);
        this._locations = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__["Packs"].float32(capacity.vertices * 3);
        this._radius = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__["Packs"].float32(capacity.vertices);
    }
    createVertex() {
        const vertex = super.createVertex();
        this.setStaticLocation(vertex, 0, 0);
        this._locations.set(vertex * 3 + 3, 1);
        this.setRadius(vertex, 0);
        return vertex;
    }
    subdivide() {
        const undivided = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__["Packs"].uint32(this.halfedges.size);
        for (const halfedge of this.halfedges) {
            undivided.push(halfedge);
        }
        const startLocation = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1__["Vector2f"]();
        const endLocation = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1__["Vector2f"]();
        while (undivided.size > 0) {
            const halfedge = undivided.get(undivided.size - 1);
            const pair = this.getPairHalfedge(halfedge);
            undivided.delete(undivided.size - 1);
            undivided.warp(pair);
            const start = this.getStartingVertex(halfedge);
            const end = this.getEndingVertex(halfedge);
            this.extractLocation(start, startLocation);
            this.extractLocation(end, endLocation);
            startLocation.add(endLocation);
            startLocation.divideWithScalar(2.0);
            const middle = this.createVertex();
            this.setLocation(middle, startLocation);
            this.setRadius(middle, (this.getRadius(start) + this.getRadius(end)) / 2);
            this.split(halfedge, middle);
        }
    }
    getRadius(vertex) {
        return this._radius.get(vertex);
    }
    setRadius(vertex, radius) {
        this._radius.set(vertex, radius);
    }
    extractLocation(vertex, output) {
        const offset = vertex * 3;
        return output.set(this._locations.get(offset), this._locations.get(offset + 1));
    }
    extractHomogeneousLocation(vertex, output) {
        const offset = vertex * 3;
        return output.set(this._locations.get(offset), this._locations.get(offset + 1), 1.0);
    }
    setStaticLocation(vertex, x, y) {
        const offset = vertex * 3;
        this._locations.set(offset, x);
        this._locations.set(offset + 1, y);
    }
    setLocation(vertex, input) {
        this.setStaticLocation(vertex, input.x, input.y);
    }
    setHomogeneousLocation(vertex, input) {
        this.setStaticLocation(vertex, input.x, input.y);
    }
    getLocation(vertex) {
        const offset = vertex * 3;
        return _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1__["Vector2f"].wrap(this._locations.array.subarray(offset, offset + 2));
    }
    getHomogeneousLocation(vertex) {
        const offset = vertex * 3;
        return _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_1__["Vector3f"].wrap(this._locations.array.subarray(offset, offset + 3));
    }
    x(vertex) {
        return this._locations.get(vertex * 3);
    }
    y(vertex) {
        return this._locations.get(vertex * 3 + 1);
    }
    extractDirection(halfedge, output) {
        const start = this.getStartingVertex(halfedge);
        const end = this.getEndingVertex(halfedge);
        return output.set(this.x(end) - this.x(start), this.y(end) - this.y(start));
    }
    dx(halfedge) {
        const start = this.getStartingVertex(halfedge);
        const end = this.getEndingVertex(halfedge);
        return this.x(end) - this.x(start);
    }
    dy(halfedge) {
        const start = this.getStartingVertex(halfedge);
        const end = this.getEndingVertex(halfedge);
        return this.y(end) - this.y(start);
    }
    length(halfedge) {
        return Math.sqrt(this.squaredLength(halfedge));
    }
    squaredLength(halfedge) {
        const start = this.getStartingVertex(halfedge);
        const end = this.getEndingVertex(halfedge);
        const x = this.x(end) - this.x(start);
        const y = this.y(end) - this.y(start);
        return x * x + y * y;
    }
}


/***/ }),

/***/ "./src/js/knot/index.ts":
/*!******************************!*\
  !*** ./src/js/knot/index.ts ***!
  \******************************/
/*! exports provided: Knot, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Knot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Knot */ "./src/js/knot/Knot.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Knot", function() { return _Knot__WEBPACK_IMPORTED_MODULE_0__["Knot"]; });

/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render */ "./src/js/knot/render.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _render__WEBPACK_IMPORTED_MODULE_1__["render"]; });





/***/ }),

/***/ "./src/js/knot/render.ts":
/*!*******************************!*\
  !*** ./src/js/knot/render.ts ***!
  \*******************************/
/*! exports provided: render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cedric-demongivert/gl-tool-math */ "./node_modules/@cedric-demongivert/gl-tool-math/index.js");
/* harmony import */ var _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cedric-demongivert/gl-tool-collection */ "./node_modules/@cedric-demongivert/gl-tool-collection/index.js");
/* harmony import */ var _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_1__);


function drawVertices(knot, picture) {
    const vertices = knot.vertices;
    const location = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    for (let index = 0, size = vertices.size; index < size; ++index) {
        const vertex = vertices.get(index);
        knot.extractLocation(vertex, location);
        picture.circle(0.02)
            .fill('#f06')
            .move(location.x - 0.01, location.y - 0.01);
    }
}
function drawEdges(knot, picture) {
    const unvisited = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_1__["Sets"].SparseDense.uint32(knot.halfedges.size);
    for (let index = 0, size = knot.halfedges.size; index < size; ++index) {
        unvisited.add(knot.halfedges.get(index));
    }
    let start = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    let end = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    while (unvisited.size > 0) {
        let halfedge = unvisited.get(0);
        unvisited.delete(halfedge);
        unvisited.delete(knot.getPairHalfedge(halfedge));
        knot.extractLocation(knot.getStartingVertex(halfedge), start);
        knot.extractLocation(knot.getEndingVertex(halfedge), end);
        picture.polyline(`${start.x},${start.y} ${end.x},${end.y}`)
            .fill('none')
            .stroke({
            color: '#f06',
            width: 0.005,
            linecap: 'butt',
            linejoin: 'round'
        });
    }
}
/*
function drawBoundary (knot : Knot, start, picture) {
  let fromVertex = new Vector2f()
  let toVertex = new Vector2f()

  let halfedge = start

  do {
    knot.getLocationOfVertex(knot.getStartOfHalfedge(halfedge), fromVertex)
    knot.getLocationOfVertex(knot.getEndOfHalfedge(halfedge), toVertex)

    picture.polyline(
      `${fromVertex.x},${fromVertex.y} ${toVertex.x},${toVertex.y}`
    ).fill('none')
     .stroke({
       color: '#f06',
       width: 0.005,
       linecap: 'butt',
       linejoin: 'round'
     })

    halfedge = knot.getNextHalfedge(halfedge)
  } while (halfedge != start)
}
*/
function render(knot, picture) {
    const unvisited = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_1__["Sets"].SparseDense.uint32(knot.halfedges.size);
    const states = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_1__["Packs"].uint8(knot.halfedges.size);
    for (let index = 0, size = knot.halfedges.size; index < size; ++index) {
        unvisited.add(knot.halfedges.get(index));
    }
    while (unvisited.size > 0) {
        let halfedge = unvisited.get(0);
        while (unvisited.has(halfedge)) {
            unvisited.delete(halfedge);
            const pair = knot.getPairHalfedge(halfedge);
            const next = knot.getNextHalfedge(halfedge);
            const previous = knot.getPreviousHalfedge(halfedge);
            if (!unvisited.has(pair)) {
                states.set(halfedge, 1 - states.get(pair));
            }
            else if (!unvisited.has(previous)) {
                states.set(halfedge, 1 - states.get(previous));
            }
            else if (!unvisited.has(next)) {
                states.set(halfedge, 1 - states.get(next));
            }
            else {
                states.set(halfedge, 1);
            }
            if (states.get(halfedge) === 0) {
                drawHalfedgeDown(knot, pair, picture);
            }
            halfedge = knot.getNextHalfedge(halfedge);
        }
    }
    for (let index = 0; index < states.size; ++index) {
        if (states.get(index) === 1) {
            drawHalfedgeUp(knot, index, picture);
        }
    }
}
function drawHalfedgeUp(knot, halfedge, picture) {
    const pair = knot.getPairHalfedge(halfedge);
    const previous = knot.getPreviousHalfedge(halfedge);
    const current = halfedge;
    const next = knot.getNextHalfedge(halfedge);
    const previousDirection = knot.extractDirection(previous, new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const currentDirection = knot.extractDirection(current, new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const nextDirection = knot.extractDirection(next, new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const previousNormal = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    const currentNormal = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    const nextNormal = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    if (previous === pair) {
        currentDirection.clockwiseNormal(previousNormal);
    }
    else {
        previousDirection.clockwiseNormal(previousNormal);
    }
    currentDirection.clockwiseNormal(currentNormal);
    if (next === pair) {
        currentDirection.clockwiseNormal(nextNormal);
    }
    else {
        nextDirection.clockwiseNormal(nextNormal);
    }
    const start = knot.extractLocation(knot.getStartingVertex(halfedge), new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const end = knot.extractLocation(knot.getEndingVertex(halfedge), new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const lineStart = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    const lineEnd = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    lineStart.copy(currentNormal)
        .add(previousNormal)
        .normalize()
        .multiplyWithScalar(knot.getRadius(knot.getStartingVertex(halfedge)))
        .add(start);
    const sx = lineStart.x;
    const sy = lineStart.y;
    const dsx = sx + currentDirection.x / 2.0;
    const dsy = sy + currentDirection.y / 2.0;
    lineEnd.copy(currentNormal)
        .add(nextNormal)
        .normalize()
        .multiplyWithScalar(knot.getRadius(knot.getEndingVertex(halfedge)))
        .negate()
        .add(end);
    const ex = lineEnd.x;
    const ey = lineEnd.y;
    const dex = ex - currentDirection.x / 2.0;
    const dey = ey - currentDirection.y / 2.0;
    picture.path(`M ${sx} ${sy} C ${dsx} ${dsy}, ${dex} ${dey}, ${ex} ${ey}`)
        .fill('none')
        .stroke({
        color: 'rgba(200, 200, 200, 1.0)',
        width: 0.015,
        linecap: 'round',
        linejoin: 'round'
    });
}
function drawHalfedgeDown(knot, halfedge, picture) {
    const pair = knot.getPairHalfedge(halfedge);
    const previous = knot.getPreviousHalfedge(halfedge);
    const current = halfedge;
    const next = knot.getNextHalfedge(halfedge);
    const previousDirection = knot.extractDirection(previous, new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const currentDirection = knot.extractDirection(current, new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const nextDirection = knot.extractDirection(next, new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const previousNormal = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    const currentNormal = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    const nextNormal = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    if (previous === pair) {
        currentDirection.clockwiseNormal(previousNormal);
    }
    else {
        previousDirection.clockwiseNormal(previousNormal);
    }
    currentDirection.clockwiseNormal(currentNormal);
    if (next === pair) {
        currentDirection.clockwiseNormal(nextNormal);
    }
    else {
        nextDirection.clockwiseNormal(nextNormal);
    }
    const start = knot.extractLocation(knot.getStartingVertex(halfedge), new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const end = knot.extractLocation(knot.getEndingVertex(halfedge), new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]());
    const lineStart = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    const lineEnd = new _cedric_demongivert_gl_tool_math__WEBPACK_IMPORTED_MODULE_0__["Vector2f"]();
    lineStart.copy(currentNormal)
        .add(previousNormal)
        .normalize()
        .multiplyWithScalar(knot.getRadius(knot.getStartingVertex(halfedge)))
        .negate()
        .add(start);
    const sx = lineStart.x;
    const sy = lineStart.y;
    const dsx = sx + currentDirection.x / 2.0;
    const dsy = sy + currentDirection.y / 2.0;
    lineEnd.copy(currentNormal)
        .add(nextNormal)
        .normalize()
        .multiplyWithScalar(knot.getRadius(knot.getEndingVertex(halfedge)))
        .add(end);
    const ex = lineEnd.x;
    const ey = lineEnd.y;
    const dex = ex - currentDirection.x / 2.0;
    const dey = ey - currentDirection.y / 2.0;
    picture.path(`M ${sx} ${sy} C ${dsx} ${dsy}, ${dex} ${dey}, ${ex} ${ey}`)
        .fill('none')
        .stroke({
        color: 'rgba(100, 100, 100, 1.0)',
        width: 0.015,
        linecap: 'round',
        linejoin: 'round'
    });
}


/***/ }),

/***/ "./src/js/summary/Heading.ts":
/*!***********************************!*\
  !*** ./src/js/summary/Heading.ts ***!
  \***********************************/
/*! exports provided: Heading */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Heading", function() { return Heading; });
/* harmony import */ var _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cedric-demongivert/gl-tool-collection */ "./node_modules/@cedric-demongivert/gl-tool-collection/index.js");
/* harmony import */ var _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__);

class Heading {
    constructor() {
        this._children = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__["Packs"].any(8);
        this._childrenView = _cedric_demongivert_gl_tool_collection__WEBPACK_IMPORTED_MODULE_0__["View"].wrap(this._children);
        this._parent = null;
        this._content = null;
        this._identifier = null;
    }
    get identifier() {
        return this._identifier;
    }
    set identifier(identifier) {
        this._identifier = identifier;
    }
    get depth() {
        let result = 1;
        let parent = this._parent;
        while (parent != null) {
            result += 1;
            parent = parent.parent;
        }
        return result;
    }
    get parent() {
        return this._parent;
    }
    set parent(parent) {
        if (this._parent !== parent) {
            if (this._parent) {
                const oldParent = this._parent;
                this._parent = null;
                oldParent.detach(this);
            }
            this._parent = parent;
            if (this._parent) {
                this._parent.attach(this);
            }
        }
    }
    get children() {
        return this._childrenView;
    }
    get content() {
        return this._content;
    }
    set content(content) {
        this._content = content;
    }
    attach(child) {
        if (!this.has(child)) {
            this._children.push(child);
            child.parent = this;
        }
    }
    detach(child) {
        const index = this._children.indexOf(child);
        if (index >= 0) {
            this._children.delete(index);
            child.parent = null;
        }
    }
    has(child) {
        return this._children.has(child);
    }
}


/***/ }),

/***/ "./src/js/summary/depth.ts":
/*!*********************************!*\
  !*** ./src/js/summary/depth.ts ***!
  \*********************************/
/*! exports provided: depth */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "depth", function() { return depth; });
function depth(tag) {
    const name = tag.tagName;
    if (name === 'H1') {
        return 1;
    }
    else if (name === 'H2') {
        return 2;
    }
    else if (name === 'H3') {
        return 3;
    }
    else if (name === 'H4') {
        return 4;
    }
    else if (name === 'H5') {
        return 5;
    }
    else if (name === 'H6') {
        return 6;
    }
    else if (name === 'H7') {
        return 7;
    }
    else if (name === 'H8') {
        return 8;
    }
    else {
        throw new Error(`The given element ${tag} is not a valid heading element. ` +
            'Valid heading elements are H1, H2, H3, H4, H5, H6, H7 and H8.');
    }
}


/***/ }),

/***/ "./src/js/summary/extract.ts":
/*!***********************************!*\
  !*** ./src/js/summary/extract.ts ***!
  \***********************************/
/*! exports provided: extract */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extract", function() { return extract; });
/* harmony import */ var _Heading__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Heading */ "./src/js/summary/Heading.ts");
/* harmony import */ var _depth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./depth */ "./src/js/summary/depth.ts");


function extract(root) {
    const elements = root.querySelectorAll('h1,h2,h3,h4,h5,h6,h7,h8');
    let stack = [];
    for (const element of elements) {
        const heading = new _Heading__WEBPACK_IMPORTED_MODULE_0__["Heading"]();
        const titleDepth = Object(_depth__WEBPACK_IMPORTED_MODULE_1__["depth"])(element);
        heading.content = element.innerHTML;
        if (element.id)
            heading.identifier = element.id;
        while (stack.length > 0 && stack[stack.length - 1].depth >= titleDepth) {
            stack.pop();
        }
        if (stack.length > 0) {
            stack[stack.length - 1].attach(heading);
        }
        stack.push(heading);
    }
    return stack[0];
}


/***/ }),

/***/ "./src/js/summary/generate.ts":
/*!************************************!*\
  !*** ./src/js/summary/generate.ts ***!
  \************************************/
/*! exports provided: generate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return generate; });
function generate(heading) {
    const result = document.createElement('li');
    result.className = `heading heading-${heading.depth}`;
    if (heading.identifier) {
        const anchor = document.createElement("a");
        anchor.href = `#${heading.identifier}`;
        anchor.innerHTML = heading.content;
        result.append(anchor);
    }
    else {
        result.innerHTML = heading.content;
    }
    if (heading.children.size > 0) {
        const subList = document.createElement('ul');
        for (const child of heading.children) {
            subList.append(generate(child));
        }
        result.append(subList);
    }
    return result;
}


/***/ }),

/***/ "./src/js/summary/index.ts":
/*!*********************************!*\
  !*** ./src/js/summary/index.ts ***!
  \*********************************/
/*! exports provided: generate, extract, Heading */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _generate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generate */ "./src/js/summary/generate.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return _generate__WEBPACK_IMPORTED_MODULE_0__["generate"]; });

/* harmony import */ var _extract__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extract */ "./src/js/summary/extract.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extract", function() { return _extract__WEBPACK_IMPORTED_MODULE_1__["extract"]; });

/* harmony import */ var _Heading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Heading */ "./src/js/summary/Heading.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heading", function() { return _Heading__WEBPACK_IMPORTED_MODULE_2__["Heading"]; });






/***/ }),

/***/ "./src/scss/app.scss":
/*!***************************!*\
  !*** ./src/scss/app.scss ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/twig/characteristics.twig":
/*!***************************************!*\
  !*** ./src/twig/characteristics.twig ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./characteristics/luck.twig */ "./src/twig/characteristics/luck.twig");

__webpack_require__(/*! ./characteristics/control.twig */ "./src/twig/characteristics/control.twig");

__webpack_require__(/*! ./characteristics/power.twig */ "./src/twig/characteristics/power.twig");

__webpack_require__(/*! ./characteristics/constitution.twig */ "./src/twig/characteristics/constitution.twig");

__webpack_require__(/*! ./characteristics/dexterity.twig */ "./src/twig/characteristics/dexterity.twig");

__webpack_require__(/*! ./characteristics/strength.twig */ "./src/twig/characteristics/strength.twig");

__webpack_require__(/*! ./characteristics/introduction.twig */ "./src/twig/characteristics/introduction.twig");

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<div class=\"row\">\r\n  <div class=\"col\">\r\n    <a href=\"#characteristics\">\r\n      <h2 id=\"characteristics\">Caractéristiques</h2>\r\n    </a>\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:10589b2871c89e205a5ceb50705f78ddbde67677c9fb5d9d515c89f95f25b72c57517271341c2af5e96c40c9b740e6b3d1756eed7e2c0fa35e92fb5f21dcc6ba:introduction.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div><!-- /#characteristics -->\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:53a37a3dd0e2c77f59345a0e4c03dd9cbc9a7467f03dcc6304c0c01c4adf27e33dbd9288d8d1a9e53131fe7aee4a8df103fafe1fd8b3a71baa6d1c32beda604f:strength.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#strength -->\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:6aa0ad98ad812cc7f84c9c019605c55a2e72793eba73ed9c47034a87ab8f922c5641b082a32f8f1cfe0910d1afd333a66fd2069076ae8fa344bfe597a5804685:dexterity.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#dexterity -->\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:4871be6021c58fb0756f6b9ce626411cc9ef07087ef2edd14c094beabeb52cb906b6722607502b37cf8f6d8c2749a7d4da3ce3bfe65d9ca02bdbca21fa716425:constitution.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#constitution -->\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:2323dee50ebfb0a531b1b4978d1180047604096fed7bfae51896b02bf614ea03acc177636c55b88dcebac3ffae30d9472ab37894474286c486c8fc8e6502516c:power.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#power -->\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:abd937affb7c764329b3df0972c8e85caae8e476d61691b4c0f548b7b19c85ab6ec124796a66af85dd5917bcf221b61e98f87fa01170330ad3f8db6303a7ab4d:control.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#control -->\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:0697013a218037f39fb4afa4875e80864d4551506d4681bfb4ba518bdc5be85bdef77b6b3ab595a33f6f6301f2ca46a8117af62844333ae830bb86b047dd0fb8:luck.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#luck -->\r\n</div>\r\n"}],
    template = twig({"id":"$resolved:ffbe009890969dd77911a189ff9a86718137014342d8dcda9bc2ad7447988764392c62ea57df776f8748415defef656bafc0192df81394c31f19522460851907:characteristics.twig","data":[{"type":"raw","value":"<div class=\"row\">\r\n  <div class=\"col\">\r\n    <a href=\"#characteristics\">\r\n      <h2 id=\"characteristics\">Caractéristiques</h2>\r\n    </a>\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:10589b2871c89e205a5ceb50705f78ddbde67677c9fb5d9d515c89f95f25b72c57517271341c2af5e96c40c9b740e6b3d1756eed7e2c0fa35e92fb5f21dcc6ba:introduction.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div><!-- /#characteristics -->\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:53a37a3dd0e2c77f59345a0e4c03dd9cbc9a7467f03dcc6304c0c01c4adf27e33dbd9288d8d1a9e53131fe7aee4a8df103fafe1fd8b3a71baa6d1c32beda604f:strength.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#strength -->\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:6aa0ad98ad812cc7f84c9c019605c55a2e72793eba73ed9c47034a87ab8f922c5641b082a32f8f1cfe0910d1afd333a66fd2069076ae8fa344bfe597a5804685:dexterity.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#dexterity -->\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:4871be6021c58fb0756f6b9ce626411cc9ef07087ef2edd14c094beabeb52cb906b6722607502b37cf8f6d8c2749a7d4da3ce3bfe65d9ca02bdbca21fa716425:constitution.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#constitution -->\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:2323dee50ebfb0a531b1b4978d1180047604096fed7bfae51896b02bf614ea03acc177636c55b88dcebac3ffae30d9472ab37894474286c486c8fc8e6502516c:power.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#power -->\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:abd937affb7c764329b3df0972c8e85caae8e476d61691b4c0f548b7b19c85ab6ec124796a66af85dd5917bcf221b61e98f87fa01170330ad3f8db6303a7ab4d:control.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#control -->\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:0697013a218037f39fb4afa4875e80864d4551506d4681bfb4ba518bdc5be85bdef77b6b3ab595a33f6f6301f2ca46a8117af62844333ae830bb86b047dd0fb8:luck.twig"}]}},{"type":"raw","value":"\r\n  </div><!-- /#luck -->\r\n</div>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/constitution.twig":
/*!****************************************************!*\
  !*** ./src/twig/characteristics/constitution.twig ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#constitution\">\r\n  <h3 id=\"constitution\">Constitution</h3>\r\n</a>\r\n<p>\r\n  La <strong>constitution</strong> représente la résistance physique du corps,\r\n  elle mesure aussi le nombre de <strong>points de vie</strong> dont dispose un\r\n  personnage. Un bon niveau de <strong>constitution</strong> permet donc\r\n  d'encaisser plus de blessures, d'endurer des conditions environnementales\r\n  difficiles et de mieux résister à la maladie et aux poisons.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:4871be6021c58fb0756f6b9ce626411cc9ef07087ef2edd14c094beabeb52cb906b6722607502b37cf8f6d8c2749a7d4da3ce3bfe65d9ca02bdbca21fa716425:constitution.twig","data":[{"type":"raw","value":"<a href=\"#constitution\">\r\n  <h3 id=\"constitution\">Constitution</h3>\r\n</a>\r\n<p>\r\n  La <strong>constitution</strong> représente la résistance physique du corps,\r\n  elle mesure aussi le nombre de <strong>points de vie</strong> dont dispose un\r\n  personnage. Un bon niveau de <strong>constitution</strong> permet donc\r\n  d'encaisser plus de blessures, d'endurer des conditions environnementales\r\n  difficiles et de mieux résister à la maladie et aux poisons.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/control.twig":
/*!***********************************************!*\
  !*** ./src/twig/characteristics/control.twig ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#control\">\r\n  <h3 id=\"control\">Contrôle</h3>\r\n</a>\r\n<p>\r\n  Le <strong>contrôle</strong> représente la maîtrise consciente de soi et le\r\n  recul que l'on peut avoir vis-à-vis de nos sentiments, elle mesure aussi la\r\n  <strong>volonté</strong> d'un personnage. Un bon niveau de\r\n  <strong>contrôle</strong> permet de résister aux manipulations mentales, de\r\n  mitiger les afflictions psychiques et de garder son sang froid dans les\r\n  situations difficiles.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:abd937affb7c764329b3df0972c8e85caae8e476d61691b4c0f548b7b19c85ab6ec124796a66af85dd5917bcf221b61e98f87fa01170330ad3f8db6303a7ab4d:control.twig","data":[{"type":"raw","value":"<a href=\"#control\">\r\n  <h3 id=\"control\">Contrôle</h3>\r\n</a>\r\n<p>\r\n  Le <strong>contrôle</strong> représente la maîtrise consciente de soi et le\r\n  recul que l'on peut avoir vis-à-vis de nos sentiments, elle mesure aussi la\r\n  <strong>volonté</strong> d'un personnage. Un bon niveau de\r\n  <strong>contrôle</strong> permet de résister aux manipulations mentales, de\r\n  mitiger les afflictions psychiques et de garder son sang froid dans les\r\n  situations difficiles.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/dexterity.twig":
/*!*************************************************!*\
  !*** ./src/twig/characteristics/dexterity.twig ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#dexterity\">\r\n  <h3 id=\"dexterity\">Dextérité</h3>\r\n</a>\r\n<p>\r\n  La <strong>dextérité</strong> représente la précision des sens, elle mesure\r\n  aussi <strong>l'initiative</strong> d'un personnage en combat. Un bon niveau\r\n  de <strong>dextérité</strong> permet d'agir le premier en combat, de se\r\n  mouvoir sans faire de bruit, d'esquiver et de maîtriser les armes de jet et\r\n  les armes légères.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:6aa0ad98ad812cc7f84c9c019605c55a2e72793eba73ed9c47034a87ab8f922c5641b082a32f8f1cfe0910d1afd333a66fd2069076ae8fa344bfe597a5804685:dexterity.twig","data":[{"type":"raw","value":"<a href=\"#dexterity\">\r\n  <h3 id=\"dexterity\">Dextérité</h3>\r\n</a>\r\n<p>\r\n  La <strong>dextérité</strong> représente la précision des sens, elle mesure\r\n  aussi <strong>l'initiative</strong> d'un personnage en combat. Un bon niveau\r\n  de <strong>dextérité</strong> permet d'agir le premier en combat, de se\r\n  mouvoir sans faire de bruit, d'esquiver et de maîtriser les armes de jet et\r\n  les armes légères.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/introduction.twig":
/*!****************************************************!*\
  !*** ./src/twig/characteristics/introduction.twig ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<p>\r\n  Les <strong>caractéristiques</strong> dépeignent les capacités innées d'un\r\n  personnage et elles sont appréciées sur une échelle allant de 0 à 20. Chaque\r\n  caractéristique est associée à un <strong>modificateur d'instinct</strong>\r\n  appliqué aux <strong>compétences</strong> du personnage. Le\r\n  <strong>modificateur d'instinct</strong> est égal à la valeur de sa\r\n  <strong>caractéristique</strong> associée retranchée de dix points, divisée\r\n  par deux et arrondie à l'entier inférieur.\r\n</p>\r\n<p>\r\n  Un personnage doit répartir un capital de 10 points par\r\n  <strong>caractéristique</strong> plus 9 points supplémentaires. Un personnage\r\n  avec une <strong>caractéristique</strong> nulle n'est pas jouable. Jouer un\r\n  personnage avec une valeur de <strong>caractéristique</strong> inférieure à 4\r\n  points doit passer par l'approbation du maître du jeu.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:10589b2871c89e205a5ceb50705f78ddbde67677c9fb5d9d515c89f95f25b72c57517271341c2af5e96c40c9b740e6b3d1756eed7e2c0fa35e92fb5f21dcc6ba:introduction.twig","data":[{"type":"raw","value":"<p>\r\n  Les <strong>caractéristiques</strong> dépeignent les capacités innées d'un\r\n  personnage et elles sont appréciées sur une échelle allant de 0 à 20. Chaque\r\n  caractéristique est associée à un <strong>modificateur d'instinct</strong>\r\n  appliqué aux <strong>compétences</strong> du personnage. Le\r\n  <strong>modificateur d'instinct</strong> est égal à la valeur de sa\r\n  <strong>caractéristique</strong> associée retranchée de dix points, divisée\r\n  par deux et arrondie à l'entier inférieur.\r\n</p>\r\n<p>\r\n  Un personnage doit répartir un capital de 10 points par\r\n  <strong>caractéristique</strong> plus 9 points supplémentaires. Un personnage\r\n  avec une <strong>caractéristique</strong> nulle n'est pas jouable. Jouer un\r\n  personnage avec une valeur de <strong>caractéristique</strong> inférieure à 4\r\n  points doit passer par l'approbation du maître du jeu.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/luck.twig":
/*!********************************************!*\
  !*** ./src/twig/characteristics/luck.twig ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#luck\">\r\n  <h3 id=\"luck\">Chance</h3>\r\n</a>\r\n\r\n<p>\r\n  La <strong>chance</strong> représente la capacité à se créer des\r\n  opportunitées. Un bon niveau de <strong>chance</strong> permet de trouver plus\r\n  facilement des biens précieux et de savoir comment créer des situations\r\n  bénéfiques aux l'allures de deus-ex-machina.\r\n</p>\r\n\r\n<p>\r\n  A partir de 16 points de <strong>chance</strong>, un personnage obtient un\r\n  bonus situationnel de 1 point sur l'ensemble de ses compétences. En dessous de\r\n  6 points de <strong>chance</strong> le personnage subit un malus situationnel\r\n  de 1 point sur l'ensemble de ses compétences.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:0697013a218037f39fb4afa4875e80864d4551506d4681bfb4ba518bdc5be85bdef77b6b3ab595a33f6f6301f2ca46a8117af62844333ae830bb86b047dd0fb8:luck.twig","data":[{"type":"raw","value":"<a href=\"#luck\">\r\n  <h3 id=\"luck\">Chance</h3>\r\n</a>\r\n\r\n<p>\r\n  La <strong>chance</strong> représente la capacité à se créer des\r\n  opportunitées. Un bon niveau de <strong>chance</strong> permet de trouver plus\r\n  facilement des biens précieux et de savoir comment créer des situations\r\n  bénéfiques aux l'allures de deus-ex-machina.\r\n</p>\r\n\r\n<p>\r\n  A partir de 16 points de <strong>chance</strong>, un personnage obtient un\r\n  bonus situationnel de 1 point sur l'ensemble de ses compétences. En dessous de\r\n  6 points de <strong>chance</strong> le personnage subit un malus situationnel\r\n  de 1 point sur l'ensemble de ses compétences.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/power.twig":
/*!*********************************************!*\
  !*** ./src/twig/characteristics/power.twig ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#power\">\r\n  <h3 id=\"power\">Pouvoir</h3>\r\n</a>\r\n<p>\r\n  Le <strong>pouvoir</strong> représente la capacité à plier la réalité à\r\n  sa volontée en usant de prouesses mentales et d'une bonne maîtrise technique,\r\n  il mesure aussi la <strong>conductivité magique</strong> d'un personnage. Un\r\n  bon niveau de <strong>pouvoir</strong> permet de résiter aux effets magiques,\r\n  de lancer des sorts plus puissant et de mieux ressentir la magie.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:2323dee50ebfb0a531b1b4978d1180047604096fed7bfae51896b02bf614ea03acc177636c55b88dcebac3ffae30d9472ab37894474286c486c8fc8e6502516c:power.twig","data":[{"type":"raw","value":"<a href=\"#power\">\r\n  <h3 id=\"power\">Pouvoir</h3>\r\n</a>\r\n<p>\r\n  Le <strong>pouvoir</strong> représente la capacité à plier la réalité à\r\n  sa volontée en usant de prouesses mentales et d'une bonne maîtrise technique,\r\n  il mesure aussi la <strong>conductivité magique</strong> d'un personnage. Un\r\n  bon niveau de <strong>pouvoir</strong> permet de résiter aux effets magiques,\r\n  de lancer des sorts plus puissant et de mieux ressentir la magie.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/characteristics/strength.twig":
/*!************************************************!*\
  !*** ./src/twig/characteristics/strength.twig ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#strength\">\r\n  <h3 id=\"strength\">Force</h3>\r\n</a>\r\n<p>\r\n  La <strong>force</strong> représente la capacité à plier le réel à sa volonté\r\n  par l'usage de moyens physiques, elle mesure aussi la <strong>capacité\r\n  de charge</strong>. Un bon niveau de <strong>force</strong> permet d'équiper\r\n  plus de matériel, de maîtriser les armures et armes lourdes et de faire plus\r\n  de dégâts physique.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:53a37a3dd0e2c77f59345a0e4c03dd9cbc9a7467f03dcc6304c0c01c4adf27e33dbd9288d8d1a9e53131fe7aee4a8df103fafe1fd8b3a71baa6d1c32beda604f:strength.twig","data":[{"type":"raw","value":"<a href=\"#strength\">\r\n  <h3 id=\"strength\">Force</h3>\r\n</a>\r\n<p>\r\n  La <strong>force</strong> représente la capacité à plier le réel à sa volonté\r\n  par l'usage de moyens physiques, elle mesure aussi la <strong>capacité\r\n  de charge</strong>. Un bon niveau de <strong>force</strong> permet d'équiper\r\n  plus de matériel, de maîtriser les armures et armes lourdes et de faire plus\r\n  de dégâts physique.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/content.twig":
/*!*******************************!*\
  !*** ./src/twig/content.twig ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./masteries.twig */ "./src/twig/masteries.twig");

__webpack_require__(/*! ./core-rules.twig */ "./src/twig/core-rules.twig");

__webpack_require__(/*! ./characteristics.twig */ "./src/twig/characteristics.twig");

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<div class=\"container\">\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <h1>Table des lois</h1>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#summary\">\r\n        <h2 id=\"summary\">Sommaire</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\" >\r\n      <ul id=\"summary-content\" class=\"matter\"></ul>\r\n    </div>\r\n  </div>\r\n  "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:ffbe009890969dd77911a189ff9a86718137014342d8dcda9bc2ad7447988764392c62ea57df776f8748415defef656bafc0192df81394c31f19522460851907:characteristics.twig"}]}},{"type":"raw","value":"\r\n  "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:0e3edc2056a83f83aef2c6a71a9e8efe6f437f4b70e9666e448be5c2649e8e79f5d499ad468bef8fac0391e9a921edadf4ba5dc81eb75c26503f80f923951bbe:core-rules.twig"}]}},{"type":"raw","value":"\r\n  "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:290496b7e8a3c38cb77d3d5126c1f0df8d7fbdc0bfe13ae23c4169e7915a6801e173a4f28dd8c7fc734e1cde0896f60749fb883d2c02f8933f25286952b105d7:masteries.twig"}]}},{"type":"raw","value":"\r\n\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#feats\">\r\n        <h2 id=\"feats\">Atouts</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#weapons\">\r\n        <h2 id=\"armors\">Armes</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Combat à main nues</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:200px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Poing</td>\r\n            <td>1D/x2</td>\r\n            <td>Contondant</td>\r\n            <td></td>\r\n            <td></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Gantelet clouté</td>\r\n            <td>3D/x2</td>\r\n            <td>Contondant</td>\r\n            <td></td>\r\n            <td></td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Armes légères</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:100px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n            <tr>\r\n              <td>Dague</td>\r\n              <td>4D/x2</td>\r\n              <td>Tranchant</td>\r\n              <td></td>\r\n            </tr>\r\n            <tr>\r\n              <td>Epée courte</td>\r\n              <td>7D/x2</td>\r\n              <td>Tranchant</td>\r\n              <td>-2 FOR</td>\r\n              <td></td>\r\n            </tr>\r\n            <tr>\r\n              <td>Marteau</td>\r\n              <td>4D + 1D!/x2</td>\r\n              <td>Contondant</td>\r\n              <td>-2 FOR</td>\r\n              <td>Dégâts bruts annulés si parré avec un bouclier</td>\r\n            </tr>\r\n            <tr>\r\n              <td>Hachette</td>\r\n              <td>5D + 3DA/x2</td>\r\n              <td>Tranchant</td>\r\n              <td>-2 FOR</td>\r\n              <td></td>\r\n            </tr>\r\n            <tr>\r\n              <td>Morgenstern</td>\r\n              <td>7D/x2</td>\r\n              <td>Contondant + Perforant</td>\r\n              <td>-2 FOR</td>\r\n              <td></td>\r\n            </tr>\r\n        </tbody>\r\n      </table>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Armes lourdes</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:100px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Epée longue</td>\r\n            <td>10D/x3</td>\r\n            <td>Tranchant</td>\r\n            <td>-4 FOR</td>\r\n            <td></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Espadon</td>\r\n            <td>11D/x3</td>\r\n            <td>Tranchant</td>\r\n            <td>-5 FOR</td>\r\n            <td></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Marteau de guerre</td>\r\n            <td>7D + 3D!/x3</td>\r\n            <td>Contondant</td>\r\n            <td>-4 FOR</td>\r\n            <td>Dégâts bruts divisés par deux si parré avec un bouclier</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Lance</td>\r\n            <td>7D + 3D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-3 FOR; -1 DEX</td>\r\n            <td>Allonge doublée</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Hache d'arme</td>\r\n            <td>7D + 4DA/x2</td>\r\n            <td>Tranchant</td>\r\n            <td>-4 FOR</td>\r\n            <td></td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Projectiles</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:100px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Arbalète de poing</td>\r\n            <td>3D + 3D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-1 FOR</td>\r\n            <td>0.5 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arbalète légère</td>\r\n            <td>7D + 3D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-2 FOR</td>\r\n            <td>0.5 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arbalète lourde</td>\r\n            <td>7D + 7D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-5 FOR</td>\r\n            <td>0.5 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arc court</td>\r\n            <td>7D/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-2 FOR</td>\r\n            <td>1 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arc long</td>\r\n            <td>10D/x3</td>\r\n            <td>Perforant</td>\r\n            <td>-4 FOR</td>\r\n            <td>1 Tir / Round</td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#armors\">\r\n        <h2 id=\"armors\">Armures</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th style=\"width:200px\">Armure</th>\r\n            <th style=\"width:100px\">Prix</th>\r\n            <th style=\"width:100px\">Points</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Armure matelassée</td>\r\n            <td>10.000c</td>\r\n            <td>+1</td>\r\n            <td>-1 DEX</td>\r\n            <td>\r\n              Endurance réduite dans les environnements chauds. <br/>\r\n              Endurance améliorée dans les environnements froids.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de cuir (souple)</td>\r\n            <td>20.000c</td>\r\n            <td>+1</td>\r\n            <td></td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de cuir (rigide)</td>\r\n            <td>40.000c</td>\r\n            <td>+2</td>\r\n            <td>-1 DEX</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Dégâts des flèches réduit de 1 point pour un minimum de 0.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de cuir (cloutée)</td>\r\n            <td>50.000c</td>\r\n            <td>+2</td>\r\n            <td>-1 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Dégâts des flèches réduit de 1 point pour un minimum de 0.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Chemise de mailles</td>\r\n            <td>100.000c</td>\r\n            <td>+4</td>\r\n            <td>-2 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Ne peut pas être portée avec une armure intermédiaire. <br/>\r\n              Peut être portée par dessus une autre armure légère. <br/>\r\n              Ne protège que le torse et les bras. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <br/>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th style=\"width:200px\">Armure</th>\r\n            <th style=\"width:100px\">Prix</th>\r\n            <th style=\"width:100px\">Points</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Armure de peau</td>\r\n            <td>40.000c</td>\r\n            <td>+2</td>\r\n            <td>-1 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements chaud. <br/>\r\n              Endurance augmentée dans les environnements froids. <br/>\r\n              Dégâts des flèches réduit de 1 point pour un minimum de 0.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Cotte de mailles</td>\r\n            <td>150.000c</td>\r\n            <td>+4</td>\r\n            <td>-1 DEX; -2 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Ne peut être porté avec la chemise de maille. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure d'écailles</td>\r\n            <td>200.000c</td>\r\n            <td>+6</td>\r\n            <td>-2 DEX; -4 FOR</td>\r\n            <td>\r\n              Dégâts des flèches transformés en dégâts contondants et réduit\r\n              de moitié. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Brigandine</td>\r\n            <td>200.000c</td>\r\n            <td>+6</td>\r\n            <td>-3 DEX; -3 FOR</td>\r\n            <td>\r\n              Dégâts des flèches transformés en dégâts contondants et réduit\r\n              de moitié. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Cuirasse</td>\r\n            <td>400.000c</td>\r\n            <td>+8</td>\r\n            <td>-2 DEX; -4 FOR</td>\r\n            <td>\r\n              Ne protège que le torse. <br/>\r\n              Peut être portée avec la cotte de mailles. <br />\r\n              Ne peut pas être portée avec une autre armure lourde. <br/>\r\n              Dégâts des flèches convertis en dégâts contondant réduits de\r\n              moitié.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <br/>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th style=\"width:200px\">Armure</th>\r\n            <th style=\"width:100px\">Prix</th>\r\n            <th style=\"width:100px\">Points</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Armure de plates</td>\r\n            <td>400.000c</td>\r\n            <td>+8</td>\r\n            <td>-5 DEX; -5 FOR</td>\r\n            <td>\r\n              Dégâts des flèches convertis en dégâts contondant réduits de\r\n              moitié.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de plaques</td>\r\n            <td>1.000.000c</td>\r\n            <td>+10</td>\r\n            <td>-5 DEX; -5 FOR</td>\r\n            <td>\r\n              Dégâts des flèches convertis en dégâts contondant réduits au\r\n              quart.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Harnois</td>\r\n            <td>1.500.000c</td>\r\n            <td>+12</td>\r\n            <td>-4 DEX; -5 FOR</td>\r\n            <td>\r\n              Dégâts des flèches convertis en dégâts contondant réduits au\r\n              quart.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n  </div>\r\n  <div id=\"tree\"></div>\r\n</div><!-- /.container -->\r\n"}],
    template = twig({"id":"$resolved:fd7a252c39c9ecb9f46a90a95f31eb3c337d8524e63c609eb63fef2b9aeda8deb6864fd005475397c21a5e09684b3add60532820c297b2b5038e053dbdb4e24b:content.twig","data":[{"type":"raw","value":"<div class=\"container\">\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <h1>Table des lois</h1>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#summary\">\r\n        <h2 id=\"summary\">Sommaire</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\" >\r\n      <ul id=\"summary-content\" class=\"matter\"></ul>\r\n    </div>\r\n  </div>\r\n  "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:ffbe009890969dd77911a189ff9a86718137014342d8dcda9bc2ad7447988764392c62ea57df776f8748415defef656bafc0192df81394c31f19522460851907:characteristics.twig"}]}},{"type":"raw","value":"\r\n  "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:0e3edc2056a83f83aef2c6a71a9e8efe6f437f4b70e9666e448be5c2649e8e79f5d499ad468bef8fac0391e9a921edadf4ba5dc81eb75c26503f80f923951bbe:core-rules.twig"}]}},{"type":"raw","value":"\r\n  "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:290496b7e8a3c38cb77d3d5126c1f0df8d7fbdc0bfe13ae23c4169e7915a6801e173a4f28dd8c7fc734e1cde0896f60749fb883d2c02f8933f25286952b105d7:masteries.twig"}]}},{"type":"raw","value":"\r\n\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#feats\">\r\n        <h2 id=\"feats\">Atouts</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#weapons\">\r\n        <h2 id=\"armors\">Armes</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Combat à main nues</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:200px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Poing</td>\r\n            <td>1D/x2</td>\r\n            <td>Contondant</td>\r\n            <td></td>\r\n            <td></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Gantelet clouté</td>\r\n            <td>3D/x2</td>\r\n            <td>Contondant</td>\r\n            <td></td>\r\n            <td></td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Armes légères</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:100px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n            <tr>\r\n              <td>Dague</td>\r\n              <td>4D/x2</td>\r\n              <td>Tranchant</td>\r\n              <td></td>\r\n            </tr>\r\n            <tr>\r\n              <td>Epée courte</td>\r\n              <td>7D/x2</td>\r\n              <td>Tranchant</td>\r\n              <td>-2 FOR</td>\r\n              <td></td>\r\n            </tr>\r\n            <tr>\r\n              <td>Marteau</td>\r\n              <td>4D + 1D!/x2</td>\r\n              <td>Contondant</td>\r\n              <td>-2 FOR</td>\r\n              <td>Dégâts bruts annulés si parré avec un bouclier</td>\r\n            </tr>\r\n            <tr>\r\n              <td>Hachette</td>\r\n              <td>5D + 3DA/x2</td>\r\n              <td>Tranchant</td>\r\n              <td>-2 FOR</td>\r\n              <td></td>\r\n            </tr>\r\n            <tr>\r\n              <td>Morgenstern</td>\r\n              <td>7D/x2</td>\r\n              <td>Contondant + Perforant</td>\r\n              <td>-2 FOR</td>\r\n              <td></td>\r\n            </tr>\r\n        </tbody>\r\n      </table>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Armes lourdes</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:100px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Epée longue</td>\r\n            <td>10D/x3</td>\r\n            <td>Tranchant</td>\r\n            <td>-4 FOR</td>\r\n            <td></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Espadon</td>\r\n            <td>11D/x3</td>\r\n            <td>Tranchant</td>\r\n            <td>-5 FOR</td>\r\n            <td></td>\r\n          </tr>\r\n          <tr>\r\n            <td>Marteau de guerre</td>\r\n            <td>7D + 3D!/x3</td>\r\n            <td>Contondant</td>\r\n            <td>-4 FOR</td>\r\n            <td>Dégâts bruts divisés par deux si parré avec un bouclier</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Lance</td>\r\n            <td>7D + 3D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-3 FOR; -1 DEX</td>\r\n            <td>Allonge doublée</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Hache d'arme</td>\r\n            <td>7D + 4DA/x2</td>\r\n            <td>Tranchant</td>\r\n            <td>-4 FOR</td>\r\n            <td></td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th colspan=\"5\">Projectiles</th>\r\n          </tr>\r\n          <tr>\r\n            <th style=\"width:200px\">Arme</th>\r\n            <th style=\"width:200px\">Dégâts</th>\r\n            <th style=\"width:100px\">Type</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Arbalète de poing</td>\r\n            <td>3D + 3D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-1 FOR</td>\r\n            <td>0.5 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arbalète légère</td>\r\n            <td>7D + 3D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-2 FOR</td>\r\n            <td>0.5 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arbalète lourde</td>\r\n            <td>7D + 7D!/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-5 FOR</td>\r\n            <td>0.5 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arc court</td>\r\n            <td>7D/x2</td>\r\n            <td>Perforant</td>\r\n            <td>-2 FOR</td>\r\n            <td>1 Tir / Round</td>\r\n          </tr>\r\n          <tr>\r\n            <td>Arc long</td>\r\n            <td>10D/x3</td>\r\n            <td>Perforant</td>\r\n            <td>-4 FOR</td>\r\n            <td>1 Tir / Round</td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <a href=\"#armors\">\r\n        <h2 id=\"armors\">Armures</h2>\r\n      </a>\r\n    </div>\r\n  </div>\r\n  <div class=\"row\">\r\n    <div class=\"col\">\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th style=\"width:200px\">Armure</th>\r\n            <th style=\"width:100px\">Prix</th>\r\n            <th style=\"width:100px\">Points</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Armure matelassée</td>\r\n            <td>10.000c</td>\r\n            <td>+1</td>\r\n            <td>-1 DEX</td>\r\n            <td>\r\n              Endurance réduite dans les environnements chauds. <br/>\r\n              Endurance améliorée dans les environnements froids.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de cuir (souple)</td>\r\n            <td>20.000c</td>\r\n            <td>+1</td>\r\n            <td></td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de cuir (rigide)</td>\r\n            <td>40.000c</td>\r\n            <td>+2</td>\r\n            <td>-1 DEX</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Dégâts des flèches réduit de 1 point pour un minimum de 0.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de cuir (cloutée)</td>\r\n            <td>50.000c</td>\r\n            <td>+2</td>\r\n            <td>-1 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Dégâts des flèches réduit de 1 point pour un minimum de 0.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Chemise de mailles</td>\r\n            <td>100.000c</td>\r\n            <td>+4</td>\r\n            <td>-2 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Ne peut pas être portée avec une armure intermédiaire. <br/>\r\n              Peut être portée par dessus une autre armure légère. <br/>\r\n              Ne protège que le torse et les bras. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <br/>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th style=\"width:200px\">Armure</th>\r\n            <th style=\"width:100px\">Prix</th>\r\n            <th style=\"width:100px\">Points</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Armure de peau</td>\r\n            <td>40.000c</td>\r\n            <td>+2</td>\r\n            <td>-1 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements chaud. <br/>\r\n              Endurance augmentée dans les environnements froids. <br/>\r\n              Dégâts des flèches réduit de 1 point pour un minimum de 0.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Cotte de mailles</td>\r\n            <td>150.000c</td>\r\n            <td>+4</td>\r\n            <td>-1 DEX; -2 FOR</td>\r\n            <td>\r\n              Endurance réduite dans les environnements froids. <br/>\r\n              Ne peut être porté avec la chemise de maille. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure d'écailles</td>\r\n            <td>200.000c</td>\r\n            <td>+6</td>\r\n            <td>-2 DEX; -4 FOR</td>\r\n            <td>\r\n              Dégâts des flèches transformés en dégâts contondants et réduit\r\n              de moitié. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Brigandine</td>\r\n            <td>200.000c</td>\r\n            <td>+6</td>\r\n            <td>-3 DEX; -3 FOR</td>\r\n            <td>\r\n              Dégâts des flèches transformés en dégâts contondants et réduit\r\n              de moitié. <br/>\r\n              Dégâts tranchants, non-lourds, réduit de moitié.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Cuirasse</td>\r\n            <td>400.000c</td>\r\n            <td>+8</td>\r\n            <td>-2 DEX; -4 FOR</td>\r\n            <td>\r\n              Ne protège que le torse. <br/>\r\n              Peut être portée avec la cotte de mailles. <br />\r\n              Ne peut pas être portée avec une autre armure lourde. <br/>\r\n              Dégâts des flèches convertis en dégâts contondant réduits de\r\n              moitié.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <br/>\r\n      <table class=\"table\">\r\n        <thead>\r\n          <tr>\r\n            <th style=\"width:200px\">Armure</th>\r\n            <th style=\"width:100px\">Prix</th>\r\n            <th style=\"width:100px\">Points</th>\r\n            <th style=\"width:150px\">Modificateur(s)</th>\r\n            <th>Effets</th>\r\n          </tr>\r\n        </thead>\r\n        <tbody>\r\n          <tr>\r\n            <td>Armure de plates</td>\r\n            <td>400.000c</td>\r\n            <td>+8</td>\r\n            <td>-5 DEX; -5 FOR</td>\r\n            <td>\r\n              Dégâts des flèches convertis en dégâts contondant réduits de\r\n              moitié.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Armure de plaques</td>\r\n            <td>1.000.000c</td>\r\n            <td>+10</td>\r\n            <td>-5 DEX; -5 FOR</td>\r\n            <td>\r\n              Dégâts des flèches convertis en dégâts contondant réduits au\r\n              quart.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n          <tr>\r\n            <td>Harnois</td>\r\n            <td>1.500.000c</td>\r\n            <td>+12</td>\r\n            <td>-4 DEX; -5 FOR</td>\r\n            <td>\r\n              Dégâts des flèches convertis en dégâts contondant réduits au\r\n              quart.<br />\r\n              Les dégâts tranchant, non lourds, son nullifiés.\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n  </div>\r\n  <div id=\"tree\"></div>\r\n</div><!-- /.container -->\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/core-rules.twig":
/*!**********************************!*\
  !*** ./src/twig/core-rules.twig ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./core-rules/reroll.twig */ "./src/twig/core-rules/reroll.twig");

__webpack_require__(/*! ./core-rules/situational-dice.twig */ "./src/twig/core-rules/situational-dice.twig");

__webpack_require__(/*! ./core-rules/critical-hit.twig */ "./src/twig/core-rules/critical-hit.twig");

__webpack_require__(/*! ./core-rules/self-resolution.twig */ "./src/twig/core-rules/self-resolution.twig");

__webpack_require__(/*! ./core-rules/adversial-test.twig */ "./src/twig/core-rules/adversial-test.twig");

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<div class=\"row\">\r\n  <div class=\"col\">\r\n    <a href=\"#core-rules\">\r\n      <h2 id=\"core-rules\">Règles principales</h2>\r\n    </a>\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:eb3cf6d6584ccb580f7bf03bbf7c5aa3649d1f889f70e9680dd3c8bd50305769bc625c98d19919389500b6fc5133c28d67ba1e86dae1a6707a36e630353b6e0d:adversial-test.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div><!-- /.adversial-test -->\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:d78bb9600889261ed38c8acdb8386cf6f0c15c6e9934669cba2da0c91a6cb6b6b5550ad419cdbbd336d5dd79b081a1d7d923722dd97d38fc0cf338ffe9dfa0a3:self-resolution.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:688870029bd97a8a6312ad7b072755b99e93969cd8c328f61616143ee134bf52d097f96bcb549a3012f4e8773b0194b8d86e3db1e73a951378e3c164ea0f3fd4:critical-hit.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:d9e20bea94ff20510906ecd423395bc1cf1693cb3d0bf8bf004c375c653805cfd35db958f7e204fb77b1c73d6c30ce3c98e48889841e71d4d173276844077a91:situational-dice.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:fb224ebcb70ef72f8cf29adab6cb6a38a38164ac05d7f0cc31e98c4416ab644dc286db3875d5a1e529a2e6204e78380fa3e8cc11539b395e468b4bb53b4d582c:reroll.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n"}],
    template = twig({"id":"$resolved:0e3edc2056a83f83aef2c6a71a9e8efe6f437f4b70e9666e448be5c2649e8e79f5d499ad468bef8fac0391e9a921edadf4ba5dc81eb75c26503f80f923951bbe:core-rules.twig","data":[{"type":"raw","value":"<div class=\"row\">\r\n  <div class=\"col\">\r\n    <a href=\"#core-rules\">\r\n      <h2 id=\"core-rules\">Règles principales</h2>\r\n    </a>\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:eb3cf6d6584ccb580f7bf03bbf7c5aa3649d1f889f70e9680dd3c8bd50305769bc625c98d19919389500b6fc5133c28d67ba1e86dae1a6707a36e630353b6e0d:adversial-test.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div><!-- /.adversial-test -->\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:d78bb9600889261ed38c8acdb8386cf6f0c15c6e9934669cba2da0c91a6cb6b6b5550ad419cdbbd336d5dd79b081a1d7d923722dd97d38fc0cf338ffe9dfa0a3:self-resolution.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:688870029bd97a8a6312ad7b072755b99e93969cd8c328f61616143ee134bf52d097f96bcb549a3012f4e8773b0194b8d86e3db1e73a951378e3c164ea0f3fd4:critical-hit.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:d9e20bea94ff20510906ecd423395bc1cf1693cb3d0bf8bf004c375c653805cfd35db958f7e204fb77b1c73d6c30ce3c98e48889841e71d4d173276844077a91:situational-dice.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:fb224ebcb70ef72f8cf29adab6cb6a38a38164ac05d7f0cc31e98c4416ab644dc286db3875d5a1e529a2e6204e78380fa3e8cc11539b395e468b4bb53b4d582c:reroll.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/core-rules/adversial-test.twig":
/*!*************************************************!*\
  !*** ./src/twig/core-rules/adversial-test.twig ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#adversial-test\">\r\n  <h3 id=\"adversial-test\">Résolution par opposition</h3>\r\n</a>\r\n\r\n<p>\r\n  La <strong>résolution par opposition</strong> décide de l'issue d'une\r\n  confrontation entre deux éléments du récit. C'est le test type pour résoudre\r\n  le succès des attaques d'un épéiste, la résistence d'une serrure à une\r\n  tentative de crochetage ou pour décider de la réaction d'un individu sujet à\r\n  une tentative de persuasion.\r\n</p>\r\n\r\n<p>\r\n  Le personnage ou l'objet qui lance les dés est dit <strong>acteur</strong> de\r\n  la résolution et c'est de son point de vue que les chances de succès sont\r\n  calculées. L'<strong>opposant</strong> est alors le personnage ou l'objet qui\r\n  subit le test et il ne peut que mitiger les chances de succès de\r\n  l'<strong>acteur</strong>. Un <strong>personnage joueur</strong> est toujours\r\n  <strong>acteur</strong> de la résolution lorsqu'il se confronte à un élément\r\n  du récit. Dans le cas où deux joueurs se confrontent,\r\n  l'<strong>acteur</strong> est décidé d'un commun accord ou à pile ou face.\r\n  Finalement, si deux éléments du récit intéragissent entre-eux, c'est au maître\r\n  du jeu de répartir les rôles.\r\n</p>\r\n\r\n<p>\r\n  Une <strong>résolution par opposition</strong> compare une compétence de\r\n  l'<strong>acteur</strong> appelée <strong>compétence offensive</strong> à une\r\n  compétence de l'<strong>opposant</strong> dite compétence\r\n  <strong>défensive</strong>. Pour que l'issue du test soit favorable pour\r\n  l'<strong>acteur</strong> celui-ci doit obtenir un score inférieur ou égal à\r\n  son <strong>seuil de succès</strong> sur un dé 100. Le\r\n  <strong>seuil de succès</strong> est la différence entre la\r\n  <strong>compétence offensive</strong> et la\r\n  <strong>compétence défensive</strong> multipliée par 5 et ajoutée à une\r\n  constante de 50. Par exemple un <strong>personnage joueur</strong> avec une\r\n  compétence de 10 en discrétion tentant de se faire discret en escaladant une\r\n  muraille surveillée par un garde ayant une compétence de 12 en perception aura\r\n  un <strong>seuil de succès</strong> de 40%. Et ce sera toujours au\r\n  <strong>personnage joueur</strong> de résoudre le test.\r\n</p>\r\n\r\n<table class=\"table-1d\">\r\n  <tbody>\r\n    <tr>\r\n      <td style=\"width:35px\">  5<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\">  5<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 10<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 15<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 20<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 25<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 30<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 35<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 40<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 45<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 50<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 55<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 60<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 65<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 70<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 75<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 80<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 85<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 90<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 95<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 95<span class=\"percent\">%</span> </td>\r\n    </tr>\r\n    <tr>\r\n      <th> -∞ </th>\r\n      <th> -9 </th>\r\n      <th> -8 </th>\r\n      <th> -7 </th>\r\n      <th> -6 </th>\r\n      <th> -5 </th>\r\n      <th> -4 </th>\r\n      <th> -3 </th>\r\n      <th> -2 </th>\r\n      <th> -1 </th>\r\n      <th>  0 </th>\r\n      <th> +1 </th>\r\n      <th> +2 </th>\r\n      <th> +3 </th>\r\n      <th> +4 </th>\r\n      <th> +5 </th>\r\n      <th> +6 </th>\r\n      <th> +7 </th>\r\n      <th> +8 </th>\r\n      <th> +9 </th>\r\n      <th> +∞ </th>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],
    template = twig({"id":"$resolved:eb3cf6d6584ccb580f7bf03bbf7c5aa3649d1f889f70e9680dd3c8bd50305769bc625c98d19919389500b6fc5133c28d67ba1e86dae1a6707a36e630353b6e0d:adversial-test.twig","data":[{"type":"raw","value":"<a href=\"#adversial-test\">\r\n  <h3 id=\"adversial-test\">Résolution par opposition</h3>\r\n</a>\r\n\r\n<p>\r\n  La <strong>résolution par opposition</strong> décide de l'issue d'une\r\n  confrontation entre deux éléments du récit. C'est le test type pour résoudre\r\n  le succès des attaques d'un épéiste, la résistence d'une serrure à une\r\n  tentative de crochetage ou pour décider de la réaction d'un individu sujet à\r\n  une tentative de persuasion.\r\n</p>\r\n\r\n<p>\r\n  Le personnage ou l'objet qui lance les dés est dit <strong>acteur</strong> de\r\n  la résolution et c'est de son point de vue que les chances de succès sont\r\n  calculées. L'<strong>opposant</strong> est alors le personnage ou l'objet qui\r\n  subit le test et il ne peut que mitiger les chances de succès de\r\n  l'<strong>acteur</strong>. Un <strong>personnage joueur</strong> est toujours\r\n  <strong>acteur</strong> de la résolution lorsqu'il se confronte à un élément\r\n  du récit. Dans le cas où deux joueurs se confrontent,\r\n  l'<strong>acteur</strong> est décidé d'un commun accord ou à pile ou face.\r\n  Finalement, si deux éléments du récit intéragissent entre-eux, c'est au maître\r\n  du jeu de répartir les rôles.\r\n</p>\r\n\r\n<p>\r\n  Une <strong>résolution par opposition</strong> compare une compétence de\r\n  l'<strong>acteur</strong> appelée <strong>compétence offensive</strong> à une\r\n  compétence de l'<strong>opposant</strong> dite compétence\r\n  <strong>défensive</strong>. Pour que l'issue du test soit favorable pour\r\n  l'<strong>acteur</strong> celui-ci doit obtenir un score inférieur ou égal à\r\n  son <strong>seuil de succès</strong> sur un dé 100. Le\r\n  <strong>seuil de succès</strong> est la différence entre la\r\n  <strong>compétence offensive</strong> et la\r\n  <strong>compétence défensive</strong> multipliée par 5 et ajoutée à une\r\n  constante de 50. Par exemple un <strong>personnage joueur</strong> avec une\r\n  compétence de 10 en discrétion tentant de se faire discret en escaladant une\r\n  muraille surveillée par un garde ayant une compétence de 12 en perception aura\r\n  un <strong>seuil de succès</strong> de 40%. Et ce sera toujours au\r\n  <strong>personnage joueur</strong> de résoudre le test.\r\n</p>\r\n\r\n<table class=\"table-1d\">\r\n  <tbody>\r\n    <tr>\r\n      <td style=\"width:35px\">  5<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\">  5<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 10<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 15<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 20<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 25<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 30<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 35<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 40<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 45<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 50<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 55<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 60<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 65<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 70<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 75<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 80<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 85<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 90<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 95<span class=\"percent\">%</span> </td>\r\n      <td style=\"width:35px\"> 95<span class=\"percent\">%</span> </td>\r\n    </tr>\r\n    <tr>\r\n      <th> -∞ </th>\r\n      <th> -9 </th>\r\n      <th> -8 </th>\r\n      <th> -7 </th>\r\n      <th> -6 </th>\r\n      <th> -5 </th>\r\n      <th> -4 </th>\r\n      <th> -3 </th>\r\n      <th> -2 </th>\r\n      <th> -1 </th>\r\n      <th>  0 </th>\r\n      <th> +1 </th>\r\n      <th> +2 </th>\r\n      <th> +3 </th>\r\n      <th> +4 </th>\r\n      <th> +5 </th>\r\n      <th> +6 </th>\r\n      <th> +7 </th>\r\n      <th> +8 </th>\r\n      <th> +9 </th>\r\n      <th> +∞ </th>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/core-rules/critical-hit.twig":
/*!***********************************************!*\
  !*** ./src/twig/core-rules/critical-hit.twig ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#critical-hit\">\r\n  <h3 id=\"critical-hit\">Critiques</h3>\r\n</a>\r\n\r\n<p>\r\n  Lors d'un test, un score supérieur à 95% est un <strong>échec\r\n  critique</strong> aux répercussions désastreuses. À l'inverse, un score\r\n  inférieur ou égal à 5% est un <strong>succès critique</strong> aux\r\n  conséquences bénéfiques. Les <strong>résultats critiques</strong> priment sur\r\n  les chances de succès réelles d'un personnage.\r\n</p>\r\n\r\n<p>\r\n  Les conséquences d'un <strong>résultat critique</strong> sont déterminées par\r\n  le <strong>maître du jeu</strong> et peuvent avoir lieu immédiatement comme\r\n  dans un avenir proche. Certaines règles supplémentaires peuvent s'appliquer.\r\n  En combat, un <strong>succès critique</strong> permet de toucher\r\n  systématiquement tout en doublant les dégâts. Un <strong>échec\r\n  critique</strong> cependant provoque une <strong>attaque\r\n  d'opportunité</strong> automatique et gratuite de la part de l'adversaire.\r\n  Les conséquences d'un critique lors d'un test\r\n  d'<strong>auto-résolution</strong> sont laissés à la discrétion du\r\n  <strong>maître du jeu</strong>.\r\n</p>\r\n\r\n<p>\r\n  Lors d'un <strong>succès critique</strong> il est toujours possible de\r\n  défier le destin : en échange des conséquences à venir, l'acteur du test peut\r\n  relancer le dé pour tenter de faire un score inférieur ou égal à 10%. Si le\r\n  second test est passé, le groupe se voit alors attribué un <strong>point de\r\n  destin</strong> pouvant être échangé contre un succès critique automatique de\r\n  n'importe quel test à venir.\r\n</p>\r\n\r\n<p>\r\n  Lors d'un <strong>échec critique</strong>, le <strong>maître du jeu</strong>\r\n  peut toujours invoquer la fatalité : en échange des conséquences à venir,\r\n  l'acteur doit relancer le dé pour tenter de faire un score inférieur ou égal\r\n  à 90%, dans le cas contraire, un <strong>point de fatalité</strong> est\r\n  attribué au groupe. Le point peut être alors échangé par le\r\n  <strong>maître du jeu</strong> contre un échec critique automatique de\r\n  n'importe quel test à venir.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:688870029bd97a8a6312ad7b072755b99e93969cd8c328f61616143ee134bf52d097f96bcb549a3012f4e8773b0194b8d86e3db1e73a951378e3c164ea0f3fd4:critical-hit.twig","data":[{"type":"raw","value":"<a href=\"#critical-hit\">\r\n  <h3 id=\"critical-hit\">Critiques</h3>\r\n</a>\r\n\r\n<p>\r\n  Lors d'un test, un score supérieur à 95% est un <strong>échec\r\n  critique</strong> aux répercussions désastreuses. À l'inverse, un score\r\n  inférieur ou égal à 5% est un <strong>succès critique</strong> aux\r\n  conséquences bénéfiques. Les <strong>résultats critiques</strong> priment sur\r\n  les chances de succès réelles d'un personnage.\r\n</p>\r\n\r\n<p>\r\n  Les conséquences d'un <strong>résultat critique</strong> sont déterminées par\r\n  le <strong>maître du jeu</strong> et peuvent avoir lieu immédiatement comme\r\n  dans un avenir proche. Certaines règles supplémentaires peuvent s'appliquer.\r\n  En combat, un <strong>succès critique</strong> permet de toucher\r\n  systématiquement tout en doublant les dégâts. Un <strong>échec\r\n  critique</strong> cependant provoque une <strong>attaque\r\n  d'opportunité</strong> automatique et gratuite de la part de l'adversaire.\r\n  Les conséquences d'un critique lors d'un test\r\n  d'<strong>auto-résolution</strong> sont laissés à la discrétion du\r\n  <strong>maître du jeu</strong>.\r\n</p>\r\n\r\n<p>\r\n  Lors d'un <strong>succès critique</strong> il est toujours possible de\r\n  défier le destin : en échange des conséquences à venir, l'acteur du test peut\r\n  relancer le dé pour tenter de faire un score inférieur ou égal à 10%. Si le\r\n  second test est passé, le groupe se voit alors attribué un <strong>point de\r\n  destin</strong> pouvant être échangé contre un succès critique automatique de\r\n  n'importe quel test à venir.\r\n</p>\r\n\r\n<p>\r\n  Lors d'un <strong>échec critique</strong>, le <strong>maître du jeu</strong>\r\n  peut toujours invoquer la fatalité : en échange des conséquences à venir,\r\n  l'acteur doit relancer le dé pour tenter de faire un score inférieur ou égal\r\n  à 90%, dans le cas contraire, un <strong>point de fatalité</strong> est\r\n  attribué au groupe. Le point peut être alors échangé par le\r\n  <strong>maître du jeu</strong> contre un échec critique automatique de\r\n  n'importe quel test à venir.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/core-rules/reroll.twig":
/*!*****************************************!*\
  !*** ./src/twig/core-rules/reroll.twig ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#reroll\">\r\n  <h3 id=\"reroll\">Pousser le test</h3>\r\n</a>\r\n\r\n<p>\r\n  Lors d'un échec, qui n'est pas un <strong>échec critique</strong> et moyennant\r\n  une justification acceptée par le <strong>maître du jeu</strong>, un\r\n  personnage peut tenter de repasser un test qu'il vient juste d'échouer. Si\r\n  celui-ci réussi la seconde tentative alors le test est passé, s'il échoue une\r\n  seconde fois alors le test est échoué avec des conséquences néfastes\r\n  supplémentaires.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:fb224ebcb70ef72f8cf29adab6cb6a38a38164ac05d7f0cc31e98c4416ab644dc286db3875d5a1e529a2e6204e78380fa3e8cc11539b395e468b4bb53b4d582c:reroll.twig","data":[{"type":"raw","value":"<a href=\"#reroll\">\r\n  <h3 id=\"reroll\">Pousser le test</h3>\r\n</a>\r\n\r\n<p>\r\n  Lors d'un échec, qui n'est pas un <strong>échec critique</strong> et moyennant\r\n  une justification acceptée par le <strong>maître du jeu</strong>, un\r\n  personnage peut tenter de repasser un test qu'il vient juste d'échouer. Si\r\n  celui-ci réussi la seconde tentative alors le test est passé, s'il échoue une\r\n  seconde fois alors le test est échoué avec des conséquences néfastes\r\n  supplémentaires.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/core-rules/self-resolution.twig":
/*!**************************************************!*\
  !*** ./src/twig/core-rules/self-resolution.twig ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#self-resolution\">\r\n  <h3 id=\"self-resolution\">Auto-résolution</h3>\r\n</a>\r\n<p>\r\n  L'<strong>auto-résolution</strong> permet de mesurer la qualité de la\r\n  <strong>réussite</strong> d'une action en fonction des capacités seules d'un\r\n  personnage. C'est le test pour mesurer la dangerosité d'un piège installé,\r\n  la fiabilité d'une serrure ou la qualité d'une production d'alchimie.\r\n  L'<strong>auto résolution</strong> produit donc un degré de difficulté, ou une\r\n  qualité dépendamment que la production soit une épreuve ou un consomable.\r\n</p>\r\n\r\n<table class=\"text-center table-2d\">\r\n  <tbody>\r\n    <tr>\r\n      <th>18</th>\r\n    \t<td>20</td>\r\n    \t<td>19</td>\r\n    \t<td>19</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>9</td>\r\n    \t<td>6</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>17</th>\r\n    \t<td>20</td>\r\n    \t<td>19</td>\r\n    \t<td>19</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>8</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>16</th>\r\n    \t<td>19</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>8</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>15</th>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>7</td>\r\n    \t<td>5</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>14</th>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>7</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>13</th>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>6</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>12</th>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>6</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>11</th>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>5</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>10</th>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>9</th>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>8</th>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>7</th>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>6</th>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>5</th>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>4</th>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th>3</th>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th>2</th>\r\n      <td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th>1</th>\r\n      <td>4</td>\r\n      <td>3</td>\r\n      <td>3</td>\r\n      <td>2</td>\r\n      <td>2</td>\r\n      <td>2</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th style=\"width:35px\">0</th>\r\n      <td style=\"width:35px\">3</td>\r\n      <td style=\"width:35px\">2</td>\r\n      <td style=\"width:35px\">2</td>\r\n      <td style=\"width:35px\">1</td>\r\n      <td style=\"width:35px\">1</td>\r\n      <td style=\"width:35px\">1</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n    </tr>\r\n    <tr>\r\n      <th></th>\r\n      <th>5<span class=\"percent\">%</span></th>\r\n      <th>10<span class=\"percent\">%</span></th>\r\n      <th>15<span class=\"percent\">%</span></th>\r\n      <th>20<span class=\"percent\">%</span></th>\r\n      <th>25<span class=\"percent\">%</span></th>\r\n      <th>30<span class=\"percent\">%</span></th>\r\n      <th>35<span class=\"percent\">%</span></th>\r\n      <th>40<span class=\"percent\">%</span></th>\r\n      <th>45<span class=\"percent\">%</span></th>\r\n      <th>50<span class=\"percent\">%</span></th>\r\n      <th>55<span class=\"percent\">%</span></th>\r\n      <th>60<span class=\"percent\">%</span></th>\r\n      <th>65<span class=\"percent\">%</span></th>\r\n      <th>70<span class=\"percent\">%</span></th>\r\n      <th>75<span class=\"percent\">%</span></th>\r\n      <th>80<span class=\"percent\">%</span></th>\r\n      <th>85<span class=\"percent\">%</span></th>\r\n      <th>90<span class=\"percent\">%</span></th>\r\n      <th>95<span class=\"percent\">%</span></th>\r\n      <th>100<span class=\"percent\">%</span></th>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],
    template = twig({"id":"$resolved:d78bb9600889261ed38c8acdb8386cf6f0c15c6e9934669cba2da0c91a6cb6b6b5550ad419cdbbd336d5dd79b081a1d7d923722dd97d38fc0cf338ffe9dfa0a3:self-resolution.twig","data":[{"type":"raw","value":"<a href=\"#self-resolution\">\r\n  <h3 id=\"self-resolution\">Auto-résolution</h3>\r\n</a>\r\n<p>\r\n  L'<strong>auto-résolution</strong> permet de mesurer la qualité de la\r\n  <strong>réussite</strong> d'une action en fonction des capacités seules d'un\r\n  personnage. C'est le test pour mesurer la dangerosité d'un piège installé,\r\n  la fiabilité d'une serrure ou la qualité d'une production d'alchimie.\r\n  L'<strong>auto résolution</strong> produit donc un degré de difficulté, ou une\r\n  qualité dépendamment que la production soit une épreuve ou un consomable.\r\n</p>\r\n\r\n<table class=\"text-center table-2d\">\r\n  <tbody>\r\n    <tr>\r\n      <th>18</th>\r\n    \t<td>20</td>\r\n    \t<td>19</td>\r\n    \t<td>19</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>9</td>\r\n    \t<td>6</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>17</th>\r\n    \t<td>20</td>\r\n    \t<td>19</td>\r\n    \t<td>19</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>8</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>16</th>\r\n    \t<td>19</td>\r\n    \t<td>18</td>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>8</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>15</th>\r\n    \t<td>18</td>\r\n    \t<td>17</td>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>7</td>\r\n    \t<td>5</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    </tr>\r\n    <tr>\r\n      <th>14</th>\r\n    \t<td>17</td>\r\n    \t<td>16</td>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>7</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>13</th>\r\n    \t<td>16</td>\r\n    \t<td>15</td>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>6</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>12</th>\r\n    \t<td>15</td>\r\n    \t<td>14</td>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>6</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>11</th>\r\n    \t<td>14</td>\r\n    \t<td>13</td>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>5</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>10</th>\r\n    \t<td>13</td>\r\n    \t<td>12</td>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    </tr>\r\n    <tr>\r\n      <th>9</th>\r\n    \t<td>12</td>\r\n    \t<td>11</td>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>8</th>\r\n    \t<td>11</td>\r\n    \t<td>10</td>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>7</th>\r\n    \t<td>10</td>\r\n    \t<td>9</td>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>6</th>\r\n    \t<td>9</td>\r\n    \t<td>8</td>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>5</th>\r\n    \t<td>8</td>\r\n    \t<td>7</td>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    </tr>\r\n    <tr>\r\n      <th>4</th>\r\n    \t<td>7</td>\r\n    \t<td>6</td>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th>3</th>\r\n    \t<td>6</td>\r\n    \t<td>5</td>\r\n    \t<td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th>2</th>\r\n      <td>5</td>\r\n    \t<td>4</td>\r\n    \t<td>4</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>3</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>2</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>1</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    \t<td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th>1</th>\r\n      <td>4</td>\r\n      <td>3</td>\r\n      <td>3</td>\r\n      <td>2</td>\r\n      <td>2</td>\r\n      <td>2</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>1</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n      <td>0</td>\r\n    </tr>\r\n    <tr>\r\n      <th style=\"width:35px\">0</th>\r\n      <td style=\"width:35px\">3</td>\r\n      <td style=\"width:35px\">2</td>\r\n      <td style=\"width:35px\">2</td>\r\n      <td style=\"width:35px\">1</td>\r\n      <td style=\"width:35px\">1</td>\r\n      <td style=\"width:35px\">1</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n      <td style=\"width:35px\">0</td>\r\n    </tr>\r\n    <tr>\r\n      <th></th>\r\n      <th>5<span class=\"percent\">%</span></th>\r\n      <th>10<span class=\"percent\">%</span></th>\r\n      <th>15<span class=\"percent\">%</span></th>\r\n      <th>20<span class=\"percent\">%</span></th>\r\n      <th>25<span class=\"percent\">%</span></th>\r\n      <th>30<span class=\"percent\">%</span></th>\r\n      <th>35<span class=\"percent\">%</span></th>\r\n      <th>40<span class=\"percent\">%</span></th>\r\n      <th>45<span class=\"percent\">%</span></th>\r\n      <th>50<span class=\"percent\">%</span></th>\r\n      <th>55<span class=\"percent\">%</span></th>\r\n      <th>60<span class=\"percent\">%</span></th>\r\n      <th>65<span class=\"percent\">%</span></th>\r\n      <th>70<span class=\"percent\">%</span></th>\r\n      <th>75<span class=\"percent\">%</span></th>\r\n      <th>80<span class=\"percent\">%</span></th>\r\n      <th>85<span class=\"percent\">%</span></th>\r\n      <th>90<span class=\"percent\">%</span></th>\r\n      <th>95<span class=\"percent\">%</span></th>\r\n      <th>100<span class=\"percent\">%</span></th>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/core-rules/situational-dice.twig":
/*!***************************************************!*\
  !*** ./src/twig/core-rules/situational-dice.twig ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#situationnal-dice\">\r\n  <h3 id=\"situationnal-dice\">Bonus et malus situationnel</h3>\r\n</a>\r\n\r\n<p>\r\n  Quand une action intentée est bien argumentée, <strong>l'acteur</strong> peut\r\n  se voir attribuer un ou plusieurs dés de <strong>bonus situationnel</strong>.\r\n  L'<strong>acteur</strong> lance alors des dés de dizaines supplémentaires\r\n  et garde la dizaine la plus basse quand il calcule son score.\r\n</p>\r\n\r\n<p>\r\n  Quand une action intentée est douteuse ou mal argumentée,\r\n  <strong>l'acteur</strong> peut se voir attribuer un ou plusieurs dés de\r\n  <strong>malus situationnel</strong>. L'<strong>acteur</strong> lance alors des\r\n  dés de dizaines supplémentaires et garde la dizaine la plus haute quand il\r\n  calcule son score.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:d9e20bea94ff20510906ecd423395bc1cf1693cb3d0bf8bf004c375c653805cfd35db958f7e204fb77b1c73d6c30ce3c98e48889841e71d4d173276844077a91:situational-dice.twig","data":[{"type":"raw","value":"<a href=\"#situationnal-dice\">\r\n  <h3 id=\"situationnal-dice\">Bonus et malus situationnel</h3>\r\n</a>\r\n\r\n<p>\r\n  Quand une action intentée est bien argumentée, <strong>l'acteur</strong> peut\r\n  se voir attribuer un ou plusieurs dés de <strong>bonus situationnel</strong>.\r\n  L'<strong>acteur</strong> lance alors des dés de dizaines supplémentaires\r\n  et garde la dizaine la plus basse quand il calcule son score.\r\n</p>\r\n\r\n<p>\r\n  Quand une action intentée est douteuse ou mal argumentée,\r\n  <strong>l'acteur</strong> peut se voir attribuer un ou plusieurs dés de\r\n  <strong>malus situationnel</strong>. L'<strong>acteur</strong> lance alors des\r\n  dés de dizaines supplémentaires et garde la dizaine la plus haute quand il\r\n  calcule son score.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries.twig":
/*!*********************************!*\
  !*** ./src/twig/masteries.twig ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./masteries/canalyze.twig */ "./src/twig/masteries/canalyze.twig");

__webpack_require__(/*! ./masteries/sleight-of-hand.twig */ "./src/twig/masteries/sleight-of-hand.twig");

__webpack_require__(/*! ./masteries/perception.twig */ "./src/twig/masteries/perception.twig");

__webpack_require__(/*! ./masteries/swiming.twig */ "./src/twig/masteries/swiming.twig");

__webpack_require__(/*! ./masteries/search.twig */ "./src/twig/masteries/search.twig");

__webpack_require__(/*! ./masteries/dodge.twig */ "./src/twig/masteries/dodge.twig");

__webpack_require__(/*! ./masteries/climbing.twig */ "./src/twig/masteries/climbing.twig");

__webpack_require__(/*! ./masteries/horse-riding.twig */ "./src/twig/masteries/horse-riding.twig");

__webpack_require__(/*! ./masteries/discretion.twig */ "./src/twig/masteries/discretion.twig");

__webpack_require__(/*! ./masteries/crochetage.twig */ "./src/twig/masteries/crochetage.twig");

__webpack_require__(/*! ./masteries/acrobatics.twig */ "./src/twig/masteries/acrobatics.twig");

__webpack_require__(/*! ./masteries/introduction.twig */ "./src/twig/masteries/introduction.twig");

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<div class=\"row\">\r\n  <div class=\"col\">\r\n    <a href=\"#masteries\">\r\n      <h2 id=\"masteries\">Maîtrises</h2>\r\n    </a>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:ff8612456a2bbe0a1369c5dbb61d264142d1becd235fb38901658e463842753481ac10ae99a8c96d36c730b7b94c6d8d97c1703d5fcd64b516a98123ba75557c:introduction.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div><!-- /.skills -->\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:4ef7777257e56ef92f38078b1c73bc54c5ecf02a67c4c9623451a2bc067b67b765e953b52793479585fdf21282a3c0324b3d986cebf4f869f5cb0c8e4219b244:acrobatics.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:522ad7e37a961f81e82f7ac1d61f23f775cd8b8ae77b739986e937b11975bc0e494ce2df6203a75edb2d7c7e53d3c0e023782af14987b07f5b0a033024297da8:crochetage.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:5b7b62f6bc474ce9c40237551873c129434cc5ff2ad93f7ee2db86fa8190da1b00c0006f49d0828916f966107c59270b967b984fe10aec9eb5dfe4d865f1be2c:discretion.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:99394bf5f4170b10c13bbdcad51d49f2d1d40d43546ea71eba2541528451cd5a952012e6e0f1596889178341d1ec3bae5305f47ae938af574bf6e7bcb41b7bff:horse-riding.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:daac987daf4878b614104040771baed2b33e874fdc73f190302ed46c5108fea907a622aecf00483f921cb304a27bf346c8ed382ae840ba282dfd14e9244249cc:climbing.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:29eb38a61e3c410507d2a8725a2502d9e8ee3b70e904cd7ee14fba578e7955fc756f27a76a1626c7ed123442904ba18a97b2a1feab0345cbee6cf1a7c6e34aee:dodge.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:06dfd8e39be04e67a711abcf17786433986029ffe2b7256db37047bc29c65c674a37812727d4a935cbeb080c79ecf107ad63be64e2ff7737a8856bcf2b97a628:search.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:79b2ec1da337717cdcb9fe5fb066f1e7a51ea61e0405f639bc98ff3c8e3070d28f5416cdf8d2a2c45bd2fece87b445548c6d5956ca87a6e29d17150d1de03231:swiming.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:460da7cf0e6d3538b29ee03c96e57f68d0cf87d3faa8e8af7078ebbff4c308ac45a8121a26e2ce624a6dd995badf2daafd4e8f410b231a15f30f872becf2b5e4:perception.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:7d09c78987cafeecb0e0314fcb52e153b249f5fc2d05f6aa9c312e9a97f3d070fe46d33c33907dec54fa97e0e438754b9ef3ddb009de69e08e6b0ec5d1e4564c:sleight-of-hand.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:d7a22121de96cf15083042af9267ffbf5b2c7f45cdf2ad317af3e7bdcf26c8a3a87a69607d3e081c52ab5ef2ec0da26014a1f185ec755906ef68eebeb0571262:canalyze.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n  </div>\r\n</div>\r\n"}],
    template = twig({"id":"$resolved:290496b7e8a3c38cb77d3d5126c1f0df8d7fbdc0bfe13ae23c4169e7915a6801e173a4f28dd8c7fc734e1cde0896f60749fb883d2c02f8933f25286952b105d7:masteries.twig","data":[{"type":"raw","value":"<div class=\"row\">\r\n  <div class=\"col\">\r\n    <a href=\"#masteries\">\r\n      <h2 id=\"masteries\">Maîtrises</h2>\r\n    </a>\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:ff8612456a2bbe0a1369c5dbb61d264142d1becd235fb38901658e463842753481ac10ae99a8c96d36c730b7b94c6d8d97c1703d5fcd64b516a98123ba75557c:introduction.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div><!-- /.skills -->\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:4ef7777257e56ef92f38078b1c73bc54c5ecf02a67c4c9623451a2bc067b67b765e953b52793479585fdf21282a3c0324b3d986cebf4f869f5cb0c8e4219b244:acrobatics.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:522ad7e37a961f81e82f7ac1d61f23f775cd8b8ae77b739986e937b11975bc0e494ce2df6203a75edb2d7c7e53d3c0e023782af14987b07f5b0a033024297da8:crochetage.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:5b7b62f6bc474ce9c40237551873c129434cc5ff2ad93f7ee2db86fa8190da1b00c0006f49d0828916f966107c59270b967b984fe10aec9eb5dfe4d865f1be2c:discretion.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:99394bf5f4170b10c13bbdcad51d49f2d1d40d43546ea71eba2541528451cd5a952012e6e0f1596889178341d1ec3bae5305f47ae938af574bf6e7bcb41b7bff:horse-riding.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:daac987daf4878b614104040771baed2b33e874fdc73f190302ed46c5108fea907a622aecf00483f921cb304a27bf346c8ed382ae840ba282dfd14e9244249cc:climbing.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:29eb38a61e3c410507d2a8725a2502d9e8ee3b70e904cd7ee14fba578e7955fc756f27a76a1626c7ed123442904ba18a97b2a1feab0345cbee6cf1a7c6e34aee:dodge.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:06dfd8e39be04e67a711abcf17786433986029ffe2b7256db37047bc29c65c674a37812727d4a935cbeb080c79ecf107ad63be64e2ff7737a8856bcf2b97a628:search.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:79b2ec1da337717cdcb9fe5fb066f1e7a51ea61e0405f639bc98ff3c8e3070d28f5416cdf8d2a2c45bd2fece87b445548c6d5956ca87a6e29d17150d1de03231:swiming.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:460da7cf0e6d3538b29ee03c96e57f68d0cf87d3faa8e8af7078ebbff4c308ac45a8121a26e2ce624a6dd995badf2daafd4e8f410b231a15f30f872becf2b5e4:perception.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:7d09c78987cafeecb0e0314fcb52e153b249f5fc2d05f6aa9c312e9a97f3d070fe46d33c33907dec54fa97e0e438754b9ef3ddb009de69e08e6b0ec5d1e4564c:sleight-of-hand.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n</div>\r\n\r\n<div class=\"row\">\r\n  <div class=\"col-xs-12 col-md-6\">\r\n    "},{"type":"logic","token":{"type":"Twig.logic.type.include","only":false,"ignoreMissing":false,"stack":[{"type":"Twig.expression.type.string","value":"$resolved:d7a22121de96cf15083042af9267ffbf5b2c7f45cdf2ad317af3e7bdcf26c8a3a87a69607d3e081c52ab5ef2ec0da26014a1f185ec755906ef68eebeb0571262:canalyze.twig"}]}},{"type":"raw","value":"\r\n  </div>\r\n  <div class=\"col-xs-12 col-md-6\">\r\n  </div>\r\n</div>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/acrobatics.twig":
/*!********************************************!*\
  !*** ./src/twig/masteries/acrobatics.twig ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#acrobatic\">\r\n  <h3 id=\"acrobatic\">Acrobatie</h3>\r\n</a>\r\n\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n  <span class=\"badge badge-secondary\">Force</span>\r\n</p>\r\n\r\n<p>\r\n  La maîtrise de l'<strong>acrobatie</strong> apprécie la capacité à utiliser\r\n  son corps de manière ingénieuse mais dangereuse pour s'extirper de situations\r\n  délicates. Sauter en travers d'un ravin, passer sous les jambes d'un\r\n  adversaire ou courrir en terrain difficile sont des exemples de situation où\r\n  un test d'acrobatie est nécéssaire.\r\n</p>\r\n\r\n<p>\r\n  Une <strong>acrobatie</strong> réalisée contre l'environnement se fait contre\r\n  le degré de difficulté de celui-ci. Dans le cas où\r\n  l'<strong>acrobatie</strong> vise un autre personnage, les règles de\r\n  l'<strong>esquive</strong> et de la <strong>parade</strong> s'appliquent en\r\n  opposition avec le niveau de maîtrise de l'acrobate. Certaines manoeuvres\r\n  peuvent nécéssiter de réaliser un test en opposition avec leur propre degré\r\n  de difficulté avant tout autre test.\r\n</p>\r\n\r\n<table class=\"table\">\r\n  <thead>\r\n    <tr>\r\n      <th colspan=\"2\">Atouts</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><strong>Parkour</strong></td>\r\n      <td>Acrobatie: 4+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Lorsqu'une acrobatie est réalisée dans le but de se déplacer rapidement\r\n        en terrain difficile, celle-ci se voie attribuer une bonus de +10%.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive acrobatique I</strong></td>\r\n      <td>Acrobatie: 8+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, une esquive\r\n        acrobatique est résolue comme une acrobatie dont le succès\r\n        aboutit aux effets d'une esquive standard. Lors d'une esquive\r\n        acrobatique le personnage subit un malus de 20% sur sa tentative\r\n        d'esquive.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Vol contrôlé</strong></td>\r\n      <td>Acrobatie: 12+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Si une acrobatie visant un autre personnage échoue alors l'acteur peut\r\n        se rattraper in-extremis en passant un test d'acrobatie DD 16 afin\r\n        d'annuler tous les effets de la parade ou de l'esquive de la victime.\r\n        Si la victime a intentée une esquive ou une parade celle-ci est\r\n        décomptée de son compte d'esquive ou de parade du round en cours.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive acrobatique II</strong></td>\r\n      <td>Acrobatie: 14+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, une esquive\r\n        acrobatique est résolue comme une acrobatie dont le succès\r\n        aboutit aux effets d'une esquive standard. Lors d'une esquive\r\n        acrobatique le personnage subit un malus de 20% sur sa tentative\r\n        d'esquive.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Parade acrobatique</strong></td>\r\n      <td>Acrobatie: 16+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une parade supplémentaire par round, cette parade\r\n        est résolue comme une acrobatie dont le succès aboutit aux effets d'une\r\n        parade standard.\r\n      </td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],
    template = twig({"id":"$resolved:4ef7777257e56ef92f38078b1c73bc54c5ecf02a67c4c9623451a2bc067b67b765e953b52793479585fdf21282a3c0324b3d986cebf4f869f5cb0c8e4219b244:acrobatics.twig","data":[{"type":"raw","value":"<a href=\"#acrobatic\">\r\n  <h3 id=\"acrobatic\">Acrobatie</h3>\r\n</a>\r\n\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n  <span class=\"badge badge-secondary\">Force</span>\r\n</p>\r\n\r\n<p>\r\n  La maîtrise de l'<strong>acrobatie</strong> apprécie la capacité à utiliser\r\n  son corps de manière ingénieuse mais dangereuse pour s'extirper de situations\r\n  délicates. Sauter en travers d'un ravin, passer sous les jambes d'un\r\n  adversaire ou courrir en terrain difficile sont des exemples de situation où\r\n  un test d'acrobatie est nécéssaire.\r\n</p>\r\n\r\n<p>\r\n  Une <strong>acrobatie</strong> réalisée contre l'environnement se fait contre\r\n  le degré de difficulté de celui-ci. Dans le cas où\r\n  l'<strong>acrobatie</strong> vise un autre personnage, les règles de\r\n  l'<strong>esquive</strong> et de la <strong>parade</strong> s'appliquent en\r\n  opposition avec le niveau de maîtrise de l'acrobate. Certaines manoeuvres\r\n  peuvent nécéssiter de réaliser un test en opposition avec leur propre degré\r\n  de difficulté avant tout autre test.\r\n</p>\r\n\r\n<table class=\"table\">\r\n  <thead>\r\n    <tr>\r\n      <th colspan=\"2\">Atouts</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><strong>Parkour</strong></td>\r\n      <td>Acrobatie: 4+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Lorsqu'une acrobatie est réalisée dans le but de se déplacer rapidement\r\n        en terrain difficile, celle-ci se voie attribuer une bonus de +10%.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive acrobatique I</strong></td>\r\n      <td>Acrobatie: 8+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, une esquive\r\n        acrobatique est résolue comme une acrobatie dont le succès\r\n        aboutit aux effets d'une esquive standard. Lors d'une esquive\r\n        acrobatique le personnage subit un malus de 20% sur sa tentative\r\n        d'esquive.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Vol contrôlé</strong></td>\r\n      <td>Acrobatie: 12+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Si une acrobatie visant un autre personnage échoue alors l'acteur peut\r\n        se rattraper in-extremis en passant un test d'acrobatie DD 16 afin\r\n        d'annuler tous les effets de la parade ou de l'esquive de la victime.\r\n        Si la victime a intentée une esquive ou une parade celle-ci est\r\n        décomptée de son compte d'esquive ou de parade du round en cours.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive acrobatique II</strong></td>\r\n      <td>Acrobatie: 14+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, une esquive\r\n        acrobatique est résolue comme une acrobatie dont le succès\r\n        aboutit aux effets d'une esquive standard. Lors d'une esquive\r\n        acrobatique le personnage subit un malus de 20% sur sa tentative\r\n        d'esquive.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Parade acrobatique</strong></td>\r\n      <td>Acrobatie: 16+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une parade supplémentaire par round, cette parade\r\n        est résolue comme une acrobatie dont le succès aboutit aux effets d'une\r\n        parade standard.\r\n      </td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/canalyze.twig":
/*!******************************************!*\
  !*** ./src/twig/masteries/canalyze.twig ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Canalyser</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Pouvoir</span>\r\n</p>\r\n<p></p>\r\n"}],
    template = twig({"id":"$resolved:d7a22121de96cf15083042af9267ffbf5b2c7f45cdf2ad317af3e7bdcf26c8a3a87a69607d3e081c52ab5ef2ec0da26014a1f185ec755906ef68eebeb0571262:canalyze.twig","data":[{"type":"raw","value":"<h3>Canalyser</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Pouvoir</span>\r\n</p>\r\n<p></p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/climbing.twig":
/*!******************************************!*\
  !*** ./src/twig/masteries/climbing.twig ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Escalade</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Force</span>\r\n  <span class=\"badge badge-secondary\">Constitution</span>\r\n</p>\r\n<p></p>\r\n"}],
    template = twig({"id":"$resolved:daac987daf4878b614104040771baed2b33e874fdc73f190302ed46c5108fea907a622aecf00483f921cb304a27bf346c8ed382ae840ba282dfd14e9244249cc:climbing.twig","data":[{"type":"raw","value":"<h3>Escalade</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Force</span>\r\n  <span class=\"badge badge-secondary\">Constitution</span>\r\n</p>\r\n<p></p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/crochetage.twig":
/*!********************************************!*\
  !*** ./src/twig/masteries/crochetage.twig ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Crochetage</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n  <span class=\"badge badge-secondary\">Chance</span>\r\n</p>\r\n<p>\r\n  La compétence crochetage évalue la capacité d'un personnage à\r\n  se jouer de toutes sortes de serrures et de mécanismes. Tenter\r\n  d'ouvrir une porte ou un coffre sans sa clef, de désactiver une\r\n  éventuelle alarme ou désamorcer un piège sont des exemples de\r\n  situations ou un test de crochetage est nécéssaire.\r\n</p>\r\n<p>\r\n  Une tentative de crochetage se joue toujours en opposition avec le\r\n  niveau de difficulté du mécanisme à forcer.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:522ad7e37a961f81e82f7ac1d61f23f775cd8b8ae77b739986e937b11975bc0e494ce2df6203a75edb2d7c7e53d3c0e023782af14987b07f5b0a033024297da8:crochetage.twig","data":[{"type":"raw","value":"<h3>Crochetage</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n  <span class=\"badge badge-secondary\">Chance</span>\r\n</p>\r\n<p>\r\n  La compétence crochetage évalue la capacité d'un personnage à\r\n  se jouer de toutes sortes de serrures et de mécanismes. Tenter\r\n  d'ouvrir une porte ou un coffre sans sa clef, de désactiver une\r\n  éventuelle alarme ou désamorcer un piège sont des exemples de\r\n  situations ou un test de crochetage est nécéssaire.\r\n</p>\r\n<p>\r\n  Une tentative de crochetage se joue toujours en opposition avec le\r\n  niveau de difficulté du mécanisme à forcer.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/discretion.twig":
/*!********************************************!*\
  !*** ./src/twig/masteries/discretion.twig ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Discrétion</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n<p>\r\n  Le score de discrétion représente la capacité d'un personnage à ne\r\n  pas se faire voir ni entendre. Un jet de discrétion se fait toujours\r\n  en opposition avec la compétence de perception.\r\n</p>\r\n<p>\r\n  Les tests opposés de perception ne peuvent être joués que si le\r\n  personnage cherchant à se faire discret est observable d'une\r\n  quelconque manière, aussi, si la vision de l'observateur est\r\n  obstruée ou que son audition est extrêmement mauvaise aucun jet de\r\n  perception ne peut être réalisé.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:5b7b62f6bc474ce9c40237551873c129434cc5ff2ad93f7ee2db86fa8190da1b00c0006f49d0828916f966107c59270b967b984fe10aec9eb5dfe4d865f1be2c:discretion.twig","data":[{"type":"raw","value":"<h3>Discrétion</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n<p>\r\n  Le score de discrétion représente la capacité d'un personnage à ne\r\n  pas se faire voir ni entendre. Un jet de discrétion se fait toujours\r\n  en opposition avec la compétence de perception.\r\n</p>\r\n<p>\r\n  Les tests opposés de perception ne peuvent être joués que si le\r\n  personnage cherchant à se faire discret est observable d'une\r\n  quelconque manière, aussi, si la vision de l'observateur est\r\n  obstruée ou que son audition est extrêmement mauvaise aucun jet de\r\n  perception ne peut être réalisé.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/dodge.twig":
/*!***************************************!*\
  !*** ./src/twig/masteries/dodge.twig ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<a href=\"#dodge\">\r\n  <h3 id=\"dodge\">Esquive</h3>\r\n</a>\r\n\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n\r\n<p>\r\n  La <strong>maîtrise de l'esquive</strong> apprécie la capacité d'un personnage\r\n  à se mouvoir dans l'objectif d'échapper à une menace.\r\n  L'<strong>esquive</strong> est une maîtrise importante pour les combats car\r\n  elle permet d'éviter un coup par tour tout en se repositionnant. Elle est\r\n  aussi la seule compétence permettant d'échapper à certains pièges ou\r\n  sortilèges.\r\n</p>\r\n\r\n<p>\r\n  L'<strong>esquive</strong> se joue toujours en opposition avec le degré de\r\n  difficulté de la menace. Esquiver une attaque influera les chances de succès\r\n  de l'attaquant vis-à-vis de sa propre maîtrise de son arme. Esquiver un sort\r\n  ou un piège influera ses chances de succès vis-à-vis de son propre degré de\r\n  difficulté. Le succès d'une esquive peut être mitigé dans certaines\r\n  situations.\r\n</p>\r\n\r\n<table class=\"table\">\r\n  <thead>\r\n    <tr>\r\n      <th colspan=\"2\">Atouts</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><strong>Esquive totale</strong></td>\r\n      <td>Esquive: 4+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage peut toujours choisir de jouer en dernier et de gagner une\r\n        esquive supplémentaire lors du round en cours en échange d'une action\r\n        de mouvement.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive en chaîne I</strong></td>\r\n      <td>Esquive: 8+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, chaque esquive\r\n        supplémentaire jouée durant un round se voit attribuée un malus de 10%\r\n        cumulatif.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive en chaîne II</strong></td>\r\n      <td>Esquive: 12+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, chaque esquive\r\n        supplémentaire jouée durant un round se voit attribuée un malus de 10%\r\n        cumulatif.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive instinctive</strong></td>\r\n      <td>Esquive: 14+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage peut tenter d'esquiver les flèches avec un malus de 25%\r\n        sur son jet d'esquive.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Danse des vents</strong></td>\r\n      <td>Esquive: 16+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round. Avec cet atout\r\n        le malus attribué à un enchaînement d'esquive durant un round est réduit\r\n        à 5% cumulatif.\r\n      </td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],
    template = twig({"id":"$resolved:29eb38a61e3c410507d2a8725a2502d9e8ee3b70e904cd7ee14fba578e7955fc756f27a76a1626c7ed123442904ba18a97b2a1feab0345cbee6cf1a7c6e34aee:dodge.twig","data":[{"type":"raw","value":"<a href=\"#dodge\">\r\n  <h3 id=\"dodge\">Esquive</h3>\r\n</a>\r\n\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n\r\n<p>\r\n  La <strong>maîtrise de l'esquive</strong> apprécie la capacité d'un personnage\r\n  à se mouvoir dans l'objectif d'échapper à une menace.\r\n  L'<strong>esquive</strong> est une maîtrise importante pour les combats car\r\n  elle permet d'éviter un coup par tour tout en se repositionnant. Elle est\r\n  aussi la seule compétence permettant d'échapper à certains pièges ou\r\n  sortilèges.\r\n</p>\r\n\r\n<p>\r\n  L'<strong>esquive</strong> se joue toujours en opposition avec le degré de\r\n  difficulté de la menace. Esquiver une attaque influera les chances de succès\r\n  de l'attaquant vis-à-vis de sa propre maîtrise de son arme. Esquiver un sort\r\n  ou un piège influera ses chances de succès vis-à-vis de son propre degré de\r\n  difficulté. Le succès d'une esquive peut être mitigé dans certaines\r\n  situations.\r\n</p>\r\n\r\n<table class=\"table\">\r\n  <thead>\r\n    <tr>\r\n      <th colspan=\"2\">Atouts</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td><strong>Esquive totale</strong></td>\r\n      <td>Esquive: 4+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage peut toujours choisir de jouer en dernier et de gagner une\r\n        esquive supplémentaire lors du round en cours en échange d'une action\r\n        de mouvement.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive en chaîne I</strong></td>\r\n      <td>Esquive: 8+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, chaque esquive\r\n        supplémentaire jouée durant un round se voit attribuée un malus de 10%\r\n        cumulatif.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive en chaîne II</strong></td>\r\n      <td>Esquive: 12+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round, chaque esquive\r\n        supplémentaire jouée durant un round se voit attribuée un malus de 10%\r\n        cumulatif.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Esquive instinctive</strong></td>\r\n      <td>Esquive: 14+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage peut tenter d'esquiver les flèches avec un malus de 25%\r\n        sur son jet d'esquive.\r\n      </td>\r\n    </tr>\r\n    <tr>\r\n      <td><strong>Danse des vents</strong></td>\r\n      <td>Esquive: 16+</td>\r\n    </tr>\r\n    <tr>\r\n      <td colspan=\"2\">\r\n        Le personnage gagne une esquive supplémentaire par round. Avec cet atout\r\n        le malus attribué à un enchaînement d'esquive durant un round est réduit\r\n        à 5% cumulatif.\r\n      </td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/horse-riding.twig":
/*!**********************************************!*\
  !*** ./src/twig/masteries/horse-riding.twig ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Équitation</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n<p>\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:99394bf5f4170b10c13bbdcad51d49f2d1d40d43546ea71eba2541528451cd5a952012e6e0f1596889178341d1ec3bae5305f47ae938af574bf6e7bcb41b7bff:horse-riding.twig","data":[{"type":"raw","value":"<h3>Équitation</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n<p>\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/introduction.twig":
/*!**********************************************!*\
  !*** ./src/twig/masteries/introduction.twig ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<p>\r\n  Les <strong>maîtrises</strong> sont des champs disciplinaires nécéssitant une\r\n  part d'inné et une part d'acquis. Chaque <strong>maîtrise</strong> est\r\n  appréciée sur une échelle de 18 points et, contrairement aux\r\n  <strong>caractéristiques</strong>, une <strong>maîtrise</strong> peut être\r\n  nulle. Un joueur ne peut investir que jusqu'à 12 points dans chaque\r\n  <strong>maîtrise</strong>, ces points représentent l'acquis lié à\r\n  l'expérience. Les 6 points restant sont attribués en fonction des\r\n  <strong>caractéristiques</strong> du héros et représentent quand à\r\n  eux la part d'instinct du personnage.\r\n</p>\r\n\r\n<p>\r\n  Le <strong>modificateur d'instinct</strong> est calculé en utilisant de\r\n  une à deux <strong>caractéristiques</strong>. Si une <strong>maîtrise</strong>\r\n  est affilié à une unique <strong>caractéristique</strong> le personnage\r\n  profite d'un bonus ou subit un malus instinctif de 5 points maximum.\r\n  Dans le cas où la <strong>maîtrise</strong> est affiliée à deux\r\n  <strong>caractéristique</strong> la <strong>caractéristique</strong> dite\r\n  majeure peut impacter le personnage jusqu'à 3 points maximum et la\r\n  <strong>caractéristique</strong> secondaire peut impacter le personnage\r\n  jusqu'à 2 points maximum. Dans tous les cas, le dernier point du\r\n  <strong>modificateur d'instinct</strong> est toujours le bonus ou malus global\r\n  de <strong>chance</strong>.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:ff8612456a2bbe0a1369c5dbb61d264142d1becd235fb38901658e463842753481ac10ae99a8c96d36c730b7b94c6d8d97c1703d5fcd64b516a98123ba75557c:introduction.twig","data":[{"type":"raw","value":"<p>\r\n  Les <strong>maîtrises</strong> sont des champs disciplinaires nécéssitant une\r\n  part d'inné et une part d'acquis. Chaque <strong>maîtrise</strong> est\r\n  appréciée sur une échelle de 18 points et, contrairement aux\r\n  <strong>caractéristiques</strong>, une <strong>maîtrise</strong> peut être\r\n  nulle. Un joueur ne peut investir que jusqu'à 12 points dans chaque\r\n  <strong>maîtrise</strong>, ces points représentent l'acquis lié à\r\n  l'expérience. Les 6 points restant sont attribués en fonction des\r\n  <strong>caractéristiques</strong> du héros et représentent quand à\r\n  eux la part d'instinct du personnage.\r\n</p>\r\n\r\n<p>\r\n  Le <strong>modificateur d'instinct</strong> est calculé en utilisant de\r\n  une à deux <strong>caractéristiques</strong>. Si une <strong>maîtrise</strong>\r\n  est affilié à une unique <strong>caractéristique</strong> le personnage\r\n  profite d'un bonus ou subit un malus instinctif de 5 points maximum.\r\n  Dans le cas où la <strong>maîtrise</strong> est affiliée à deux\r\n  <strong>caractéristique</strong> la <strong>caractéristique</strong> dite\r\n  majeure peut impacter le personnage jusqu'à 3 points maximum et la\r\n  <strong>caractéristique</strong> secondaire peut impacter le personnage\r\n  jusqu'à 2 points maximum. Dans tous les cas, le dernier point du\r\n  <strong>modificateur d'instinct</strong> est toujours le bonus ou malus global\r\n  de <strong>chance</strong>.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/perception.twig":
/*!********************************************!*\
  !*** ./src/twig/masteries/perception.twig ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Perception</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n<p>\r\n  La perception représente la capacité d'un personnage à utiliser ses\r\n  sens pour analyser son environnement. Tenter d'écouter des\r\n  conversations lointaines, de trouver un autre personnage cherchant\r\n  à se faire discret ou chercher des mécanismes cachés dans le sol et\r\n  les murs sont des actions nécéssitant un jet de perception.\r\n</p>\r\n<p>\r\n  Si la perception se fait à l'encontre d'un autre personnage elle se\r\n  joue contre la compétence qu'il utilise au moment où la perception\r\n  est joué. Un test de perception contre discrétion est un cas\r\n  d'école. Dans le cas où la perception se joue contre l'environnement\r\n  elle se fera contre son degré de difficulté.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:460da7cf0e6d3538b29ee03c96e57f68d0cf87d3faa8e8af7078ebbff4c308ac45a8121a26e2ce624a6dd995badf2daafd4e8f410b231a15f30f872becf2b5e4:perception.twig","data":[{"type":"raw","value":"<h3>Perception</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n</p>\r\n<p>\r\n  La perception représente la capacité d'un personnage à utiliser ses\r\n  sens pour analyser son environnement. Tenter d'écouter des\r\n  conversations lointaines, de trouver un autre personnage cherchant\r\n  à se faire discret ou chercher des mécanismes cachés dans le sol et\r\n  les murs sont des actions nécéssitant un jet de perception.\r\n</p>\r\n<p>\r\n  Si la perception se fait à l'encontre d'un autre personnage elle se\r\n  joue contre la compétence qu'il utilise au moment où la perception\r\n  est joué. Un test de perception contre discrétion est un cas\r\n  d'école. Dans le cas où la perception se joue contre l'environnement\r\n  elle se fera contre son degré de difficulté.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/search.twig":
/*!****************************************!*\
  !*** ./src/twig/masteries/search.twig ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Fouille</h3>\r\n\r\n<p>\r\n  <span class=\"badge badge-primary\">Chance</span>\r\n</p>\r\n\r\n<p>\r\n  La compétence fouille évalue la capacité d'un personnage à trouver\r\n  ce qu'il cherche dans un environnement étranger. Un personnage avec\r\n  une bonne compétence fouille est donc capable d'estimer précisément\r\n  si un document est présent dans une pièce qu'il vient de forcer, de\r\n  délester un cadavre de ses biens de valeur en un temps record ou de\r\n  rechercher d'éventuels passages secrets et pièges.\r\n</p>\r\n\r\n<p>\r\n  La compétence fouille se joue toujours en opposition du degré de\r\n  difficulté de l'objet ou du sujet recherché. Si le sujet de la\r\n  fouille à été intentionellement dissimulé la fouille se joue contre\r\n  le degré de succès de la tentative de dissimulation. Quand aux\r\n  éléments en évidence ils doivnet toujours être portées à la\r\n  connaissance du joueur.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:06dfd8e39be04e67a711abcf17786433986029ffe2b7256db37047bc29c65c674a37812727d4a935cbeb080c79ecf107ad63be64e2ff7737a8856bcf2b97a628:search.twig","data":[{"type":"raw","value":"<h3>Fouille</h3>\r\n\r\n<p>\r\n  <span class=\"badge badge-primary\">Chance</span>\r\n</p>\r\n\r\n<p>\r\n  La compétence fouille évalue la capacité d'un personnage à trouver\r\n  ce qu'il cherche dans un environnement étranger. Un personnage avec\r\n  une bonne compétence fouille est donc capable d'estimer précisément\r\n  si un document est présent dans une pièce qu'il vient de forcer, de\r\n  délester un cadavre de ses biens de valeur en un temps record ou de\r\n  rechercher d'éventuels passages secrets et pièges.\r\n</p>\r\n\r\n<p>\r\n  La compétence fouille se joue toujours en opposition du degré de\r\n  difficulté de l'objet ou du sujet recherché. Si le sujet de la\r\n  fouille à été intentionellement dissimulé la fouille se joue contre\r\n  le degré de succès de la tentative de dissimulation. Quand aux\r\n  éléments en évidence ils doivnet toujours être portées à la\r\n  connaissance du joueur.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/sleight-of-hand.twig":
/*!*************************************************!*\
  !*** ./src/twig/masteries/sleight-of-hand.twig ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Vol à la tire</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n  <span class=\"badge badge-secondary\">Chance</span>\r\n</p>\r\n<p>\r\n  La compétence vol à la tire évalue la capacité d'un personnage\r\n  à subtiliser les biens d'un portées par un autre sans éveiller son\r\n  attention. Une tentative de vol à la tire s'effectue toujours en\r\n  opposition avec la compétence de perception de la victime. Tout\r\n  comme la compétence discrétion, un test de vol à la tire n'a lieu\r\n  que si la victime est capable de percevoir le voleur d'une\r\n  quelconque manière.\r\n</p>\r\n"}],
    template = twig({"id":"$resolved:7d09c78987cafeecb0e0314fcb52e153b249f5fc2d05f6aa9c312e9a97f3d070fe46d33c33907dec54fa97e0e438754b9ef3ddb009de69e08e6b0ec5d1e4564c:sleight-of-hand.twig","data":[{"type":"raw","value":"<h3>Vol à la tire</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Dextérité</span>\r\n  <span class=\"badge badge-secondary\">Chance</span>\r\n</p>\r\n<p>\r\n  La compétence vol à la tire évalue la capacité d'un personnage\r\n  à subtiliser les biens d'un portées par un autre sans éveiller son\r\n  attention. Une tentative de vol à la tire s'effectue toujours en\r\n  opposition avec la compétence de perception de la victime. Tout\r\n  comme la compétence discrétion, un test de vol à la tire n'a lieu\r\n  que si la victime est capable de percevoir le voleur d'une\r\n  quelconque manière.\r\n</p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ "./src/twig/masteries/swiming.twig":
/*!*****************************************!*\
  !*** ./src/twig/masteries/swiming.twig ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var twig = __webpack_require__(/*! twig */ "./node_modules/twig/twig.js").twig,
    tokens = [{"type":"raw","value":"<h3>Natation</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Force</span>\r\n  <span class=\"badge badge-secondary\">Constitution</span>\r\n</p>\r\n<p></p>\r\n"}],
    template = twig({"id":"$resolved:79b2ec1da337717cdcb9fe5fb066f1e7a51ea61e0405f639bc98ff3c8e3070d28f5416cdf8d2a2c45bd2fece87b445548c6d5956ca87a6e29d17150d1de03231:swiming.twig","data":[{"type":"raw","value":"<h3>Natation</h3>\r\n<p>\r\n  <span class=\"badge badge-primary\">Force</span>\r\n  <span class=\"badge badge-secondary\">Constitution</span>\r\n</p>\r\n<p></p>\r\n"}],"allowInlineIncludes":true,"rethrow":true});

module.exports = function(context) { return template.render(context); }

module.exports.tokens = tokens;

/***/ }),

/***/ 0:
/*!***************************************************!*\
  !*** multi ./src/js/index.ts ./src/scss/app.scss ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! D:\development\rpg\src\js\index.ts */"./src/js/index.ts");
module.exports = __webpack_require__(/*! D:\development\rpg\src\scss\app.scss */"./src/scss/app.scss");


/***/ }),

/***/ 1:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });